msgid ""
msgstr ""
"Project-Id-Version: gb-asm-tutorial\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-10-27 11:19\n"
"Last-Translator: \n"
"Language-Team: Italian\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: it\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Crowdin-Project: gb-asm-tutorial\n"
"X-Crowdin-Project-ID: 572129\n"
"X-Crowdin-Language: it\n"
"X-Crowdin-File: messages.pot\n"
"X-Crowdin-File-ID: 3\n"

#: src/SUMMARY.md:1
msgid "Home"
msgstr "Home"

#: src/SUMMARY.md:2
msgid "Roadmap"
msgstr "Tabella di marcia"

#: src/SUMMARY.md:3
msgid "Help"
msgstr "Aiuto"

#: src/SUMMARY.md:5
msgid "Part ‚Ö† ‚Äî Hello World!"
msgstr "Parte ‚Ö† - Hello World!"

#: src/SUMMARY.md:7
msgid "Setup"
msgstr "Configurazione"

#: src/SUMMARY.md:8
msgid "Hello World!"
msgstr "Hello World!"

#: src/SUMMARY.md:9
msgid "The toolchain"
msgstr "Strumenti di lavoro"

#: src/SUMMARY.md:10
msgid "Binary and hexadecimal"
msgstr "Binario ed esadecimale"

#: src/SUMMARY.md:11
msgid "Registers"
msgstr "Registri"

#: src/SUMMARY.md:12
msgid "Assembly basics"
msgstr "Basi di Assembly"

#: src/SUMMARY.md:13
msgid "Memory"
msgstr "Memoria"

#: src/SUMMARY.md:14
msgid "The header"
msgstr "L'header"

#: src/SUMMARY.md:15
msgid "Operations & flags"
msgstr "Operazioni e flags"

#: src/SUMMARY.md:16
msgid "Jumps"
msgstr "Salti"

#: src/SUMMARY.md:17
msgid "Tracing"
msgstr "Tracciamento"

#: src/SUMMARY.md:18
msgid "Graphics"
msgstr "Grafica"

#: src/SUMMARY.md:19
msgid "Tiles"
msgstr "Tiles"

#: src/SUMMARY.md:20
msgid "Palettes"
msgstr "Palette"

#: src/SUMMARY.md:21
msgid "Tilemap"
msgstr "Tilemap"

#: src/SUMMARY.md:22
msgid "Wrapping up"
msgstr "In conclusione"

#: src/SUMMARY.md:24
msgid "Part ‚Ö° ‚Äî Our first game"
msgstr "Parte ‚Ö° - Il nostro primo gioco"

#: src/SUMMARY.md:26
msgid "Getting started"
msgstr "Per iniziare"

#: src/SUMMARY.md:27
msgid "Objects"
msgstr "Oggetti"

#: src/SUMMARY.md:28
msgid "Functions"
msgstr "Funzioni"

#: src/SUMMARY.md:29
msgid "Input"
msgstr "Input"

#: src/SUMMARY.md:30
msgid "Collision"
msgstr "Collisioni"

#: src/SUMMARY.md:31
msgid "Bricks"
msgstr "Mattoncini"

#: src/SUMMARY.md:32
msgid "Work in progress"
msgstr "Lavori in corso"

#: src/SUMMARY.md:34
msgid "Part III ‚Äî Our second game"
msgstr "Parte III ‚Äî Il nostro secondo gioco"

#: src/SUMMARY.md:36
msgid "Getting Started"
msgstr "Come iniziare"

#: src/SUMMARY.md:37
msgid "Project Structure"
msgstr "Struttura del progetto"

#: src/SUMMARY.md:38
msgid "Entry Point"
msgstr "Punto di ingresso"

#: src/SUMMARY.md:39
msgid "Changing Game States"
msgstr "Cambiamento dello Stato di Gioco"

#: src/SUMMARY.md:40
msgid "Title Screen"
msgstr "Schermata del titolo"

#: src/SUMMARY.md:41
msgid "Story Screen"
msgstr "Schermata della storia"

#: src/SUMMARY.md:42
msgid "Gameplay"
msgstr "Gameplay"

#: src/SUMMARY.md:43
msgid "Scrolling Background"
msgstr "Sfondo scorrevole"

#: src/SUMMARY.md:44
msgid "Heads-Up Interface"
msgstr ""

#: src/SUMMARY.md:45
msgid "Sprites & Metasprites"
msgstr ""

#: src/SUMMARY.md:46
msgid "Object Pools"
msgstr ""

#: src/SUMMARY.md:47
msgid "The Player"
msgstr "Il giocatore"

#: src/SUMMARY.md:48
msgid "Bullets"
msgstr ""

#: src/SUMMARY.md:49
msgid "Enemies"
msgstr "Nemici"

#: src/SUMMARY.md:50
msgid "Collision Detection"
msgstr "Rilevamento della collisione (collision detection)"

#: src/SUMMARY.md:51
msgid "Enemy-Player Collision"
msgstr "Collisione nemico-giocatore"

#: src/SUMMARY.md:52
msgid "Enemy-Bullet Collision"
msgstr ""

#: src/SUMMARY.md:53
msgid "Conclusion"
msgstr "Conclusione"

#: src/SUMMARY.md:56
msgid "Where to go next"
msgstr "Prossimi passi"

#: src/SUMMARY.md:57
msgid "Resources"
msgstr "Risorse"

#: src/SUMMARY.md:58
msgid "Thanks"
msgstr "Ringraziamenti"

#: src/index.md:1
msgid "# Home"
msgstr "# Pagina Principale"

#: src/index.md:3
msgid "üëã Welcome to gb-asm-tutorial!\n"
"This tutorial will teach you how to make games for the Game Boy and Game Boy Color."
msgstr "üëã Benvenuto in gb-asm-tutorial!\n"
"Questo tutorial ti insegner√† come programmare giochi per il Game Boy e per il Game Boy Color."

#: src/index.md:6
#: src/part1/hello_world.md:15
#: src/part1/registers.md:24
msgid "::: warning:‚ö†Ô∏è"
msgstr ""

#: src/index.md:8
msgid "While the Game Boy and Game Boy Color are almost the same console, **the Game Boy Advance is entirely different**.\n"
"However, the GBA is able to run GB and GBC games!\n"
"If you are looking to program GBC games and run them on a GBA, you're at the right place; however, if you want to make games specifically for the GBA, please check out [Tonc](http://coranac.com/tonc/text) instead."
msgstr "Il Game Boy ed il Game Boy Color sono quasi la stessa console, ma **il Game Boy Advance √® un sistema completamente diverso**.\n"
"Tuttavia, puoi comunque usarlo per giocare a giochi del GB e GBC!\n"
"Se vuoi imparare a programmare giochi per il GBC e giocarci su di un GBA, puoi comunque seguire questo tutorial; se per√≤ volessi creare giochi specificamente per il GameBoy Advance allora [Tonc](http://coranac.com/tonc/text) √® il tutorial che fai per te."

#: src/index.md:12
#: src/roadmap.md:21
#: src/part1/setup.md:17
#: src/part1/setup.md:55
#: src/part1/hello_world.md:19
#: src/part1/hello_world.md:46
#: src/part1/bin_and_hex.md:28
#: src/part1/bin_and_hex.md:109
#: src/part1/registers.md:29
#: src/part1/registers.md:44
#: src/part1/assembly.md:65
#: src/part1/assembly.md:72
#: src/part1/assembly.md:176
#: src/part1/memory.md:8
#: src/part1/memory.md:92
#: src/part1/memory.md:110
#: src/part1/header.md:22
#: src/part1/header.md:57
#: src/part1/header.md:131
#: src/part1/operations.md:81
#: src/part1/jumps.md:7
#: src/part1/jumps.md:39
#: src/part1/jumps.md:66
#: src/part1/jumps.md:90
#: src/part1/tracing.md:31
#: src/part1/tracing.md:42
#: src/part1/tiles.md:13
#: src/part1/tiles.md:39
#: src/part1/palettes.md:13
#: src/part1/tilemap.md:8
#: src/part1/tilemap.md:45
#: src/part1/wrapup.md:16
#: src/part2/getting-started.md:30
#: src/part2/getting-started.md:113
#: src/part2/getting-started.md:149
#: src/part2/objects.md:13
#: src/part2/objects.md:40
#: src/part2/objects.md:165
#: src/part2/collision.md:131
#: src/part2/collision.md:285
#: src/part2/collision.md:415
#: src/part2/wip.md:13
#: src/part3/project-structure.md:15
#: src/part3/project-structure.md:135
#: src/part3/entry-point.md:120
#: src/part3/story-screen.md:17
msgid ":::"
msgstr ""

#: src/index.md:14
msgid "## Controls"
msgstr "## Comandi"

#: src/index.md:16
msgid "There are some handy icons near the top of your screen!"
msgstr "In cima alla pagina puoi vedere alcune icone, sempre presenti se ne dovessi avere bisogno!"

#: src/index.md:18
msgid "- The \"burger\" <i class=\"fa fa-bars\"></i> toggles the navigation side panel;\n"
"- The brush <i class=\"fa fa-paint-brush\"></i> allows selecting a different color theme;\n"
"- The magnifying glass <i class=\"fa fa-search\"></i> pops up a search bar;\n"
"- The world icon <i class=\"fa fa-globe\"></i> lets you change the language of the tutorial;\n"
"- The printer <i class=\"fa fa-print\"></i> gives a single-page version of the _entire_ tutorial, which you can print if you want;\n"
"- The GitHub icon <i class=\"fa fa-github\"></i> links to the tutorial's source repository;\n"
"- The edit button <i class=\"fa fa-edit\"></i> allows you to suggest changes to the tutorial, provided that you have a GitHub account."
msgstr ""

#: src/index.md:26
msgid "Additionally, there are arrows to the left and to the right of the page (they are at the bottom instead on mobile) to more easily navigate to the next page."
msgstr "Ci sono anche delle frecce a lato della pagina (o in fondo, se sei su cellulare) per passare alla pagina successiva o precedente."

#: src/index.md:28
msgid "With that said, you can get started by simply navigating to the following page :)"
msgstr "E con questo, per iniziare ti baster√† premere la freccia a destra :)"

#: src/index.md:30
msgid "## Authors"
msgstr "## Autori"

#: src/index.md:32
msgid "The tutorial was written by [Eldred \"ISSOtm\" Habert](https://eldred.fr/), [Evie](https://evie.gbdev.io/), [Antonio Vivace](https://github.com/avivace), [LaroldsJubilantJunkyard](https://www.LaroldsJubilantJunkyard.com) and [other contributors](https://github.com/gbdev/gb-asm-tutorial/graphs/contributors)."
msgstr "Il tutorial √® stato scritto da [Eldred \"ISSOtm\" Habert](https://eldred.fr/), [Evie](https://evie.gbdev.io/), [Antonio Vivace](https://github.com/avivace), [LaroldsJubilantJunkyard](https://www.LaroldsJubilantJunkyard.com) e [altri collaboratori](https://github.com/gbdev/gb-asm-tutorial/graphs/contributors)."

#: src/index.md:34
msgid "## Contributing"
msgstr "## Contribuire"

#: src/index.md:36
msgid "You can **provide feedback** or send suggestions in the form of Issues on the [GitHub repository](https://github.com/gbdev/gb-asm-tutorial)."
msgstr ""

#: src/index.md:38
msgid "We're also [looking for help](https://github.com/gbdev/gb-asm-tutorial/issues) for **writing new lessons and improving the existing ones**! You can go through the Issues to see what needs to be worked on and send Pull Requests!"
msgstr ""

#: src/index.md:40
msgid "You can also help **translating** the tutorial on [Crowdin](https://crowdin.com/project/gb-asm-tutorial)."
msgstr ""

#: src/index.md:42
msgid "## Licensing"
msgstr "## Licenza"

#: src/index.md:44
msgid "**In short**:"
msgstr "**In breve**:"

#: src/index.md:46
msgid "- Code within the tutorial is essentially **public domain**, meaning that you are allowed to copy it freely without restrictions.\n"
"- You are free to copy the tutorial's contents (prose, diagrams, etc.), modify them, and share that, but you must give credit and license any copies permissively.\n"
"- This site's _source code_ can be freely copied, but you must give a license and copyright notice."
msgstr ""

#: src/index.md:50
msgid "**Full details**, please follow these links for more information on the respective licenses:"
msgstr "**Maggiori Informazioni**, per maggiori informazioni sulle rispettive licenze, seguire questi link:"

#: src/index.md:52
msgid "- All the code contained within the tutorial itself is licensed under <a rel=\"license\" href=\"http://creativecommons.org/publicdomain/zero/1.0/\">CC0</a>. _To the extent possible under law, all copyright and related or neighboring rights to code presented within GB ASM Tutorial have been waived._\n"
"- The contents (prose, images, etc.) of this tutorial are licensed under a <a rel=\"license\" href=\"http://creativecommons.org/licenses/by-sa/4.0/\">Creative Commons Attribution-ShareAlike 4.0 International License</a>.\n"
"- Code used to display and format the site is licensed under the [MIT License](https://github.com/gbdev/gb-asm-tutorial/blob/master/LICENSE) unless otherwise specified."
msgstr ""

#: src/roadmap.md:1
msgid "# Roadmap"
msgstr "# Tabella di marcia"

#: src/roadmap.md:3
msgid "The tutorial is split into three sections.\n"
"**I strongly advise you go through the tutorial in order!**"
msgstr "Il tutorial √® suddiviso in tre sezioni.\n"
"**Consiglio vivamente di seguirle in ordine!**"

#: src/roadmap.md:6
msgid "In Part ‚Ö†, we run our first \"Hello World!\" program, which we then dissect to learn what makes the Game Boy tick."
msgstr "Nella parte ‚Ö†, lanciamo il nostro primo programma \"Hello World!\", per poi analizzarlo al fine di capire come funziona il Game Boy."

#: src/roadmap.md:8
msgid "In Part ‚Ö°, we program our first game, a clone of *Arkanoid*; we learn how to prod the hardware into having something we can call a \"game\".\n"
"Along the way, we will make plenty of mistakes, so we can learn how to debug our code."
msgstr "Nella parte ‚Ö° programmiamo il nostro primo gioco, un clone di *Arkanoid*; impariamo a dare le prime istruzioni all'hardware per ottenere qualcosa che si possa definire \"gioco\".\n"
"Lungo il percorso commetteremo molti errori, ma questo servir√† anche a imparare a risolvere i problemi del nostro codice."

#: src/roadmap.md:11
msgid "And finally, Part ‚Ö¢ is about \"advanced\" use of the hardware, where we learn how to make even better-looking games, and we program a Shoot 'Em Up!"
msgstr "Infine, la Parte ‚Ö¢ riguarda l'uso \"avanzato\" dell'hardware, dove impareremo a creare giochi ancora pi√π rifiniti e programmeremo uno \"Shoot 'Em Up\"!"

#: src/roadmap.md:13
#: src/part1/setup.md:50
#: src/part1/assembly.md:169
#: src/part1/memory.md:87
#: src/part1/memory.md:106
#: src/part1/header.md:18
#: src/part1/jumps.md:3
#: src/part1/jumps.md:61
#: src/part1/tilemap.md:39
#: src/part2/getting-started.md:24
#: src/part2/getting-started.md:144
#: src/part2/objects.md:8
#: src/part2/objects.md:33
#: src/part2/collision.md:125
#: src/part3/project-structure.md:11
#: src/part3/entry-point.md:116
#: src/part3/story-screen.md:13
msgid "::: tip"
msgstr ""

#: src/roadmap.md:15
msgid "We hope this tutorial will work for you."
msgstr ""

#: src/roadmap.md:17
msgid "But if it doesn't (the format may not work well for everyone, and that's okay), I encourage you to look at [some other resources](resources.md), which might work better for you."
msgstr ""

#: src/roadmap.md:19
msgid "It's also fine to **take a break from time to time**; feel free to read at your own pace, and to [ask for clarifications](https://gbdev.io/chat) if anything isn't clear to you."
msgstr ""

#: src/roadmap.md:23
#: src/part1/assembly.md:181
#: src/part1/memory.md:134
#: src/part1/jumps.md:114
#: src/part1/tracing.md:104
#: src/part1/tiles.md:94
#: src/part1/palettes.md:99
#: src/part1/tilemap.md:67
#: src/part1/wrapup.md:18
#: src/thanks.md:11
msgid "---"
msgstr "---"

#: src/roadmap.md:25
msgid "This tutorial is a work in progress."
msgstr "Questo tutorial √® ancora in lavorazione."

#: src/help-feedback.md:1
msgid "# Help"
msgstr "# Aiuto"

#: src/help-feedback.md:3
msgid "If you are stuck in a certain part of the tutorial, want some advice, or just wish to chat with us, [the GBDev community chat](https://gbdev.io/chat) is the place to go!\n"
"The authors actively participate there so don't be afraid to ask questions!\n"
"(The \"ASM\" channel should be the most appropriate to discuss the tutorial, by the way.)"
msgstr "Se avessi problemi con una parte del tutorial, se volessi suggerimenti di qualsiasi tipo o anche solo parlare con noi la [chat della comunit√† GBDev](https://gbdev.io/chat) √® il posto che cerchi!\n"
"Partecipiamo tutti attivamente sul sito, perci√≤ non aver timore di fare domande di qualunque tipo!\n"
"(il canale \"ASM\" √® il posto migliore per discutere di questo tutorial.)"

#: src/help-feedback.md:7
msgid "If you prefer email, you can reach us at `tutorial@<domain>`, where you replace `<domain>` with this website's domain name.\n"
"Anti-spam measure, I hope you understand."
msgstr "Se preferisci la posta elettronica, puoi raggiungerci all'indirizzo `tutorial@<domain>`, devi sostituire `<domain>` con il nome di dominio di questo sito.\n"
"Si tratta di una misura antispam, spero che tu capisca."

#: src/part1/setup.md:1
msgid "# Setup"
msgstr "# Preparazione"

#: src/part1/setup.md:3
msgid "First, we should set up our dev environment.\n"
"We will need:"
msgstr "Per prima cosa, dobbiamo configurare il nostro ambiente di sviluppo.\n"
"Avremo bisogno di:"

#: src/part1/setup.md:6
msgid "1. A POSIX environment\n"
"2. [RGBDS](https://rgbds.gbdev.io/install) v0.5.1 (though v0.5.0 should be compatible)\n"
"3. GNU Make (preferably a recent version)\n"
"4. A code editor\n"
"5. A debugging emulator"
msgstr "1. Un ambiente POSIX\n"
"2. [RGBDS](https://rgbds.gbdev.io/install) v0.5.1 (anche se la v0.5.0 dovrebbe essere comunque compatibile)\n"
"3. GNU Make (preferibilmente una versione recente)\n"
"4. Un editor di codice\n"
"5. Un emulatore per il debug"

#: src/part1/setup.md:12
msgid "::: tip:‚ùìüòï"
msgstr ""

#: src/part1/setup.md:14
msgid "The following install instructions are provided on a \"best-effort\" basis, but may be outdated, or not work for you for some reason.\n"
"Don't worry, we're here to help: [ask away](../help-feedback.md), and we'll help you with installing everything!"
msgstr ""

#: src/part1/setup.md:19
msgid "## Tools"
msgstr "## Strumenti"

#: src/part1/setup.md:21
msgid "### Linux & macOS"
msgstr "### Linux e macOS"

#: src/part1/setup.md:23
msgid "Good news: you're already fulfilling step 1!\n"
"You just need to [install RGBDS](https://rgbds.gbdev.io/install), and maybe update GNU Make."
msgstr "Buone notizie: hai gi√† completato il primo passo!\n"
"Dovete solo [installare RGBDS](https://rgbds.gbdev.io/install) e forse aggiornare GNU Make."

#: src/part1/setup.md:26
msgid "#### macOS"
msgstr "#### macOS"

#: src/part1/setup.md:28
msgid "At the time of writing this, macOS (up to 11.0, the current latest release) ships a very outdated GNU Make.\n"
"You can check it by opening a terminal, and running `make --version`, which should indicate \"GNU Make\" and a date, among other things."
msgstr "Al momento della stesura di questo articolo, macOS (fino alla 11.0, l'ultima release attuale) ha in dotazione un GNU Make molto datato.\n"
"√à possibile verificarlo aprendo un terminale ed eseguendo `make --version`, che dovrebbe indicare \"GNU Make\" e una data, tra le altre cose."

#: src/part1/setup.md:31
msgid "If your Make is too old, you can update it using [Homebrew](https://brew.sh)'s formula [`make`](https://formulae.brew.sh/formula/make#default).\n"
"At the time of writing, this should print a warning that the updated Make has been installed as `gmake`; you can either follow the suggestion to use it as your \"default\" `make`, or use `gmake` instead of `make` in this tutorial."
msgstr "Se il vostro Make √® troppo vecchio, potete aggiornarlo usando la formula di [Homebrew](https://brew.sh) [`make`](https://formulae.brew.sh/formula/make#default).\n"
"Al momento in cui scriviamo, dovrebbe essere stampato un avviso che il Make aggiornato √® stato installato come `gmake`; si pu√≤ seguire il suggerimento di usarlo come `make` \"predefinito\", oppure usare `gmake` invece di `make` in questo tutorial."

#: src/part1/setup.md:34
msgid "#### Linux"
msgstr "#### Linux"

#: src/part1/setup.md:36
msgid "Once RGBDS is installed, open a terminal and run `make --version` to check your Make version (which is likely GNU Make)."
msgstr "Una volta installato RGBDS, aprite il terminale ed eseguite il comando `make --version` per controllare la vostra versione di Make (che probabilmente √® GNU Make)."

#: src/part1/setup.md:38
msgid "If `make` cannot be found, you may need to install your distribution's `build-essentials`."
msgstr "Se `make` non √® presente, potrebbe essere necessario installare le `build-essentials` della propria distribuzione."

#: src/part1/setup.md:40
msgid "### Windows"
msgstr "### Windows"

#: src/part1/setup.md:42
msgid "The sad truth is that Windows is a terrible OS for development; however, you can install environments that solve most issues."
msgstr "La triste verit√† √® che Windows √® un pessimo sistema operativo per noi sviluppatori; tuttavia, √® possibile installare degli strumenti che risolvono la maggior parte dei suoi problemi."

#: src/part1/setup.md:44
msgid "On Windows 10, your best bet is [WSL](https://docs.microsoft.com/en-us/windows/wsl), which sort of allows running a Linux distribution within Windows.\n"
"Install WSL 1 or WSL 2, then a distribution of your choice, and then follow these steps again, but for the Linux distribution you installed."
msgstr "Su Windows 10, la scelta migliore √® [WSL](https://docs.microsoft.com/en-us/windows/wsl), che permette di eseguire una distribuzione Linux all'interno di Windows.\n"
"Installate WSL 1 o WSL 2, poi una distribuzione a vostra scelta e quindi seguite nuovamente questi passaggi per la distribuzione Linux appena installata."

#: src/part1/setup.md:47
msgid "If WSL is not an option, you can use [MSYS2](https://www.msys2.org) or [Cygwin](https://www.cygwin.com) instead; then check out [RGBDS' Windows install instructions](https://rgbds.gbdev.io/install).\n"
"As far as I'm aware, both of these provide a sufficiently up-to-date version of GNU Make."
msgstr "In alternativa a WSL, si pu√≤ usare [MSYS2](https://www.msys2.org) o [Cygwin](https://www.cygwin.com); per poi consultare le istruzioni per l'installazione di Windows di [RGBDS] (https://rgbds.gbdev.io/install).\n"
"Per quanto ne so, entrambi dovrebbero fornire una versione sufficientemente aggiornata di GNU Make."

#: src/part1/setup.md:52
msgid "If you have programmed for other consoles, such as the GBA, check if MSYS2 isn't already installed on your machine.\n"
"This is because devkitPro, a popular homebrew development bundle, includes MSYS2."
msgstr "Se avete programmato per altre console, come il GBA, controllate che MSYS2 non sia gi√† installato sul vostro computer.\n"
"Questo perch√© devkitPro, un popolare pacchetto di sviluppo homebrew, include MSYS2."

#: src/part1/setup.md:57
msgid "## Code editor"
msgstr "## Editor di codice"

#: src/part1/setup.md:59
msgid "Any code editor is fine; I personally use [Sublime Text](https://www.sublimetext.com) with its [RGBDS syntax package](https://packagecontrol.io/packages/RGBDS); however, you can use any text editor, including Notepad, if you're crazy enough.\n"
"Awesome GBDev has [a section on syntax highlighting packages](https://gbdev.io/resources#syntax-highlighting-packages), see there if your favorite editor supports RGBDS."
msgstr "Qualsiasi editor di codice va bene; personalmente uso [Sublime Text](https://www.sublimetext.com) con il suo [pacchetto sintassi RGBDS](https://packagecontrol.io/packages/RGBDS); tuttavia √® possibile usare qualsiasi editor di testo, compreso il Blocco Note se si √® abbastanza pazzi.\n"
"Awesome GBDev ha [una sezione sui pacchetti per l'evidenziazione della sintassi](https://gbdev.io/resources#syntax-highlighting-packages) dove potete controllare se il vostro editor preferito supporta RGBDS."

#: src/part1/setup.md:62
msgid "## Emulator"
msgstr "## Emulatore"

#: src/part1/setup.md:64
msgid "Using an emulator to play games is one thing; using it to program games is another.\n"
"The two aspects an emulator must fulfill to allow an enjoyable programming experience are:\n"
"- **Debugging tools**:\n"
"  When your code goes haywire on an actual console, it's very difficult to figure out why or how.\n"
"  There is no console output, no way to `gdb` the program, nothing.\n"
"  However, an emulator can provide debugging tools, allowing you to control execution, inspect memory, etc.\n"
"  These are vital if you want GB dev to be *fun*, trust me!\n"
"- **Good accuracy**:\n"
"  Accuracy means \"how faithful to the original console something is\".\n"
"  Using a bad emulator for playing games can work (to some extent, and even then...), but using it for *developing* a game makes it likely to accidentally render your game incompatible with the actual console.\n"
"  For more info, read [this article on Ars Technica](https://arstechnica.com/?post_type=post&p=44524) (especially the <q>An emulator for every game</q> section at the top of page 2).\n"
"  You can compare GB emulator accuracy on [Daid's GB-emulator-shootout](https://daid.github.io/GBEmulatorShootout/)."
msgstr "Usare un emulatore per giocare √® una cosa; usarlo per programmare giochi √® un'altra.\n"
"I due aspetti che un emulatore deve soddisfare per consentire una piacevole esperienza di programmazione sono:\n"
"- __Un supporto al debug__:\n"
"  Se il tuo programma va in palla sulla console √® pressoch√© impossibile capire cosa sia andato storto:\n"
"  non puoi controllare gli errori dal terminale, non puoi usare `gdb`, niente.\n"
"  Un emulatore, al contrario, pu√≤ avere strumenti per aiutare il debug, ad esempio dandoti controllo sull'esecuzione leggere e mdoificare la memoria, e molto altro.\n"
"  Senza di questi strumenti lo sviluppo sar√† tutto meno che _divertente_, fidati!\n"
"- __Emulazione Precisa__:\n"
"  La precisione di un emulatore √® quanto questo riproduca bene il comportamento del sistema reale.\n"
"  Un emulatore poco accurato andr√† anche bene per giocare (seppur spesso con un esperienza poco fluida...), ma se vuoi _programmare_, hai bisogno di sapere se il tuo gioco sia effettivamente compatibile con il tuo sistema.\n"
"  Se sei interessato puoi leggere di pi√π a riguardo su [questo articolo di Ars Technica](https://arstechnica.com/?post_type=post&p=44524) (in particolare la sezione <q>An emulator for every game</q> in cima alla seconda pagina).\n"
"  Puoi vedere e confrontare la precisione di alcuni degli emulatori GameBoy pi√π popolari sul [GB-emulator-shootout](https://daid.github.io/GBEmulatorShootout/) di Daid. Trovi una tabella con diversi test ed i risultati per emulatore."

#: src/part1/setup.md:77
msgid "The emulator I will be using for this tutorial is [Emulicious](https://emulicious.net/).\n"
"Users on all OSes can install the Java runtime to be able to run it.\n"
"Other debugging emulators are available, such as [Mesen2](https://www.mesen.ca/), [BGB](https://bgb.bircd.org) (Windows/Wine only), [SameBoy](https://sameboy.github.io) (graphical interface on macOS only); they should have similar capabilities, but accessed through different menu options."
msgstr ""

#: src/part1/hello_world.md:1
msgid "# Hello World!"
msgstr "# Hello World!"

#: src/part1/hello_world.md:3
msgid "In this lesson, we will begin by assembling our first program.\n"
"The rest of this chapter will be dedicated to explaining how and why it works."
msgstr "In questa lezione inizieremo ad assemblare il nostro primo programma.\n"
"Il resto del capitolo sar√† dedicato a spiegare come e perch√© funziona."

#: src/part1/hello_world.md:6
msgid "Note that we will need to type a lot of commands, so open a terminal now.\n"
"It's a good idea to create a new directory (`mkdir gb_hello_world`, for example, then `cd gb_hello_world` to enter the new directory)."
msgstr "Tenete presente che da ora dovremo lanciare molti comandi, quindi √® il momento di aprire una finestra del terminale.\n"
"√à buon norma creare una nuova directory (`mkdir gb_hello_world`, per esempio, poi `cd gb_hello_world` per entrare nella nuova directory)."

#: src/part1/hello_world.md:9
msgid "Grab the following files (right-click each link, \"Save Link As...\"), and place them all in this new directory:\n"
"- [`hello-world.asm`](../assets/hello-world.asm)\n"
"- [`hardware.inc`](https://raw.githubusercontent.com/gbdev/hardware.inc/v4.0/hardware.inc)"
msgstr "Scaricate i seguenti file (cliccate con il tasto destro del mouse su ogni link, \"Salva link con nome...\") e metteteli tutti in questa nuova directory:\n"
"- [`hello-world.asm`](../assets/hello-world.asm)\n"
"- [`hardware.inc`](https://raw.githubusercontent.com/gbdev/hardware.inc/v4.0/hardware.inc)"

#: src/part1/hello_world.md:13
msgid "Then, still from a terminal within that directory, run the following three commands."
msgstr "Quindi, sempre dal terminale, all'interno di quella directory, lanciate i tre comandi seguenti."

#: src/part1/hello_world.md:17
msgid "To clarify where each individual command begins, I've added a `$` before each command, but don't type them!"
msgstr "Per chiarezza espositiva, all'inizio di ogni comando, ho aggiunto un `$`, ma voi non digitatelo!"

#: src/part1/hello_world.md:21
msgid "```console\n"
"$ rgbasm -L -o hello-world.o hello-world.asm\n"
"$ rgblink -o hello-world.gb hello-world.o\n"
"$ rgbfix -v -p 0xFF hello-world.gb\n"
"```"
msgstr "```console\n"
"$ rgbasm -L -o hello-world.o hello-world.asm\n"
"$ rgblink -o hello-world.gb hello-world.o\n"
"$ rgbfix -v -p 0xFF hello-world.gb\n"
"````"

#: src/part1/hello_world.md:27
msgid "<style>\n"
"\t.box.danger ol {\n"
"\t\tlist-style-type: symbols(fixed \"üëé\" \"üëç\" \"üëç\");\n"
"\t}\n"
"</style>"
msgstr "<style>\n"
"\t.box.danger ol {\n"
"\t\tlist-style-type: symbols(fixed \"üëé\" \"üëç\" \"üëç\");\n"
"\t}\n"
"</style>"

#: src/part1/hello_world.md:33
msgid "::: danger:‚ÄºÔ∏è"
msgstr ""

#: src/part1/hello_world.md:35
msgid "Be careful with arguments! Some options, such as `-o` here, use the argument after them as a parameter:"
msgstr "Fate attenzione agli argomenti! Alcune opzioni, come `-o`, usano l'argomento dopo di esse come parametro:"

#: src/part1/hello_world.md:37
msgid "1. `rgbasm -L -o hello-world.asm hello-world.o` won't work (and may corrupt `hello-world.asm`!)\n"
"2. `rgbasm -L hello-world.asm -o hello-world.o` will work\n"
"3. `rgbasm hello-world.asm -o hello-world.o -L` will also work"
msgstr "1. `rgbasm -L -o hello-world.asm hello-world.o` non funzioner√† (e potrebbe corrompere `hello-world.asm`!)\n"
"2. `rgbasm -L hello-world.asm -o hello-world.o` funzioner√†\n"
"3. `rgbasm hello-world.asm -o hello-world.o -L` funzioner√† anche"

#: src/part1/hello_world.md:41
msgid "If you need whitespace within an argument, you must quote it:"
msgstr "In caso di spazi all'interno di un argomento, √® necessario metterlo tra virgolette:"

#: src/part1/hello_world.md:43
msgid "1. `rgbasm -L -o hello world.o hello world.asm` won't work\n"
"2. `rgbasm -L -o \"hello world.o\" \"hello world.asm\"` will work"
msgstr "1. `rgbasm -L -o hello world.o hello world.asm` non funzioner√†\n"
"2. `rgbasm -L -o \"hello world.o\" \"hello world.asm\"` funzioner√†"

#: src/part1/hello_world.md:48
msgid "It should look like this:\n"
"<script id=\"asciicast-weljUlcp1KC5GqS9jqV62dy5m\" src=\"https://asciinema.celforyon.fr/a/weljUlcp1KC5GqS9jqV62dy5m.js\" async></script>"
msgstr "E dunque il processo sar√† il seguente:\n"
"<script id=\"asciicast-weljUlcp1KC5GqS9jqV62dy5m\" src=\"https://asciinema.celforyon.fr/a/weljUlcp1KC5GqS9jqV62dy5m.js\" async></script>"

#: src/part1/hello_world.md:51
msgid "(If you encounter an error you can't figure out by yourself, don't be afraid to [ask us](../index.md#feedback)! We'll sort it out.)"
msgstr "(Se riscontrate un errore che non riuscite a risolvere da soli, non abbiate paura di [chiedere](../index.md#feedback)! Lo risolveremo insieme)"

#: src/part1/hello_world.md:53
msgid "Congrats!\n"
"You just assembled your first Game Boy ROM!\n"
"Now, we just need to run it; open Emulicious, then go \"File\", then \"Open File\", and load `hello-world.gb`."
msgstr ""

#: src/part1/hello_world.md:57
msgid "<video controls poster=\"../assets/vid/hello_world.poster.png\">\n"
"\t<source src=\"../assets/vid/hello_world.webm\" type=\"video/webm\">\n"
"\t<source src=\"../assets/vid/hello_world.mp4\" type=\"video/mp4\">"
msgstr "<video controls poster=\"../assets/vid/hello_world.poster.png\">\n"
"\t<source src=\"../assets/vid/hello_world.webm\" type=\"video/webm\">\n"
"\t<source src=\"../assets/vid/hello_world.mp4\" type=\"video/mp4\">"

#: src/part1/hello_world.md:61
msgid "\t<img src=\"../assets/vid/hello_world.gif\" alt=\"Video demonstration in Emulicious\">\n"
"</video>"
msgstr ""

#: src/part1/hello_world.md:64
msgid "You could also take a flash cart (I use the [EverDrive GB X5](https://krikzz.com/store/home/47-everdrive-gb.html), but there are plenty of alternatives), load up your ROM onto it, and run it on an actual console!"
msgstr "Potreste anche prendere una flash cart (cartuccia flash) (io uso l'[EverDrive GB X5](https://krikzz.com/store/home/47-everdrive-gb.html), ma ci sono molte alternative), caricarci la vostra ROM e farla girare su una console vera e propria!"

#: src/part1/hello_world.md:66
msgid "![Picture of the Hello World running on a physical DMG](../assets/img/hello_dmg.jpg)"
msgstr "![Immagine di Hello World in esecuzione su una console DMG reale](../assets/img/hello_dmg.jpg)"

#: src/part1/hello_world.md:68
msgid "Well, now that we have something working, it's time to peel back the curtains..."
msgstr "Bene, ora che abbiamo qualcosa che funziona, √® il momento di togliere le tende per scoprire cosa c'√® sotto..."

#: src/part1/toolchain.md:1
msgid "# The toolchain"
msgstr "# Strumenti di lavoro"

#: src/part1/toolchain.md:3
msgid "So, in the previous lesson, we built a nice little \"Hello World!\" ROM.\n"
"Now, let's find out exactly what we did."
msgstr "Dunque, nella lezione precedente abbiamo scritto una piccola ROM \"Hello World!\".\n"
"Ora √® il momento di capire meglio cosa abbiamo fatto."

#: src/part1/toolchain.md:6
msgid "## RGBASM and RGBLINK"
msgstr "## RGBASM e RGBLINK"

#: src/part1/toolchain.md:8
msgid "Let's begin by explaining what `rgbasm` and `rgblink` do."
msgstr "Iniziamo spiegando cosa fanno `rgbasm` e `rgblink`."

#: src/part1/toolchain.md:10
msgid "RGBASM is an *assembler*.\n"
"It is responsible for reading the source code (in our case, `hello-world.asm` and `hardware.inc`), and generating blocks of code with some \"holes\".\n"
"RGBASM does not always have enough information to produce a full ROM, so it does most of the work, and stores its intermediary results in what's known as *object files* (hence the `.o` extension)."
msgstr "RGBASM √® un *assembler* (compilatore).\n"
"Il suo compito √® leggere il codice sorgente (nel nostro caso `hello-world.asm` e `hardware.inc`) e generare un file di codice che per√≤ √® incompleto:\n"
"RGBASM non sempre ha tutte le informazioni che gli servono a generare una ROM, quindi produce dei *file oggetto* che fanno da intermediari (con estensione `.o`)."

#: src/part1/toolchain.md:14
msgid "RGBLINK is a *linker*.\n"
"Its job is taking object files (or, like in our case, just one), and \"linking\" them into a ROM, which is to say: filling the aforementioned \"holes\".\n"
"RGBLINK's purpose may not be obvious with programs as simple as this Hello World, but it will become much clearer in Part ‚Ö°."
msgstr "RGBLINK √® un *linker*.\n"
"Il suo compito √® usare le informazioni dei file oggetto (che nel nostro caso √® solo uno) ed unirli (in inglese \"link\") in una ROM.\n"
"RGBLINK potrebbe sembrare superfluo, ma √® solo perch√© la ROM che abbiamo guardato √® davvero piccola: quando nella seconda parte il nostro progetto crescer√†, la sua utilit√† sar√† pi√π apparente."

#: src/part1/toolchain.md:18
msgid "So: Source code ‚Üí `rgbasm` ‚Üí Object files ‚Üí `rgblink` ‚Üí ROM, right?\n"
"Well, not exactly."
msgstr "Quindi: Codice sorgente ‚Üí `rgbasm` ‚Üí File oggetto ‚Üí `rgblink` ‚Üí ROM, giusto?\n"
"Beh, non esattamente."

#: src/part1/toolchain.md:21
#: src/part1/header.md:61
msgid "## RGBFIX"
msgstr "## RGBFIX"

#: src/part1/toolchain.md:23
msgid "RGBLINK does produces a ROM, but it's not quite usable yet.\n"
"See, actual ROMs have what's called a *header*.\n"
"It's a special area of the ROM that contains [metadata about the ROM](https://gbdev.io/pandocs/The_Cartridge_Header.html); for example, the game's name, Game Boy Color compatibility, and more.\n"
"For simplicity, we defaulted a lot of these values to 0 for the time being; we'll come back to them in Part ‚Ö°."
msgstr "RGBLINK produce s√¨ una ROM, ma se la provassimo su un GameBoy non funzionerebbe.\n"
"Nelle ROM deve sempre essere presente qualcosa chiamato *header*:\n"
"questa sezione contiene [informazioni sulla ROM](https://gbdev.io/pandocs/The_Cartridge_Header.html), come il nome del gioco, il nome dell'autore, se sia compatibile con il GameBoy Color ed altro.\n"
"Per il momento abbiamo impostato tutti i valori a zero nel programma per semplicit√†, ma ne riparleremo nella seconda parte del tutorial."

#: src/part1/toolchain.md:28
msgid "However, the header contains three crucial fields:\n"
"- The [Nintendo logo](https://gbdev.io/pandocs/The_Cartridge_Header.html#0104-0133--nintendo-logo),\n"
"- the [ROM's size](https://gbdev.io/pandocs/The_Cartridge_Header.html#0148--rom-size),\n"
"- and [two checksums](https://gbdev.io/pandocs/The_Cartridge_Header.html#014d--header-checksum)."
msgstr "Ma nell'header ci sono anche delle componenti importantissime:\n"
"- il [logo Nintendo](https://gbdev.io/pandocs/The_Cartridge_Header.html#0104-0133--nintendo-logo),\n"
"- la [dimensione della ROM](https://gbdev.io/pandocs/The_Cartridge_Header.html#0148--rom-size),\n"
"- e [due valori di controllo](https://gbdev.io/pandocs/The_Cartridge_Header.html#014d--header-checksum) ([checksum](https://it.wikipedia.org/wiki/Checksum))."

#: src/part1/toolchain.md:33
msgid "When the console first starts up, it runs [a little program](https://github.com/ISSOtm/gb-bootroms) known as the *boot ROM*, which reads and draws the logo from the cartridge, and displays the little boot animation.\n"
"When the animation is finished, the console checks if the logo matches a copy that it stores internally; if there is a mismatch, **it locks up!**\n"
"And, since it locks up, our game never gets to run... üò¶\n"
"This was meant as an anti-piracy measure; however, that measure [has since then been ruled as invalid](https://en.wikipedia.org/wiki/Sega_v._Accolade), so don't worry, we are clear! üòÑ"
msgstr "Quando la console viene accesa viene eseguito [un programma](https://github.com/ISSOtm/gb-bootroms) chiamato *ROM di avvio* (boot ROM) responsabile, tra l'altro, dell'animazione di avvio leggendo il logo di Nintendo dalla ROM.\n"
"Alla fine dell'animazione, per√≤, la ROM di avvio controlla che il logo di Nintendo sia corretto, e interrompe l'esecuzione se non lo √®:\n"
"in pratica, se non azzecchiamo il logo il nostro gioco non partir√† mai... üò¶\n"
"Questo meccanismo era per evitare la pirateria; per nostra fortuna, per√≤, [non √® pi√π valida](https://en.wikipedia.org/wiki/Sega_v._Accolade) perci√≤ non dobbiamo preoccuparci! üòÑ"

#: src/part1/toolchain.md:38
msgid "Similarly, the boot ROM also computes a *[checksum](https://en.wikipedia.org/wiki/Checksum)* of the header, supposedly to ensure that it isn't corrupted.\n"
"The header also contains a copy of this checksum; if it doesn't match what the boot ROM computed, then the boot ROM **also locks up!**"
msgstr "Allo stesso modo, la ROM di avvio calcola anche un *[checksum](https://en.wikipedia.org/wiki/Checksum)* dell'header, presumibilmente per garantire che non sia corrotto.\n"
"L'header contiene anche una copia di questo checksum; se non corrisponde a quello calcolato dalla ROM di avvio, la ROM di avvio **si blocca!**"

#: src/part1/toolchain.md:41
msgid "The header also contains a checksum over the whole ROM, but nothing ever uses it.\n"
"It doesn't hurt to get it right, though."
msgstr "L'header contiene anche un checksum dell'intera ROM, ma non viene mai utilizzato.\n"
"Non costa niente ed √® una buona idea, comunque, farlo bene."

#: src/part1/toolchain.md:44
msgid "Finally, the header also contains the ROM's size, which is required by emulators and flash carts."
msgstr "Infine, l'header contiene anche la dimensione della ROM, necessaria per emulatori e dalle flash cart."

#: src/part1/toolchain.md:46
msgid "RGBFIX's role is to fill in the header, especially these 3 fields, which are required for our ROM to be guaranteed to run fine.\n"
"The `-v` option instructs RGBFIX to make the header **v**alid, by injecting the Nintendo logo and computing the two checksums.\n"
"The `-p 0xFF` option instructs it to **p**ad the ROM to a valid size, and set the corresponding value in the \"ROM size\" header field."
msgstr "RGBFIX serve proprio a compilare l'header in automatico, in particolare questi tre campi senza i quali il GameBoy non far√† funzionare il gioco.\n"
"L'opzione `-v` dice a RGBFIX di rendere **v**alido l'header, inserendo il logo e calcolando le checksum.\n"
"L'opzione `-p 0xFF` invece aggiunge dei byte alla ROM finch√© non raggiunge una dimensione valida (in inglese **p**adding), per poi scriverla nell'header."

#: src/part1/toolchain.md:50
msgid "Alright!\n"
"So the full story is: Source code ‚Üí `rgbasm` ‚Üí Object files ‚Üí `rgblink` ‚Üí \"Raw\" ROM ‚Üí `rgbfix` ‚Üí \"Fixed\" ROM.\n"
"Good."
msgstr "Perfetto!\n"
"Quindi, per riassumere: <br>\n"
"codice sorgente ‚Üí `rgbasm` ‚Üí file oggetto ‚Üí `rgblink` ‚Üí ROM \"vera\" ‚Üí `rgbfix` ‚Üí ROM funzionante"

#: src/part1/toolchain.md:54
msgid "You might be wondering why RGBFIX's functionality hasn't been included directly in RGBLINK.\n"
"There are some historical reasons, but RGBLINK can also be used to produce things other than ROMs (especially via the `-x` option), and RGBFIX is sometimes used without RGBLINK anywhere in sight."
msgstr "A questo punto ti potresti chiedere: perch√© non si uniscono tutti questi programmi in uno solo?\n"
"Ci sono ragioni nella storia di questi programmi, ma soprattutto RGBLINK pu√≤ fare altro (per esempio usando `-x`), e a volte RGBFIX √® usato senza che RGBLINK sia minimamente necessario."

#: src/part1/toolchain.md:57
msgid "## File names"
msgstr "## Nomi dei file"

#: src/part1/toolchain.md:59
msgid "Note that RGBDS does not care at all about the files' extensions.\n"
"Some people call their source code `.s`, for example, or their object files `.obj`.\n"
"The file names don't matter, either; it's just practical to keep the same name."
msgstr "A RGBDS, come alla maggior parte dei programmi, non importa come chiami i file n√© l'estensione che gli dai: l'importante √® il contenuto.\n"
"Per esempio molti usano l'estensione `.s` per il sorgente, oppure `.obj` per gli oggetti."

#: src/part1/bin_and_hex.md:1
msgid "# Binary and hexadecimal"
msgstr "# Binario ed esadecimale"

#: src/part1/bin_and_hex.md:3
msgid "Before we talk about the code, a bit of background knowledge is in order.\n"
"When programming at a low level, understanding of *[binary](https://en.wikipedia.org/wiki/Binary_number)* and *[hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal)* is mandatory.\n"
"Since you may already know about both of these, a summary of the RGBDS-specific information is available at the end of this lesson."
msgstr "Prima di passare al codice dobbiamo introdurre alcuni concetti.\n\n"
"Quando si programma ad un basso livello √® fondamentale capire bene i sistemi *[binario](https://it.wikipedia.org/wiki/Sistema_numerico_binario)* ed *[esadecimale](https://it.wikipedia.org/wiki/esadecimale)*.\n"
"Se gi√† conoscessi questi concetti, in fondo alla pagina ci sono delle informazioni specifiche all'uso di RGDBS."

#: src/part1/bin_and_hex.md:7
msgid "So, what's binary?\n"
"It's a different way to represent numbers, in what's called *base 2*.\n"
"We're used to counting in [base 10](https://en.wikipedia.org/wiki/Decimal), so we have 10 digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9.\n"
"Here's how digits work:"
msgstr "Cos'√® il binario?\n"
"√à semplicemente un modo alternativo di rappresentare i numeri, in _base 2_.\n"
"Noi contiamo in [base 10](https://it.wikipedia.org/wiki/decimale), ovvero con 10 cifre: 0, 1, 2, 3, 4, 5, 6, 7, 8, e 9.\n"
"Le cifre hanno una funzione ben specifica:"

#: src/part1/bin_and_hex.md:12
msgid "```\n"
"  42 =                       4 √ó 10   + 2\n"
"     =                       4 √ó 10^1 + 2 √ó 10^0\n"
"                                  ‚Üë          ‚Üë\n"
"    These tens come from us counting in base 10!"
msgstr "```\n"
"  42 =                       4 √ó 10   + 2\n"
"     =                       4 √ó 10^1 + 2 √ó 10^0\n"
"                                  ‚Üë          ‚Üë\n"
"    \tqui usiamo 10 perch√© contiamo in base 10!"

#: src/part1/bin_and_hex.md:18
msgid "1024 = 1 √ó 1000 + 0 √ó 100  + 2 √ó 10   + 4\n"
"     = 1 √ó 10^3 + 0 √ó 10^2 + 2 √ó 10^1 + 4 √ó 10^0\n"
"       ‚Üë          ‚Üë          ‚Üë          ‚Üë\n"
"And here we can see the digits that make up the number!\n"
"```"
msgstr "1024 = 1 √ó 1000 + 0 √ó 100  + 2 √ó 10   + 4\n"
"     = 1 √ó 10^3 + 0 √ó 10^2 + 2 √ó 10^1 + 4 √ó 10^0\n"
"       ‚Üë          ‚Üë          ‚Üë          ‚Üë\n"
" e qui vediamo le cifre che compongono il numero!\n"
"```"

#: src/part1/bin_and_hex.md:24
#: src/part1/registers.md:40
#: src/part1/assembly.md:61
#: src/part1/tracing.md:38
msgid "::: tip:‚ÑπÔ∏è"
msgstr ""

#: src/part1/bin_and_hex.md:26
msgid "`^` here means \"to the power of\", where `X^N` is equal to multiplying `X` with itself `N` times, and `X ^ 0 = 1`."
msgstr "`^` qui significa \"alla potenza di\", dove `X^N` √® uguale a moltiplicare `X` con se stesso `N` volte, e `X ^ 0 = 1`."

#: src/part1/bin_and_hex.md:30
msgid "Decimal digits form a unique *decomposition* of numbers in powers of 10 (*deci*mal is base 10, remember?).\n"
"But why stop at powers of 10?\n"
"We could use other bases instead, such as base 2.\n"
"(Why base 2 specifically will be explained later.)"
msgstr "Con le cifre decimali ogni numero viene *scomposto* in maniera univoca in potenze di 10 (il *deci*male √® la base 10, ricordi?).\n"
"Ma perch√© fermarsi alle potenze di 10?\n"
"Potremmo invece usare altre basi, come la base 2\n"
"(il perch√© della base 2 sar√† spiegato pi√π avanti)."

#: src/part1/bin_and_hex.md:35
msgid "Binary is base 2, so there are only two digits, called *bits*: 0 and 1.\n"
"Thus, we can generalize the principle outlined above, and write these two numbers in a similar way:"
msgstr "Il sistema binario √® in base 2, quindi ha solo due cifre (chiamate *bit*): 0 e 1.\n"
"Possiamo quindi generalizzare il principio descritto sopra e riscrivere i due numeri di prima in modo simile:"

#: src/part1/bin_and_hex.md:38
msgid "```\n"
"  42 =                                                    1 √ó 32  + 0 √ó 16  + 1 √ó 8   + 0 √ó 4   + 1 √ó 2   + 0\n"
"     =                                                    1 √ó 2^5 + 0 √ó 2^4 + 1 √ó 2^3 + 0 √ó 2^2 + 1 √ó 2^1 + 0 √ó 2^0\n"
"                                                              ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë\n"
"                                          And since now we're counting in base 2, we're seeing twos instead of tens!"
msgstr "```\n"
"  42 =                                                    1 √ó 32  + 0 √ó 16  + 1 √ó 8   + 0 √ó 4   + 1 √ó 2   + 0\n"
"     =                                                    1 √ó 2^5 + 0 √ó 2^4 + 1 √ó 2^3 + 0 √ó 2^2 + 1 √ó 2^1 + 0 √ó 2^0\n"
"                                                              ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë\n"
"                                          E visto che stiamo contando in base 2, vediamo dei due invece dei dieci!"

#: src/part1/bin_and_hex.md:44
msgid "1024 = 1 √ó 1024 + 0 √ó 512 + 0 √ó 256 + 0 √ó 128 + 0 √ó 64  + 0 √ó 32  + 0 √ó 16  + 0 √ó 8   + 0 √ó 4   + 0 √ó 2   + 0\n"
"     = 1 √ó 2^10 + 0 √ó 2^9 + 0 √ó 2^8 + 0 √ó 2^7 + 0 √ó 2^6 + 0 √ó 2^5 + 0 √ó 2^4 + 0 √ó 2^3 + 0 √ó 2^2 + 0 √ó 2^1 + 0 √ó 2^0\n"
"       ‚Üë          ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë\n"
"```"
msgstr "1024 = 1 √ó 1024 + 0 √ó 512 + 0 √ó 256 + 0 √ó 128 + 0 √ó 64  + 0 √ó 32  + 0 √ó 16  + 0 √ó 8   + 0 √ó 4   + 0 √ó 2   + 0\n"
"     = 1 √ó 2^10 + 0 √ó 2^9 + 0 √ó 2^8 + 0 √ó 2^7 + 0 √ó 2^6 + 0 √ó 2^5 + 0 √ó 2^4 + 0 √ó 2^3 + 0 √ó 2^2 + 0 √ó 2^1 + 0 √ó 2^0\n"
"       ‚Üë          ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë\n"
"```"

#: src/part1/bin_and_hex.md:49
msgid "So, by applying the same principle, we can say that in base 2, 42 is written as `101010`, and 1024 as `10000000000`. \n"
"Since you can't tell ten (decimal 10) and two (binary 10) apart, RGBDS assembly has binary numbers prefixed by a percent sign: 10 is ten, and %10 is two."
msgstr "Quindi, applicando lo stesso principio, possiamo dire che in base 2, 42 si scrive come `101010` e 1024 come `10000000000`. \n"
"Poich√© non √® possibile distinguere tra dieci (10 decimale) e due (10 binario), l'assemblaggio RGBDS prevede numeri binari preceduti da un segno di percentuale: 10 √® dieci e %10 √® due."

#: src/part1/bin_and_hex.md:52
msgid "Okay, but why base 2 specifically?\n"
"Rather conveniently, a bit can only be 0 or 1, which are easy to represent as \"ON\" or \"OFF\", empty or full, etc!\n"
"If you want, at home, to create a one-bit memory, just take a box.\n"
"If it's empty, it stores a 0; if it contains *something*, it stores a 1.\n"
"Computers thus primarily manipulate binary numbers, and this has a *slew* of implications, as we will see throughout this entire tutorial."
msgstr "Ok, ma perch√© proprio la base 2?\n"
"Visto che un bit pu√≤ essere solo 0 o 1, √® molto facile rappresentarlo: pu√≤ essere \"ON\" o \"OFF\", vuoto o pieno, ecc!\n"
"Se ad esempio si vuole creare una memoria da un bit basta prendere una scatola:\n"
"se √® vuota allora simboleggia uno 0; se contiene *qualcosa*, allora √® un 1.\n"
"I computer manipolano quindi principalmente numeri binari e questo ha *molte* implicazioni, come vedremo nel corso di questo tutorial."

#: src/part1/bin_and_hex.md:58
msgid "## Hexadecimal"
msgstr "## Esadecimale"

#: src/part1/bin_and_hex.md:60
msgid "To recap, decimal isn't practical for a computer to work with, instead relying on binary (base 2) numbers.\n"
"Okay, but binary is really impractical to work with.\n"
"Take %10000000000, aka 2048; when in decimal only 4 digits are required, binary instead needs 12!\n"
"And, did you notice that I actually wrote one zero too few?\n"
"Fortunately, hexadecimal is here to save the day! ü¶∏"
msgstr "Ricapitolando: il decimale non √® pratico per i computer, che si affidano invece ai numeri binari (base 2).\n"
"Ok, ma il binario √® davvero difficile da usare per noi programmatori.\n"
"Prendiamo %10000000000, ovvero 2048; mentre per scriverlo in decimale bastano solo 4 cifre, in binario ne servono 12!\n"
"E probabilmente non avete neanche notato che ho scritto uno zero di troppo!\n"
"Per fortuna arriva l'esadecimale a salvare la situazione! ü¶∏"

#: src/part1/bin_and_hex.md:66
msgid "Base 16 works just the same as every other base, but with 16 digits, called *nibbles*: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F."
msgstr "La base 16 funziona esattamente come tutte le altre basi, ma con 16 cifre (chiamate \"*nibbles*\" in inglese): 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, ed F."

#: src/part1/bin_and_hex.md:68
msgid "```\n"
"  42 =            2 √ó 16   + 10\n"
"     =            2 √ó 16^1 + A √ó 16^0"
msgstr "```\n"
"  42 =            2 √ó 16   + 10\n"
"     =            2 √ó 16^1 + A √ó 16^0"

#: src/part1/bin_and_hex.md:72
msgid "1024 = 4 √ó 256  + 0 √ó 16   + 0\n"
"     = 4 √ó 16^2 + 0 √ó 16^1 + 0 √ó 16^0\n"
"```"
msgstr "1024 = 4 √ó 256  + 0 √ó 16   + 0\n"
"     = 4 √ó 16^2 + 0 √ó 16^1 + 0 √ó 16^0\n"
"```"

#: src/part1/bin_and_hex.md:76
msgid "Like binary, we will use a prefix to denote hexadecimal, namely `$`.\n"
"So, 42 = $2A, and 1024 = $400.\n"
"This is *much* more compact than binary, and slightly more than decimal, too; but what makes hexadecimal very interesting is that one nibble corresponds *exactly* to 4 bits!"
msgstr "Come per il binario useremo un prefisso per indicare l'esadecimale, cio√® `$`.\n"
"Quindi, 42 = $2A e 1024 = $400.\n"
"Questo √® *molto* pi√π compatto del binario, e anche un po' pi√π del decimale; ma ci√≤ che rende l'esadecimale molto interessante √® che una sua cifra corrisponde *esattamente* a 4 bit!"

#: src/part1/bin_and_hex.md:80
msgid " Nibble | Bits\n"
":------:|:----:\n"
"     $0 | %0000\n"
"     $1 | %0001\n"
"     $2 | %0010\n"
"     $3 | %0011\n"
"     $4 | %0100\n"
"     $5 | %0101\n"
"     $6 | %0110\n"
"     $7 | %0111\n"
"     $8 | %1000\n"
"     $9 | %1001\n"
"     $A | %1010\n"
"     $B | %1011\n"
"     $C | %1100\n"
"     $D | %1101\n"
"     $E | %1110\n"
"     $F | %1111"
msgstr " Nibble | Bit\n"
":------:|:----:\n"
"     $0 | %0000\n"
"     $1 | %0001\n"
"     $2 | %0010\n"
"     $3 | %0011\n"
"     $4 | %0100\n"
"     $5 | %0101\n"
"     $6 | %0110\n"
"     $7 | %0111\n"
"     $8 | %1000\n"
"     $9 | %1001\n"
"     $A | %1010\n"
"     $B | %1011\n"
"     $C | %1100\n"
"     $D | %1101\n"
"     $E | %1110\n"
"     $F | %1111"

#: src/part1/bin_and_hex.md:99
msgid "This makes it very easy to convert between binary and hexadecimal, while retaining a compact enough notation.\n"
"Thus, hexadecimal is used a lot more than binary.\n"
"And, don't worry, decimal can still be used üòú"
msgstr "Ci√≤ rende facilissimo convertire tra binario ed esadecimale, e mantenere una notazione sufficientemente compatta.\n"
"Per questo, l'esadecimale √® molto pi√π utilizzato del binario.\n"
"E non preoccuparti, puoi ancora usare il decimale üòú"

#: src/part1/bin_and_hex.md:103
msgid "(Side note: one could point that octal, i.e. base 8, would also work for this; however, we will primarily deal with units of 8 bits, for which hexadecimal works much better than octal. RGBDS supports octal via the `&` prefix, but I have yet to see it used.)"
msgstr "(Nota: si potrebbe pensare che anche l'ottale, cio√® la base 8, funzioni altrettanto bene; tuttavia avremo a che fare perlopi√π con unit√† di 8 bit, per le quali l'esadecimale funziona molto meglio dell'ottale. Volendo, RGBDS permette di usare l'ottale tramite il prefisso `&`, ma non l'ho mai visto usare nella pratica)"

#: src/part1/bin_and_hex.md:105
msgid "::: tip:üí°"
msgstr ""

#: src/part1/bin_and_hex.md:107
msgid "If you're having trouble converting between decimal and binary/hexadecimal, check if your favorite calculator program doesn't have a \"programmer\" mode, or a way to convert between bases."
msgstr "Se vi √® difficile convertire i numeri tra le diverse basi, controllate se la vostra calcolatrice ha una modalit√† \"programmatore\" o un altro modo per convertire i numeri: la maggior parte delle calcolatrici lo ha."

#: src/part1/bin_and_hex.md:111
msgid "## Summary"
msgstr "## Riepilogo"

#: src/part1/bin_and_hex.md:113
msgid "- In RGBDS assembly, the hexadecimal prefix is `$`, and the binary prefix is `%`.\n"
"- Hexadecimal can be used as a \"compact binary\" notation.\n"
"- Using binary or hexadecimal is useful when individual bits matter; otherwise, decimal works just as well.\n"
"- For when numbers get a bit too long, RGBASM allows underscores between digits (`123_465`, `%10_1010`, `$DE_AD_BE_EF`, etc.)"
msgstr "- Nell'assembly RGBDS, il prefisso esadecimale √® `$`, mentre il prefisso binario √® `%`.\n"
"- L'esadecimale pu√≤ essere usato come notazione \"binaria compatta\".\n"
"- L'uso del binario o dell'esadecimale √® utile quando i singoli bit sono importanti; altrimenti, il decimale va comunque bene.\n"
"- Nei casi in cui i numeri iniziano a diventare troppo lunghi, RGBASM consente di inserire dei trattini bassi tra le cifre (`123_465`, `%10_1010`, `$DE_AD_BE_EF`, ecc.)."

#: src/part1/registers.md:1
msgid "# Registers"
msgstr "# Registri"

#: src/part1/registers.md:3
msgid "Alright!\n"
"Now that we know what bits are, let's talk about how they're used.\n"
"Don't worry, this is mostly prep work for the next section, where we will‚Äîfinally!‚Äîlook at the code üëÄ"
msgstr "Bene!\n"
"Ora che sappiamo cosa sono i bit, cerchiamo di capire come si usano.\n"
"Non ti preoccupare, tutto questo √® per lo pi√π in preparazione alla prossima parte, dove ci butteremo finalmente nel codice vero e proprio üëÄ"

#: src/part1/registers.md:7
msgid "First, if you opened Emulicious, you have been greeted with just the Game Boy screen.\n"
"So, it's time we pop the debugger open!\n"
"Go to \"Tools\", then click \"Debugger\", or press <kbd><kbd>F1</kbd></kbd>.\n"
"Then in the debugger's menu, click \"View\", then click \"Show Addresses\""
msgstr ""

#: src/part1/registers.md:12
msgid "<video controls poster=\"../assets/vid/debugger.poster.png\">\n"
"\t<source src=\"../assets/vid/debugger.webm\" type=\"video/webm\">\n"
"\t<source src=\"../assets/vid/debugger.mp4\" type=\"video/mp4\">"
msgstr "<video controls poster=\"../assets/vid/debugger.poster.png\">\n"
"\t<source src=\"../assets/vid/debugger.webm\" type=\"video/webm\">\n"
"\t<source src=\"../assets/vid/debugger.mp4\" type=\"video/mp4\">"

#: src/part1/registers.md:16
msgid "\t<img src=\"../assets/vid/debugger.gif\" alt=\"Video demonstration in Emulicious\">\n"
"</video>"
msgstr ""

#: src/part1/registers.md:19
msgid "The debugger may look intimidating at first, but don't worry, soon we'll be very familiar with it!\n"
"For now, let's focus on this small box near the top-right, the *register viewer*."
msgstr "Il debugger potrebbe sembrare incomprensibile all'inizio, ma non ti preoccupare: ti ci abituerai in fretta!\n"
"Per il momento guarda in alto a destra, dove c'√® un piccolo spazio intitolato _register viewer_ (visualizzatore dei registri)."

#: src/part1/registers.md:22
msgid "![Picture of the register viewer's location](../assets/img/reg_viewer.png)"
msgstr "![Immagine della posizione del visualizzatore di registri](../assets/img/reg_viewer.png)"

#: src/part1/registers.md:26
msgid "The register viewer shows both *CPU registers* and some *hardware registers*.\n"
"This lesson will only deal with CPU registers, so that's why we will be ignoring some of these entries here."
msgstr "Il visualizzatore mostra sia i _registri della CPU_ che alcuni _registri hardware_.\n"
"In questa lezione parleremo solo dei registri della CPU, perci√≤ non ti preoccupare se salteremo alcuni nomi."

#: src/part1/registers.md:31
msgid "What are CPU registers?\n"
"Well, imagine you're preparing a cake.\n"
"You will be following a recipe, whose instructions may be \"melt 125g of chocolate and 125g of butter, blend with 2 eggs\" and so on.\n"
"You will fetch some ingredients from the fridge as needed, but you don't cook inside the fridge; for that, you have a small workspace."
msgstr "Ma cosa sono questi registri della CPU?\n"
"Ti faccio un esempio: immagina di star preparando una torta.\n"
"Ovviamente avrai una ricetta da seguire, come ad esempio \"sciogli 125g di cioccolato e 125g di burro, mescola il tutto con due uova\" e cos√¨ via.\n"
"Dopo aver preso gli ingredienti, non li usi direttamente nel frigo; per comodit√†, li prenderai e li metterai su un banco da lavoro o un tavolo dove lavorarci pi√π facilmente."

#: src/part1/registers.md:36
msgid "Registers are pretty much the CPU's workspace.\n"
"They are small, tiny chunks of memory embedded directly in the CPU (only 10 bytes for the Game Boy's CPU, and even modern CPUs have less than a kilobyte if you don't count <a href=\"https://en.wikipedia.org/wiki/SIMD\"><abbr title=\"Single Instruction, Multiple Data\">SIMD</abbr></a> registers).\n"
"Operations are not performed directly on data stored in memory, which would be equivalent to breaking eggs directly inside our fridge, but they are performed on registers."
msgstr "I registri sono questo tavolo, su cui il processore poggia temporaneamente i suoi ingredienti.\n"
"Pi√π concretamente, sono dei piccoli spazi di memoria (Il GameBoy ne ha solo 10 byte, e anche le CPU moderne hanno meno di un kilobyte se non si contano i registri <a href=\"https://it.wikipedia.org/wiki/SIMD\"><abbr title=\"Single Instruction, Multiple Data\">SIMD</abbr></a>).\n"
"Eseguire le operazioni direttamente sulla memoria √® scomodo, sarebbe come rompere le uova nel frigo: per questo le spostiamo sul tavolo, i registri, prima di romperle."

#: src/part1/registers.md:42
msgid "There are exceptions to this rule, like many other \"rules\" I will give in this tutorial; I will paper over them to keep the mental complexity reasonable, but don't treat my word as gospel either."
msgstr "Ovviamente ci sono eccezioni a questa regola, come un po' tutte le regole che ti spiegheremo nel tutorial; stiamo semplificando di molto le cose per mantenerle ad un livello abbastanza facile da comprendere, perci√≤ non prendere mai queste regole troppo alla lettera."

#: src/part1/registers.md:46
msgid "## General-purpose registers"
msgstr "## Registri Generici"

#: src/part1/registers.md:48
msgid "CPU registers can be placed into two categories: *general-purpose* and *special-purpose*.\n"
"A \"general-purpose\" register (<abbr title=\"General-Purpose Register\">GPR</abbr> for short) can be used for storing arbitrary integer numbers.\n"
"Some GPRs are special nonetheless, as we will see later; but the distinction is \"can I store arbitrary integers in it?\"."
msgstr "A grandi linee ci sono due tipi di registri: _registri generici_ e _registri speciali_.\n"
"Un registro generico (abbreviato <abbr title=\"inglese: General-Purpose Register\">GPR</abbr>) pu√≤ essere usato per dati di qualunque tipo.\n"
"Qualche GPR ha anche delle funzioni pi√π specifiche, come vedremo pi√π in l√†; in generale per distinguerli da quelli speciali chiediti \"posso inserirci dati arbitrari?\"."

#: src/part1/registers.md:52
msgid "I won't introduce special-purpose registers quite yet, as their purpose wouldn't make sense yet.\n"
"Rather, they will be discussed as the relevant concepts are introduced."
msgstr "Parleremo poi dei registri speciali;\n"
"hanno funzioni particolari che non abbiamo ancora spiegato e perci√≤ li spiegheremo quando parleremo della funzione specifica, visto che fino ad allora non ne capiremmo lo scopo."

#: src/part1/registers.md:55
msgid "The Game Boy CPU has seven 8-bit GPRs: `a`, `b`, `c`, `d`, `e`, `h`, and `l`.\n"
"\"8-bit\" means that, well, they store 8 bits.\n"
"Thus, they can store integers from 0 to 255 (%1111_1111 aka $FF)."
msgstr "La CPU del Game Boy ha sette GPR a 8 bit: `a`, `b`, `c`, `d`, `e`, `h` e `l`.\n"
"\"8 bit\" significa che memorizzano 8 bit.\n"
"Pertanto, possono memorizzare numeri interi da 0 a 255 (%1111_1111 alias $FF)."

#: src/part1/registers.md:59
msgid "`a` is the *accumulator*, and we will see later that it can be used in special ways."
msgstr "`a' √® l'*accumulatore*, e come vedremo pi√π avanti pu√≤ essere usato in modi particolari."

#: src/part1/registers.md:61
msgid "A special feature is that these registers, besides `a`, are *paired up*, and the pairs can be treated as the 16-bit registers `bc`, `de`, and `hl`.\n"
"The pairs are *not* separate from the individual registers; for example, if `d` contains 192 ($C0) and `e` contains 222 ($DE), then `de` contains 49374 ($C0DE) = 192 √ó 256 + 222.\n"
"The other pairs work similarly."
msgstr "Questi registri hanno un'altra caratteristica interessante; sono tutti (tranne `a`) _accoppiati_ ad un altro registro, e queste coppie possono funzionare da registri a 16 bit: `BC`, `DE`, e `HL`.\n"
"Ma tieni sempre a mente che le coppie _non_ sono indipendenti dai registri che li formano; se, ad esempio, `D` contiene 192 ($C0) ed `E` 222 ($DE) allora `DE` conterr√† 49374 ($C0DE) = `D √ó 0x100 + E`.\n"
"Tutte le altre coppie funzionano allo stesso modo."

#: src/part1/registers.md:65
msgid "Modifying `de` actually modifies both `d` and `e` at the same time, and modifying either individually also affects the pair.\n"
"How do we modify registers?\n"
"Let's see how, with our first assembly instructions!"
msgstr "Quindi, cambiare il valore di `DE` modifica sia quello di `D` che di `E` allo stesso tempo e modificare `D` o `E` cambier√† il valore della coppia `DE`.\n"
"Ok, ma come facciamo a usare questi registri?\n"
"√à il momento di dare un'occhiata all'Assembly!"

#: src/part1/assembly.md:1
msgid "# Assembly basics"
msgstr "# Primi passi in Assembly"

#: src/part1/assembly.md:3
msgid "Alright, now that we know what the tools *do*, let's see what language RGBASM speaks.\n"
"I will take a short slice of the beginning of `hello-world.asm`, so that we agree on the line numbers, and you can get some syntax highlighting even if your editor doesn't support it."
msgstr "Bene, ora che sappiamo cosa *fanno* gli strumenti, vediamo che lingua parla RGBASM.\n"
"Prender√≤ una breve porzione dell'inizio di `hello-world.asm`, in modo da essere d'accordo sui numeri di riga e da avere un'evidenziazione della sintassi anche se il vostro editor non la supporta."

#: src/part1/assembly.md:6
msgid "```rgbasm,linenos,start=1\n"
"INCLUDE \"hardware.inc\""
msgstr ""

#: src/part1/assembly.md:9
#: src/part3/entry-point.md:18
msgid "SECTION \"Header\", ROM0[$100]"
msgstr ""

#: src/part1/assembly.md:11
#: src/part1/header.md:138
#: src/part2/getting-started.md:38
#: src/part3/entry-point.md:20
msgid "\tjp EntryPoint"
msgstr "\tjp EntryPoint"

#: src/part1/assembly.md:13
#: src/part3/entry-point.md:22
msgid "\tds $150 - @, 0 ; Make room for the header"
msgstr "\tds $150 - @, 0 ; Lascia spazio per l'header"

#: src/part1/assembly.md:15
msgid "EntryPoint:\n"
"\t; Shut down audio circuitry\n"
"\tld a, 0\n"
"\tld [rNR52], a\n"
"```"
msgstr "EntryPoint:\n"
"\t; Spegnimento del circuito audio\n"
"\tld A, 0\n"
"\tld [rNR52], A\n"
"````"

#: src/part1/assembly.md:21
msgid "Let's analyze it.\n"
"Note that I will be ignoring a *lot* of RGBASM's functionality; if you're curious to know more, you should wait until parts II and III, or [read the docs](https://rgbds.gbdev.io/docs)."
msgstr "Analizziamolo insieme.\n"
"Sappi che per il momento salteremo _molte_ delle funzionalit√† di RGBASM; se fossi curioso di saperne di pi√π, dovrai aspettare fino alla seconda o terza parte oppure leggere la [documentazione](https://rgbds.gbdev.io/docs)."

#: src/part1/assembly.md:24
msgid "## Comments"
msgstr "## Commenti"

#: src/part1/assembly.md:26
msgid "We'll start with line 10, which should appear gray above.\n"
"Semicolons `;` denote *comments*.\n"
"Everything from a semicolon to the end of the line is *ignored* by RGBASM.\n"
"As you can see on line 7, comments need not be on an otherwise empty line."
msgstr "Iniziamo dalla riga 10, che dovrebbe essere grigia nel riquadro qui sopra.\n"
"I punti e virgola `;` indicano un _commento_.\n"
"I commenti (che finiscono alla fine della riga) sono _ignorati_ dall'assembler, indipendentemente dal contenuto.\n"
"Come vedi alla riga 7, puoi anche inserire commenti dopo aver scritto altro."

#: src/part1/assembly.md:31
msgid "Comments are a staple of every good programming language; they are useful to give context as to what code is doing.\n"
"They're the difference between \"Pre-heat the oven at 180 ¬∞C\" and \"Pre-heat the oven at 180 ¬∞C, any higher and the cake would burn\", basically.\n"
"In any language, good comments are very useful; in assembly, they play an even more important role, as many common semantic facilities are not available."
msgstr "I commenti sono molto importanti in tutti i linguaggi di programmazione: ti aiutano a descrivere la funzione del tuo codice.\n"
"√à pi√π o meno la differenza tra \"scalda il forno fino a 180¬∞C\" e \"scalda il forno a 180¬∞C, se lo scaldassi di pi√π la torta brucerebbe\".\n"
"I commenti sono utilissimi in ogni linguaggio di programmazione, ma in Assembly sono ancora pi√π importanti: infatti, il codice Assembly √® molto pi√π astratto."

#: src/part1/assembly.md:35
msgid "## Instructions"
msgstr "## Istruzioni"

#: src/part1/assembly.md:37
msgid "Assembly is a very line-based language.\n"
"Each line can contain one of two things:\n"
"- a *directive*, which instructs RGBASM to do something, or\n"
"- an *instruction*[^instr_directive], which is written directly into the ROM."
msgstr "L'assembly √® un linguaggio \"line-based\", ovvero incentrato sulle righe.\n"
"Ogni riga di codice pu√≤ contenere una di queste due cose:\n"
"- una *direttiva*, che istruisce RGBASM a fare qualcosa, oppure\n"
"- una *istruzione*[^instr_direttiva], che viene scritta direttamente nella ROM."

#: src/part1/assembly.md:42
msgid "We will talk about directives later, for now let's focus on instructions: for example, in the snippet above, we will ignore lines 1 (`INCLUDE`), 7 (`ds`), and 3 (`SECTION`)."
msgstr "Parleremo delle direttive pi√π avanti, per ora concentriamoci sulle istruzioni: per esempio, nello snippet qui sopra, ignoreremo le righe 1 (`INCLUDE`), 7 (`ds`) e 3 (`SECTION`)."

#: src/part1/assembly.md:44
msgid "To continue the cake-baking analogy even further, instructions are like steps in a recipe.\n"
"The console's processor (<abbr title=\"Central Processing Unit\">CPU</abbr>) executes instructions one at a time, and that... eventually does something!\n"
"Like baking a cake, drawing a \"Hello World\" image, or displaying a Game Boy programming tutorial!\n"
"\\*wink\\* \\*wink\\*"
msgstr "Per continuare l'analogia con la preparazione di una torta, le istruzioni sono come i passi di una ricetta.\n"
"Il processore (<abbr title=\"Central Processing Unit\">CPU</abbr>) esegue un'istruzione alla volta. Istruzione dopo istruzione... dopo un po' si arriva al risultato!\n"
"Come cuocere una torta, disegnare \"Hello World\", oppure mostrarti un tutorial sull'Assembly del GameBoy!"

#: src/part1/assembly.md:49
msgid "Instructions have a *mnemonic*, which is a name they are given, and *operands*, which indicate what they should act upon.\n"
"For example, in \"melt the chocolate and butter in a saucepan\", *the whole sentence* would be the instruction, *the verb* \"melt\" would be the mnemonic, and \"chocolate\", \"butter\", and \"saucepan\" the operands, i.e. some kind of parameters to the operation."
msgstr "Le istruzioni sono composte da una _mnemonica_, un nome con cui le puoi invocare, e dei _parametri_, ovvero su cosa va eseguita l'operazione.\n"
"Ad esempio: in \"sciogli il cioccolato ed il burro in una padella\" l'istruzione √® _tutta la frase_; la mnemonica sarebbe l'_azione_, ovvero sciogli, mentre i parametri sono gli _oggetti_ della frase (cioccolato, burro, padella)."

#: src/part1/assembly.md:52
msgid "Let's discuss the most fundamental instruction, **`ld`**.\n"
"`ld` stands for \"LoaD\", and its purpose is simply to copy data from its right operand ([\"<abbr title=\"Right-Hand Side\">RHS</abbr>\"](https://en.wikipedia.org/wiki/Sides_of_an_equation)) into its left operand ([\"<abbr title=\"Left-Hand Side\">LHS</abbr>\"](https://en.wikipedia.org/wiki/Sides_of_an_equation)).\n"
"For example, take line 11's `ld a, 0`: it copies (\"loads\") the value 0 into the 8-bit register `a`[^ld_imm_from].\n"
"If you look further in the file, line 33 has `ld a, b`, which causes the value in register `b` to be copied into register `a`."
msgstr "Cominciamo dall'istruzione pi√π importante: **`ld`**.\n"
"`ld` sta per \"<abbr title=\"LoaD in inglese\">carica</abbr>\", e semplicemente copia i dati contenuti nel secondo parametro (\"[<abbr title=\"Right-Hand Side\">RHS</abbr>](https://en.wikipedia.org/wiki/Sides_of_an_equation)\") nel primo (\"[<abbr title=\"Left-Hand Side\">LHS</abbr>](https://en.wikipedia.org/wiki/Sides_of_an_equation)\").\n"
"Per esempio, guardiamo la riga 11 del nostro programma, `ld a, 0`: copia (\"carica\") il numero zero nel registro `a`[^ld_imm_from].\n"
"Per fare un altro esempio, a riga 33 troviamo `ld a, b`: significa semplicemente \"copia il valore di `b` in `a`."

#: src/part1/assembly.md:57
msgid "Instruction | Mnemonic | Effect\n"
"------------|----------|----------------------\n"
"Load        | `ld`     | Copies values around"
msgstr "Istruzione | Mnemonica | Effetto\n"
"------------|----------|----------------------\n"
"Carica | `ld` | Copia dei valori"

#: src/part1/assembly.md:63
msgid "Due to CPU limitations, not all operand combinations are valid for `ld` and many other instructions; we will talk about this when writing our own code later."
msgstr "Per via delle limitazioni del processore, non tutte le combinazioni di operandi sono valide per `ld` e per molte altre istruzioni; ne parleremo in seguito, quando arriver√† il momento di scrivere il nostro codice."

#: src/part1/assembly.md:67
#: src/part1/jumps.md:34
#: src/part1/tiles.md:35
msgid "::: tip:ü§î"
msgstr ""

#: src/part1/assembly.md:69
msgid "RGBDS has an [instruction reference](https://rgbds.gbdev.io/docs/gbz80.7) worth bookmarking, and you can also consult it locally with `man 7 gbz80` if RGBDS is installed on your machine (except Windows...).\n"
"The descriptions there are more succinct, since they're intended as reminders, not as tutorials."
msgstr "RGBDS ha una [lista delle istruzioni del GameBoy](https://rgbds.gbdev.io/docs/gbz80.7) che vale la pena tenere tra i preferiti, e che si pu√≤ anche consultare dal terminale scrivendo `man 7 gbz80` se RGBDS √® installato sulla propria macchina (tranne su Windows...).\n"
"Le descrizioni che trovate in quella pagina sono pi√π concise: sono intese come un promemoria, non come un tutorial."

#: src/part1/assembly.md:74
msgid "## Directives"
msgstr "## Direttive"

#: src/part1/assembly.md:76
msgid "In a way, instructions are destined to the console's CPU, and comments are destined to the programmer.\n"
"But some lines are neither, and are instead sort of metadata destined to RGBDS itself.\n"
"Those are called *directives*, and our Hello World actually contains three of those."
msgstr "Quindi, in un certo senso, le istruzioni sono destinate al processore del GameBoy mentre i commenti sono destinati al programmatore.\n"
"Ma alcune righe non sono n√© l'una n√© l'altra cosa, e sono invece dei metadati destinati a RGBDS stesso.\n"
"Queste sono chiamate *direttive* e il nostro \"Hello World\" ne contiene tre."

#: src/part1/assembly.md:80
msgid "### Including other files"
msgstr "### Includere un altro file"

#: src/part1/assembly.md:82
msgid "```rgbasm,linenos\n"
"INCLUDE \"hardware.inc\"\n"
"```"
msgstr "``rgbasm, linenos\n"
"INCLUDE \"hardware.inc\"\n"
"````"

#: src/part1/assembly.md:86
msgid "Line 1 *includes* `hardware.inc`[^hw_inc_directives].\n"
"Including a file has the same effect as if you copy-pasted it, but without having to actually do that."
msgstr "La riga 1 *include* `hardware.inc`[^hw_inc_directives].\n"
"`Include`ndo un file √® come se copiassimo il suo contenuto alla riga dove inseriamo la direttiva."

#: src/part1/assembly.md:89
msgid "It allows sharing code across files easily: for example, if two files `a.asm` and `b.asm` were to include `hardware.inc`, you would only need to modify `hardware.inc` once for the modifications to apply to both `a.asm` and `b.asm`.\n"
"If you instead copy-pasted the contents manually, you would have to edit both copies in `a.asm` and `b.asm` to apply the changes, which is more tedious and error-prone."
msgstr "Cos√¨ facendo, si pu√≤ riciclare facilmente il codice in diversi file: se, ad esempio, due file `a.asm` e `b.asm` includono `hardware.inc` basta modificare il file perch√© le modifiche si applichino ad `a.asm` e `b.asm`.\n"
"Se invece copiassi a mano il contenuto di `hardware.inc` in `a.asm` e `b.asm` dovresti modificare il contenuto di entrambi ogni volta che vuoi apportare un cambiamento, che non √® solo uno spreco di tempo ma aumenta la possibilit√† di commettere errori."

#: src/part1/assembly.md:92
msgid "`hardware.inc` defines a bunch of constants related to interfacing with the hardware.\n"
"Constants are basically names with a value attached, so when you write out their name, they are replaced with their value.\n"
"This is useful because, for example, it is easier to remember the address of the **LCD** **C**ontrol register as `rLCDC` than `$FF40`."
msgstr "`hardware.inc` definisce alcune costanti molto utili per interfacciarsi con l'hardware del GameBoy.\n"
"Le costanti non sono altro che dei nomi a cui √® assegnato un valore: scrivere una costante equivale a scrivere il valore che le √® assegnato.\n"
"Questo torna molto utile: √® molto pi√π semplice ricordare il registro \"**LCD** **C**ontrol\" (impostazioni dello schermo) col nome `rLCDC` piuttosto che ricordare l'indirizzo `$FF40`."

#: src/part1/assembly.md:96
msgid "We will discuss constants in more detail in Part ‚Ö°."
msgstr "Parleremo delle costanti in modo pi√π approfondito nella Parte ‚Ö°."

#: src/part1/assembly.md:98
msgid "### Sections"
msgstr "### Sezioni"

#: src/part1/assembly.md:100
msgid "Let's first explain what a \"section\" is, then we will see what line 3 does."
msgstr "Spieghiamo innanzitutto che cos'√® una \"sezione\", poi vedremo che cosa fa la riga 3."

#: src/part1/assembly.md:102
msgid "A section represents a contiguous range of memory, and by default, ends up *somewhere* not known in advance.\n"
"If you want to see where all the sections end up, you can ask RGBLINK to generate a \"map file\" with the `-m` flag:"
msgstr "Una sezione rappresenta un intervallo contiguo di memoria che, di base, finisce da *qualche* parte non nota in anticipo.\n"
"Se si vuole vedere dove finisce ogni sezione si pu√≤ chiedere a RGBLINK di generare un \"file mappa\" con l'opzione `-m`:"

#: src/part1/assembly.md:105
msgid "```console\n"
"$ rgblink hello-world.o -m hello-world.map\n"
"```"
msgstr "```console\n"
"$ rgblink hello-world.o -m hello-world.map\n"
"```"

#: src/part1/assembly.md:109
msgid "...and we can see, for example, where the `\"Tilemap\"` section ended up:"
msgstr "...e possiamo vedere, per esempio, dove √® finita la sezione `\"Tilemap\"`:"

#: src/part1/assembly.md:111
msgid "```\n"
"  SECTION: $05a6-$07e5 ($0240 bytes) [\"Tilemap\"]\n"
"```"
msgstr "```\n"
"  SECTION: $05a6-$07e5 ($0240 bytes) [\"Tilemap\"]\n"
"```"

#: src/part1/assembly.md:115
msgid "Sections cannot be split by RGBDS, which is useful e.g. for code, since the processor executes instructions one right after the other (except jumps, as we will see later).\n"
"There is a balance to be struck between too many and not enough sections, but it typically doesn't matter much until banking is introduced into the picture‚Äîand it won't be until much, much later."
msgstr "Le sezioni non possono essere divise da RGBDS, che √® utile ad esempio per il codice poich√© il processore esegue le istruzioni una dopo l'altra (a parte con i salti, che vedremo pi√π avanti).\n"
"Va trovato il giusto equilibrio per il numero di sezioni: non troppe ma neanche troppo poche, anche se in genere non ha molta importanza fino a quando non si inizia a parlare di banche di memoria."

#: src/part1/assembly.md:118
msgid "So, for now, let's just assume that one section should contain things that \"go together\" topically, and let's examine one of ours."
msgstr "Quindi, per ora, assumiamo che una sezione debba contenere cose che \"vanno insieme\" dal punto di vista topico, ed esaminiamo una delle nostre."

#: src/part1/assembly.md:120
msgid "```rgbasm,linenos,start=3\n"
"SECTION \"Header\", ROM0[$100]\n"
"```"
msgstr "```rgbasm,linenos,start=3\n"
"SECTION \"Header\", ROM0[$100]\n"
"```"

#: src/part1/assembly.md:124
msgid "So!\n"
"What's happening here?\n"
"Well, we are simply declaring a new section; all instructions and data after this line and until the next `SECTION` one will be placed in this newly-created section.\n"
"Before the first `SECTION` directive, there is no \"active\" section, and thus generating code or data will be met with a `Cannot output data outside of a SECTION` error."
msgstr "Quindi!\n"
"Cosa fa questa riga?\n"
"Altro non √® che la dichiarazione di una nuova sezione; tutte le istruzioni e i dati dopo questa riga e fino alla successiva dichiarazione `SECTION` saranno inseriti in questa sezione appena creata.\n"
"Prima della prima direttiva `SECTION` non c'√® una sezione \"attiva\": scrivere dati o codice al di fuori di una sezione ci dar√† l'errore `Cannot output data outside of a SECTION`."

#: src/part1/assembly.md:129
msgid "The new section's name is \"`Header`\".\n"
"Section names can contain any characters (and even be empty, if you want), and must be unique[^sect_name].\n"
"The `ROM0` keyword indicates which \"memory type\" the section belongs to ([here is a list](https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.5#SECTIONS)).\n"
"We will discuss them in Part ‚Ö°."
msgstr "Il nome della nuova sezione √® \"`Header`\".\n"
"I nomi delle sezioni possono contenere qualsiasi carattere (e anche essere vuoti, se si vuole) e devono essere unici[^nome_sezione].\n"
"La parola chiave `ROM0` indica a quale \"tipo di memoria\" appartiene la sezione ([ecco un elenco](https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.5#SECTIONS)).\n"
"Ne parleremo nella Parte ‚Ö°."

#: src/part1/assembly.md:134
msgid "The `[$100]` part is more interesting, in that it is unique to this section.\n"
"See, I said above that:"
msgstr "Dove dice `[100$]` invece √® pi√π interessante, perch√© √® un'indicazione speciale per questa sezione.\n"
"Se ricordi, prima abbiamo detto che:"

#: src/part1/assembly.md:137
msgid "> a section \\[...\\] by default, ends up *somewhere* not known in advance."
msgstr "> Una sezione \\[...\\], di base, finisce da *qualche* parte non nota in anticipo."

#: src/part1/assembly.md:139
msgid "However, some memory locations are special, and so sometimes we need a specific section to span a specific range of memory.\n"
"To enable this, RGBASM provides the `[addr]` syntax, which *forces* the section's starting address to be `addr`."
msgstr "Per√≤ alcune parti della memoria sono speciali, e quindi a volte √® necessario che una sezione specifica copra un intervallo di memoria specifico.\n"
"Per permetterlo, RGBASM ha la sintassi `[addr]` che *forza* l'indirizzo iniziale della sezione a essere `addr`."

#: src/part1/assembly.md:142
msgid "In this case, the memory range $100‚Äì$14F is special, as it is the *ROM's header*.\n"
"We will discuss the header in a couple lessons, but for now, just know that we need not to put any of our code or data in that space.\n"
"How do we do that?\n"
"Well, first, we begin a section at address $100, and then we need to reserve some space."
msgstr "In questo caso, l'intervallo di memoria $100-$14F √® speciale perch√© √® l'header della ROM.\n"
"Parleremo dell'header tra un paio di lezioni, ma per il momento basta sapere che **non** dobbiamo inserire n√© codice n√© dati in quello spazio.\n"
"E come facciamo?\n"
"Innanzitutto, iniziamo una sezione all'indirizzo $100, dopodich√© riserviamo un po' di spazio."

#: src/part1/assembly.md:147
msgid "### Reserving space"
msgstr "### Lasciare spazio"

#: src/part1/assembly.md:149
msgid "```rgbasm,linenos,start=5\n"
"\tjp EntryPoint"
msgstr "```rgbasm,linenos,start=5\n"
"\tjp EntryPoint"

#: src/part1/assembly.md:152
#: src/part1/header.md:140
#: src/part2/getting-started.md:40
msgid "\tds $150 - @, 0 ; Make room for the header\n"
"```"
msgstr "\tds $150 - @, 0 ; Fa spazio per l'header\n"
"```"

#: src/part1/assembly.md:155
msgid "Line 7 claims to \"Make room for the header\", which I briefly mentioned just above.\n"
"For now, let's focus on what `ds` actually does."
msgstr "La riga 7 afferma di \"fare spazio per l'header\", di cui ho parlato brevemente poco sopra.\n"
"Per ora, concentriamoci su ci√≤ che `ds` fa effettivamente."

#: src/part1/assembly.md:158
msgid "`ds` is used for *statically* allocating memory.\n"
"It simply reserves some amount of bytes, which are set to a given value.\n"
"The first argument to `ds`, here `$150 - @`, is *how many bytes to reserve*.\n"
"The second (optional) argument, here `0`, is *what value to set each reserved byte to*[^ds_pattern]."
msgstr "`ds` √® usato per allocare *staticamente* della memoria.\n"
"Riserva un certo numero di byte, che sono impostati ad un certo valore dato.\n"
"Il primo argomento di `ds`, in questo caso `$150 - @`, √® *quanti byte riservare*.\n"
"Il secondo argomento (che √® opzionale), in questo caso `0`, √® *il valore a cui impostare ogni byte riservato*[^ds_pattern]."

#: src/part1/assembly.md:163
msgid "We will see why these bytes must be reserved in a couple of lessons."
msgstr "Vedremo perch√© questi byte devono essere riservati in un paio di lezioni."

#: src/part1/assembly.md:165
msgid "It is worth mentioning that this first argument here is an *expression*.\n"
"RGBDS (thankfully!) supports arbitrary expressions essentially anywhere.\n"
"This expression is a simple subtraction: $150 minus `@`, which is a special symbol that stands for \"the current memory address\"."
msgstr "√à importante notare che il primo argomento √® un'*espressione*.\n"
"RGBDS (fortunatamente!) supporta l'inserimento di espressioni arbitrarie pressoch√© ovunque.\n"
"Quest'espressione √® una semplice sottrazione: $150 meno `@`, che √® un simbolo speciale che sta per \"l'indirizzo in memoria attuale\"."

#: src/part1/assembly.md:171
msgid "A symbol is essentially \"a name attached to a value\", usually a number.\n"
"We will explore the different types of symbols throughout the tutorial, starting with labels in the next section."
msgstr "Un simbolo √® essenzialmente \"un nome associato a un valore\", di solito un numero.\n"
"Nel corso dell'esercitazione esploreremo i diversi tipi di simboli, a partire dalle etichette nella prossima sezione."

#: src/part1/assembly.md:174
msgid "A numerical symbol used in an expression evaluates to its value, which must be known when compiling the ROM‚Äîin particular, it can't depend on any register's contents."
msgstr "Un simbolo numerico utilizzato in un'espressione viene sostituito dal suo valore, che dev'essere noto al momento della compilazione della ROM; in particolare, non pu√≤ dipendere dal contenuto di alcun registro."

#: src/part1/assembly.md:178
msgid "Oh, but you may be wondering what the \"memory addresses\" I keep mentioning are.\n"
"Let's see about those!"
msgstr "Ora vi starete chiedendo cosa siano questi \"indirizzi di memoria\" di cui continuo a parlare.\n"
"Andiamo subito a scoprirlo!"

#: src/part1/assembly.md:183
msgid "[^instr_directive]:\n"
"Technically, instructions in RGBASM are implemented as directives, basically writing their encoded form to the ROM; but the distinction between the instructions in the source code and those in the final ROM is not worth bringing up right now."
msgstr "[^instr_directive]:\n"
"Tecnicamente le istruzioni in RGBASM sono implementate come direttive, che in pratica scrivono la loro forma codificata nella ROM; ma in questo momento non vale la pena di tirare fuori la distinzione tra le istruzioni nel codice sorgente e quelle nella ROM finale."

#: src/part1/assembly.md:186
msgid "[^ld_imm_from]:\n"
"The curious reader may ask where the value is copied *from*. The answer is simply that the \\\"immediate\\\" byte ($00 in this example) is stored in ROM just after the instruction's opcode byte, and it's what gets copied to `a`.\n"
"We will come back to this when we talk about how instructions are encoded later on."
msgstr "[^ld_imm_from]:\n"
"Il lettore curioso potrebbe chiedersi da *dove* venga copiato il valore. La risposta √® semplicemente che il byte cosiddetto \\\"immediato\\\" ($00 in questo esempio) √® memorizzato nella ROM *immediat*amente dopo il byte del codice dell'istruzione, ed √® questo valore che viene copiato in `a`.\n"
"Torneremo su questo punto pi√π avanti, quando parleremo di come vengono codificate le istruzioni."

#: src/part1/assembly.md:190
msgid "[^hw_inc_directives]:\n"
"`hardware.inc` itself contains more directives, in particular to define a lot of symbols.\n"
"They will be touched upon much later, so we won't look into `hardware.inc` yet."
msgstr "[^hw_inc_directives]:\n"
"Lo stesso `hardware.inc` contiene altre direttive, in particolare per definire molti simboli.\n"
"Saranno trattate molto pi√π avanti, quindi non esamineremo ancora `hardware.inc`."

#: src/part1/assembly.md:194
msgid "[^sect_name]:\n"
"Section names actually only need to be unique for \"plain\" sections, and function differently with \"unionized\" and \"fragment\" sections, which we will discuss much later."
msgstr "[^nome_sezione]:\n"
"I nomi delle sezioni devono essere univoci solo per le sezioni \"semplici\" e funzionano in modo diverso con le sezioni \"unificate\" e \"a frammenti\", di cui parleremo pi√π avanti."

#: src/part1/assembly.md:197
msgid "[^ds_pattern]:\n"
"Actually, since RGBASM 0.5.0, `ds` can accept a *list* of bytes, and will repeat the pattern for as many bytes as specified.\n"
"It just complicates the explanation slightly, so I omitted it for now.\n"
"Also, if the argument is omitted, it defaults to what is specified using the `-p` option **to RGBASM**."
msgstr "[^ds_pattern]:\n"
"In realt√†, da RGBASM 0.5.0, `ds` si pu√≤ usare con un *elenco* di byte e la pattern sar√† ripetuta per il numero di byte necessario.\n"
"Questo complica un po' la spiegazione, quindi per ora l'ho omesso.\n"
"Inoltre, se il parametro di `ds` viene omesso, il suo valore assume quello predefinito specificato con l'opzione `-p` **di RGBASM**."

#: src/part1/memory.md:1
msgid "# Memory"
msgstr "# Memoria"

#: src/part1/memory.md:3
msgid "::: tip:üéâ"
msgstr ""

#: src/part1/memory.md:5
msgid "Congrats, you have just finished the hardest lessons of the tutorial!\n"
"Since you have the basics, from now on, we'll be looking at more and more concrete code."
msgstr "Congratulazioni, avete appena finito le lezioni pi√π difficili del tutorial!\n"
"Dal momento che avete le basi, d'ora in poi vedremo codice sempre pi√π concreto."

#: src/part1/memory.md:10
msgid "If we look at line 29, we see `ld a, [de]`.\n"
"Given what we just learned, this copies a value into register `a`... but where from?\n"
"What do these brackets mean?\n"
"To answer that, we need to talk about *memory*."
msgstr "Se guardiamo alla riga 29 leggiamo `ld a, [de]`.\n"
"Stando a quanto abbiamo appena appreso, questo copia un valore nel registro `a`... ma da dove?\n"
"Cosa significano queste parentesi?\n"
"Per rispondere dobbiamo parlare della *memoria*."

#: src/part1/memory.md:15
msgid "## What's a memory?"
msgstr "## Cos'√® una memoria?"

#: src/part1/memory.md:17
msgid "The purpose of memory is to store information.\n"
"On a piece of paper or a whiteboard, you can write letters to store the grocery list, for example.\n"
"But what can you store in a computer memory?\n"
"The answer to that question is *current*[^memory_magnetic].\n"
"Computer memory is made of little cells that can store current.\n"
"But, as we saw in the lesson about binary, the presence or absence of current can be used to encode binary numbers!"
msgstr "Lo scopo della memoria √® quello di immagazzinare informazioni.\n"
"Su un foglio di carta o su una lavagna si possono scrivere lettere per memorizzare, ad esempio, la lista della spesa.\n"
"Ma cosa si pu√≤ memorizzare nella memoria di un computer?\n"
"La risposta a questa domanda √® *corrente*[^memoria_magnetica].\n"
"La memoria del computer √® costituita da piccole celle in grado di immagazzinare corrente.\n"
"Ma, come abbiamo visto nella lezione sul binario, la presenza o l'assenza di corrente pu√≤ essere utilizzata per codificare i numeri binari!"

#: src/part1/memory.md:24
msgid "tl;dr: memory **stores numbers**.\n"
"In fact, memory is a *long* array of numbers, stored in cells.\n"
"To uniquely identify each cell, it's given a number (what else!) called its *address*.\n"
"Like street numbers!\n"
"The first cell has address 0, then address 1, 2, and so on.\n"
"On the Game Boy, each cell contains *8 bits*, i.e. a *byte*."
msgstr "Per farla breve: la memoria **immagazzina numeri**.\n"
"Difatti la memoria √® una *lunga* lista di numeri, memorizzati in celle.\n"
"Per identificare in modo univoco ogni cella, le viene assegnato un numero (e che altro!) chiamato *indirizzo*.\n"
"Come i numeri civici!\n"
"La prima cella ha l'indirizzo 0, poi l'indirizzo 1, 2 e cos√¨ via.\n"
"Sul Game Boy ogni cella contiene *8 bit*, cio√® un *byte*."

#: src/part1/memory.md:31
msgid "How many cells are there?\n"
"Well, this is actually a trick question..."
msgstr "Quante cellule ci sono?\n"
"In realt√† questa √® una domanda trabocchetto..."

#: src/part1/memory.md:34
msgid "## The many types of memory"
msgstr "## I tanti tipi di memoria"

#: src/part1/memory.md:36
msgid "There are several memory chips in the Game Boy, but we can put them into two categories: <abbr title=\"Read-Only Memory\">ROM</abbr> and <abbr title=\"Random Access Memory\">RAM</abbr>[^rom_ram_and].\n"
"ROM simply designates memory that cannot be written to[^rom_ro], and RAM memory that can be written to."
msgstr "Nel Game Boy sono presenti diversi circuiti di memoria, ma possiamo suddividerli in due categorie: <abbr title=\"Read-Only Memory\">ROM</abbr> e <abbr title=\"Random Access Memory\">RAM</abbr>[^rom_ram_and].\n"
"ROM indica semplicemente la memoria su cui non √® possibile scrivere[^rom_ro], e RAM la memoria su cui √® possibile scrivere."

#: src/part1/memory.md:39
msgid "Due to how they work, the CPU, as well as the memory chips, can only use a single number for addresses.\n"
"Let's go back to the \"street numbers\" analogy: each memory chip is a street, with its own set of numbers, but the CPU has no idea what a street is, it only deals with street numbers.\n"
"To allow the CPU to talk to multiple chips, a sort of \"postal service\", the *chip selector*, is tasked with translating the CPU's street numbers into a street & street number."
msgstr "Per via del loro funzionamento il processore ed i circuiti di memoria possono utilizzare un solo numero per gli indirizzi.\n"
"Torniamo all'analogia dei \"numeri civici\": ogni circuito di memoria √® una strada, con la sua serie di numeri, ma il processore non ha idea di cosa sia una strada, si occupa solo di numeri civici.\n"
"Per consentire al processore di parlare con pi√π circuiti serve una sorta di \"servizio postale\", il *selezionatore di circuito* (\"chip selector\" in inglese), che ha il compito di tradurre i numeri civici del processore in una via ed un numero civico effettivi."

#: src/part1/memory.md:43
msgid "For example, let's say a convention is established where addresses 0 through 1999 go to chip A's addresses 0&ndash;1999, 2000&ndash;2999 to chip B's 0&ndash;999, and 3000&ndash;3999 to chip C's 0&ndash;999.\n"
"Then, if the CPU asks for the byte at address 2791, the chip selector will ask chip B for the byte at its *own* address 791, and forward the reply to the CPU."
msgstr "Ad esempio, supponiamo che sia stata stabilita una convenzione per cui gli indirizzi da 0 a 1999 vanno agli indirizzi 0&ndash;1999 del circuito A, 2000&ndash;2999 allo 0&ndash;999 del circuito B e 3000&ndash;3999 allo 0&ndash;999 del circuito C.\n"
"Quindi, se il processore chiede il byte all'indirizzo 2791, il selettore di chip chieder√† al circuito B il byte al *suo* indirizzo 791 ed inoltrer√† la risposta al processore."

#: src/part1/memory.md:46
msgid "Since addresses dealt with by the CPU do not directly correspond to the chips' addresses, we talk about *logical* addresses (here, the CPU's) versus *physical* addresses (here, the chips'), and the correspondence is called a *memory map*.\n"
"Since we are programming the CPU, we will only be dealing with **logical** addresses, but it's crucial to keep in mind that different addresses may be backed by different memory chips, since each chip has unique characteristics."
msgstr "Poich√© gli indirizzi trattati dal processore non corrispondono direttamente a quelli dei circuiti si parla di indirizzi *logici* (qui, quelli del processore) e di indirizzi *fisici* (qui, quelli dei circuiti), e la corrispondenza √® chiamata *mappa di memoria* (\"memory map\" in inglese).\n"
"Poich√© stiamo programmando il processore ci occuperemo solo di indirizzi **logici**, ma √® fondamentale tenere presente che indirizzi diversi possono essere supportati da circuiti di memoria diversi, poich√© ogni circuito ha caratteristiche uniche."

#: src/part1/memory.md:49
msgid "This may sound complicated, so here is a summary:\n"
"- Memory stores numbers, each 8-bit on the Game Boy.\n"
"- Memory is accessed byte by byte, and the cell being accessed is determined by an *address*, which is just a number.\n"
"- The CPU deals with all memory uniformly, but there are several memory chips each with their own characteristics."
msgstr "Pu√≤ sembrare complicato, quindi ecco un riassunto:\n"
"- La memoria contiene numeri, ognuno dei quali sul Game Boy √® ad 8 bit.\n"
"- Si accede alla memoria byte per byte e la cella a cui si accede √® determinata da un *indirizzo*, che √® semplicemente un numero.\n"
"- Il processore tratta tutta la memoria come se fosse uniforme, ma esistono diversi circuiti di memoria ognuno con le proprie caratteristiche."

#: src/part1/memory.md:54
msgid "### Game Boy memory map"
msgstr "### Mappa di memoria del Game Boy"

#: src/part1/memory.md:56
msgid "Let's answer the question that introduced this section: how many memory cells are there on the Game Boy?\n"
"Well, now, we can reframe this question as \"how many logical addresses are there?\" or \"how many physical addresses are there in total?\"."
msgstr "Adesso rispondiamo alla domanda che ci aveva portato a questa sezione: quante celle di memoria ci sono sul Game Boy?\n"
"Ora possiamo riformulare meglio questa domanda come \"quanti indirizzi logici ci sono?\" o \"quanti indirizzi fisici ci sono in totale?\"."

#: src/part1/memory.md:59
msgid "Logical addresses, which again are just numbers, are 16-bit on the Game Boy.\n"
"Therefore, there are 2^16 = 65536 logical addresses, from $0000 to $FFFF.\n"
"How many physical addresses, though?\n"
"Well, here is a memory map [courtesy of Pan Docs](https://gbdev.io/pandocs/Memory_Map.html) (though I will simplify it a bit):"
msgstr "Gli indirizzi logici, che sono solo numeri, sono a 16 bit sul Game Boy.\n"
"Pertanto, ci sono 2^16 = 65536 indirizzi logici, da $0000 a $FFFF.\n"
"Ma quanti sono gli indirizzi fisici?\n"
"Ecco una mappa della memoria [per gentile concessione di Pan Docs](https://gbdev.io/pandocs/Memory_Map.html) (anche se la semplificher√≤ un po'):"

#: src/part1/memory.md:64
msgid "Start | End   | Name | Description\n"
"------|-------|------|-------------------------------------------------------------------------\n"
"$0000 | $7FFF | ROM  | The game ROM, supplied by the cartridge.\n"
"$8000 | $9FFF | VRAM | Video RAM, where graphics are stored and arranged.\n"
"$A000 | $BFFF | SRAM | Save RAM, optionally supplied by the cartridge to save data to.\n"
"$C000 | $DFFF | WRAM | Work RAM, general-purpose RAM for the game to store things in.\n"
"$FE00 | $FE9F | OAM  | Object Attribute Memory, where \"objects\" are stored.\n"
"$FF00 | $FF7F | I/O  | Neither ROM nor RAM, but this is where you control the console.\n"
"$FF80 | $FFFE | HRAM | High RAM, a tiny bit of general-purpose RAM which can be accessed faster.\n"
"$FFFF | $FFFF | IE | A lone I/O byte that's separated from the rest for some reason."
msgstr "Inizio | Fine | Nome | Descrizione\n"
"------|-------|------|-------------------------------------------------------------------------\n"
"$0000 | $7FFF | ROM | La ROM del gioco, fornita dalla cartuccia.\n"
"$8000 | $9FFF | VRAM | RAM video, dove viene memorizzata e organizzata la grafica.\n"
"$A000 | $BFFF | SRAM | RAM di salvataggio, fornita opzionalmente da certe cartucce per salvare i dati.\n"
"$C000 | $DFFF | WRAM | RAM di lavoro, RAM a uso generico in cui il gioco pu√≤ memorizzare i dati.\n"
"$FE00 | $FE9F | OAM | Object Attribute Memory, dove vengono memorizzati gli \"oggetti\".\n"
"$FF00 | $FF7F | I/O | N√© ROM n√© RAM, ma √® qui che si controlla la console.\n"
"$FF80 | $FFFE | HRAM | High RAM, una piccola porzione di RAM generica a cui si accede pi√π velocemente.\n"
"$FFFF | $FFFF | IE | Un solo byte di I/O separato dal resto per qualche motivo."

#: src/part1/memory.md:75
msgid "$8000 + $2000 + $2000 + $2000 + $A0 + $80 + $7F + 1 adds up to $E1A0, or 57760 bytes of memory that can be *actually* accessed.\n"
"The curious reader will naturally ask, \"What about the remaining 7776 bytes? What happens when accessing them?\"; the answer is: \"It depends, it's complicated; avoid accessing them\"."
msgstr "$8000 + $2000 + $2000 + $2000 + $A0 + $80 + $7F + 1 fanno in totale $E1A0, ovvero 57760 byte di memoria che si possono *effettivamente* usare.\n"
"E a questo punto potreste chiedervi: \"E i restanti 7776 byte? Cosa succede quando provo ad usarli?\"; la risposta √®: \"Dipende, √® complicato; evitate di accedervi\"."

#: src/part1/memory.md:78
msgid "## Labels"
msgstr "## Etichette"

#: src/part1/memory.md:80
msgid "Okay, memory addresses are nice, but you can't possibly expect me to keep track of all these addresses manually, right??\n"
"Well, fear not, for we have labels!"
msgstr "Ok, tutto questo √® molto bello, ma non vi aspetterete certo che io tenga in mente tutti questi indirizzi per conto mio, giusto??\n"
"Beh, non temere, perch√© abbiamo le etichette!"

#: src/part1/memory.md:83
msgid "Labels are [symbols](https://rgbds.gbdev.io/docs/v0.5.1/rgbasm.5#SYMBOLS) which basically allow attaching a name to a byte of memory.\n"
"A label is declared like at line 9 (`EntryPoint:`): at the beginning of the line, write the label's name, followed by a colon, and it will refer to the byte right after itself.\n"
"So, for example, `EntryPoint` refers to the `ld a, 0` right below it (more accurately, the first byte of that instruction, but we will get there when we get there)."
msgstr "Le etichette sono [simboli](https://rgbds.gbdev.io/docs/v0.5.1/rgbasm.5#SYMBOLS) che in pratica permettono di assegnare un nome a un indirizzo di memoria.\n"
"Un'etichetta viene dichiarata come alla riga 9 (`EntryPoint:`): all'inizio della riga si scrive il nome dell'etichetta, seguito da due punti, ed essa si riferir√† al byte immediatamente successivo.\n"
"Quindi, per esempio, `EntryPoint` si riferisce al `ld a, 0` subito dopo (pi√π precisamente, al primo byte di quell'istruzione, ma ci arriveremo quando ci arriveremo)."

#: src/part1/memory.md:89
msgid "If you peek inside `hardware.inc`, you will see that for example `rNR52` is not defined as a label.\n"
"That's because they are *constants*, which we will touch on later; since they can be used mostly like labels, we will conflate the two for now."
msgstr "Sbirciando all'interno di `hardware.inc` si vedr√† che, per esempio, `rNR52` non √® definito come un'etichetta.\n"
"Il motivo √® che queste sono *costanti*, di cui parleremo pi√π in l√†; visto che si usano in modo quasi identico alle etichette, per il momento le considereremo uguali."

#: src/part1/memory.md:94
msgid "Writing out a label's name is equivalent to writing the address of the byte it's referencing (with a few exceptions we will see in Part ‚Ö°).\n"
"For example, consider the `ld de, Tiles` at line 25.\n"
"`Tiles` (line 64) is referring to the first byte of the tile data; if we assume that the tile data ends up being stored starting at $0193, then `ld de, Tiles` is equivalent to `ld de, $0193`!"
msgstr "Scrivere il nome di un'etichetta equivale a scrivere l'indirizzo del byte a cui fa riferimento (con alcune eccezioni che vedremo nella Parte ‚Ö°).\n"
"Per esempio, si consideri la `ld de, Tiles` alla riga 25.\n"
"`Tiles` (riga 64) si riferisce al primo byte dei dati delle mattonelle; se assumiamo che i dati delle mattonelle finiscono per essere memorizzati a partire da $0193, allora `ld de, Tiles` √® equivalente a `ld de, $0193`!"

#: src/part1/memory.md:98
msgid "## What's with the brackets?"
msgstr "## Cosa sono queste parentesi?"

#: src/part1/memory.md:100
msgid "Right, we came into this because we wanted to know what the brackets in `ld a, [de]` mean.\n"
"Well, they can basically be read as \"at address...\".\n"
"For example, `ld a, b` can be read as \"copy into `a` the value stored in `b`\"; `ld a, [$5414]` would be read as \"copy into `a` the value stored at address $5414\", and `ld a, [de]` would be read as \"copy into `a` the value stored at address `de`\".\n"
"Wait, what does that mean?\n"
"Well, if `de` contains the value $5414, then `ld a, [de]` will do the same thing as `ld a, [$5414]`."
msgstr "Bene, siamo arrivati a questo punto perch√© volevamo sapere cosa significano le parentesi in `ld a, [de]`.\n"
"In pratica, possono essere lette come \"all'indirizzo...\".\n"
"Per esempio, `ld a, b` pu√≤ essere letto come \"copia in `a` il valore memorizzato in `b`\"; `ld a, [$5414]` si legge come \"copia in `a` il valore memorizzato all'indirizzo $5414\", e `ld a, [de]` si legge come \"copia in `a` il valore memorizzato all'indirizzo `de`\".\n"
"Aspettate, cosa significa?\n"
"Beh, se `de` contiene il valore $5414, allora `ld a, [de]` far√† la stessa cosa di `ld a, [$5414]`."

#: src/part1/memory.md:108
msgid "If you're familiar with C, these brackets are basically how the dereference operator is implemented."
msgstr "Se avete familiarit√† con il C, queste parentesi sono sostanzialmente il modo in cui viene implementato l'operatore di dereferenziazione."

#: src/part1/memory.md:112
msgid "### `hli`"
msgstr "### `hli`"

#: src/part1/memory.md:114
msgid "An astute reader will have noticed the `ld [hli], a` just below the `ld a, [de]` we have just studied.\n"
"`[de]` makes sense because it's one of the register pairs we saw a couple lessons ago, but `[hli]`?\n"
"It's actually a special notation, which can also be written as `[hl+]`.\n"
"It functions as `[hl]`, but `hl` is *incremented* just after memory is accessed.\n"
"`[hld]`/`[hl-]` is the mirror of this one, *decrementing* `hl` instead of incrementing it."
msgstr "I lettori attenti avranno notato il `ld [hli], a` appena sotto il `ld a, [de]` che abbiamo appena studiato.\n"
"`[de]` ha senso perch√© √® una delle coppie di registri che abbiamo visto un paio di lezioni fa, ma `[hli]`?\n"
"In realt√†, √® una notazione speciale, che pu√≤ essere scritta anche come `[hl+]`.\n"
"Funziona come `[hl]`, ma `hl` viene *incrementato* subito dopo l'accesso alla memoria.\n"
"`[hld]`/`[hl-]` √® lo specchio di questa, *decrementando* `hl` invece di incrementarlo."

#: src/part1/memory.md:120
msgid "## An example"
msgstr "## Un esempio"

#: src/part1/memory.md:122
msgid "So, if we look at the first two instructions of `CopyTiles`:"
msgstr "Quindi, se osserviamo le prime due istruzioni di `CopyTiles`:"

#: src/part1/memory.md:124
msgid "```rgbasm,linenos,start=29\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"```"
msgstr "```rgbasm,linenos,start=29\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"```"

#: src/part1/memory.md:129
msgid "...we can see that we're copying the byte in memory *pointed to* by `de` (that is, whose address is contained in `de`) into the byte pointed to by `hl`.\n"
"Here, `a` serves as temporary storage, since the CPU is unable to perform `ld [hl], [de]` directly."
msgstr "...possiamo vedere che stiamo copiando il byte in memoria *puntato* da `de` (cio√® il cui indirizzo √® contenuto in `de`) nel byte puntato da `hl`.\n"
"Qui, `a` serve come memoria temporanea, poich√© la CPU non √® in grado di eseguire direttamente `ld [hl], [de]`."

#: src/part1/memory.md:132
msgid "While we're at this, let's examine the rest of `.copyTiles` in the following lessons!"
msgstr "Gi√† che ci siamo, esaminiamo il resto di `.copyTiles` nelle lezioni successive!"

#: src/part1/memory.md:136
msgid "[^memory_magnetic]:\n"
"Actually, this depends a lot on the type of memory.\n"
"A lot of memory nowadays uses magnetic storage, but to keep the explanation simple, and to parallel the explanation of binary given earlier, let's assume that current is being used."
msgstr "[^memory_magnetic]:\n"
"In realt√†, questo dipende molto dal tipo di memoria.\n"
"Molte memorie oggi utilizzano un'archiviazione magnetica, ma per mantenere il discordo pi√π semplice e per fare un parallelo con la spiegazione del binario data in precedenza, supponiamo che venga utilizzata un'archiviazione a corrente elettrica."

#: src/part1/memory.md:140
msgid "[^rom_ram_and]:\n"
"There are other types of memory, such as flash memory or EEPROM, but only Flash has been used on the Game Boy, and for only a handful of games; so we can mostly forget about them."
msgstr "[^rom_ram_e]:\n"
"Esistono altri tipi di memoria, come la memoria flash o l'EEPROM, ma solo la flash √® stata utilizzata sul Game Boy, e solo per una manciata di giochi; quindi possiamo dimenticarci di loro."

#: src/part1/memory.md:143
msgid "[^rom_ro]:\n"
"No, really!\n"
"Mask ROM is created by literally punching holes into a layer of silicon using acid, and e.g. the console's boot ROM is made of hard-wired transitors within the CPU die.\n"
"Good luck writing to that!\n"
"<br>\n"
"\"ROM\" is sometimes (mis)used to refer to \"persistent memory\" chips, such as flash memory, whose write functionality was disabled.\n"
"Most bootleg / \"repro\" Game Boy cartridges you can find nowadays actually contain flash; this is why you can reflash them using specialized hardware, but original cartridges cannot be."
msgstr "[^rom_ro]:\n"
"No, davvero!\n"
"La ROM a maschera viene creata letteralmente bucando uno strato di silicio con l'acido e, ad esempio, la ROM di avvio della console √® fatta di transistor cablati all'interno del die della CPU.\n"
"Buona fortuna a scriverci!\n"
"<br>\n"
"Il termine \"ROM\" viene a volte (erroneamente) utilizzato per indicare i chip di \"memoria persistente\", come la memoria flash, la cui funzionalit√† di scrittura √® stata disabilitata.\n"
"La maggior parte delle cartucce Game Boy bootleg / \"repro\" che si possono trovare al giorno d'oggi contengono effettivamente la memoria flash; questo √® il motivo per cui √® possibile riflasharle utilizzando hardware specializzato, mentre non √® possibile farlo con le cartucce originali."

#: src/part1/header.md:1
msgid "# Header"
msgstr "# Header"

#: src/part1/header.md:3
msgid "Let's go back to a certain line near the top of `hello-world.asm`."
msgstr "Torniamo a una certa riga all'inizio di `hello-world.asm`."

#: src/part1/header.md:5
#: src/part1/header.md:76
msgid "```rgbasm,linenos,start=7\n"
"\tds $150 - @, 0 ; Make room for the header\n"
"```"
msgstr "```rgbasm,linenos,start=7\n"
"\tds $150 - @, 0 ; Facciamo spazio per l'header\n"
"```"

#: src/part1/header.md:9
msgid "What is this mysterious header, why are we making room for it, and more questions answered in this lesson!"
msgstr "Che cos'√® questo misterioso header, detto anche intestazione? Perch√© dobbiamo allocargli uno spazio specifico? Queste e tante altre domande troveranno una risposta in questa lezione!"

#: src/part1/header.md:11
msgid "## What is the header?"
msgstr "## Cos'√® l'header?"

#: src/part1/header.md:13
msgid "First order of business is explaining what the header *is*.\n"
"It's the region of memory from $0104 to $014F (inclusive).\n"
"It contains metadata about the ROM, such as its title, Game Boy Color compatibility, size,\n"
"two checksums, and interestingly, the Nintendo logo that is displayed during the power-on animation."
msgstr "La prima cosa da fare √® spiegare *cosa √®* l'header.\n"
"√à la regione di memoria da $0104 a $014F (inclusa).\n"
"Contiene metadati sulla ROM, come il titolo, la compatibilit√† con il Game Boy Color, le dimensioni,\n"
"due checksum e, cosa interessante, il logo Nintendo che viene visualizzato durante l'animazione di accensione."

#: src/part1/header.md:20
msgid "You can find this information and more [in the Pan Docs](https://gbdev.io/pandocs/The_Cartridge_Header)."
msgstr "Queste e altre informazioni sono disponibili [nei documenti Pan](https://gbdev.io/pandocs/The_Cartridge_Header)."

#: src/part1/header.md:24
msgid "Interestingly, most of the information in the header does not matter on real hardware (the ROM's size is determined only by the capacity of the ROM chip in the cartridge, not the header byte).\n"
"In fact, some prototype ROMs actually have incorrect header info!"
msgstr "√à interessante notare che la maggior parte delle informazioni contenute nell'header non ha importanza in un hardware reale (la dimensione della ROM √® determinata solo dalla capacit√† del chip ROM nella cartuccia, non dal byte nella intestazione).\n"
"Difatti, alcuni prototipi di ROM hanno addirittura informazioni errate nell'header!"

#: src/part1/header.md:27
msgid "Most of the header was only used by Nintendo's manufacturing department to know what components to put in the cartridge when publishing a ROM.\n"
"Thus, only ROMs sent to Nintendo had to have a fully correct header; ROMs used for internal testing only needed to pass the boot ROM's checks, explained further below."
msgstr "La maggior parte dell'header veniva utilizzata solo dal reparto di produzione di Nintendo per sapere quali componenti inserire nella cartuccia quando si pubblicava una ROM.\n"
"Pertanto, solo le ROM inviate a Nintendo dovevano avere una intestazione perfettamente accurata; le ROM utilizzate per i test interni dovevano solo superare i controlli della ROM di avvio, che spiegheremo pi√π avanti."

#: src/part1/header.md:30
msgid "However, in our \"modern\" day and age, the header actually matters a lot.\n"
"Emulators (including hardware emulators such as flashcarts) must emulate the hardware present in the cartridge.\n"
"The header being the only source of information about what hardware the ROM's cartridge should contain, they rely on some of the values in the header."
msgstr "Tuttavia, nella nostra epoca \"moderna\", l'header √® molto importante.\n"
"Gli emulatori (compresi gli emulatori hardware, come le flashcard) devono emulare l'hardware presente nella cartuccia e fanno affidamento su alcuni dei valori presenti nell'header, dato che questa sezione √® l'unica fonte di informazioni sull'hardware che la cartuccia della ROM dovrebbe contenere."

#: src/part1/header.md:34
msgid "## Boot ROM"
msgstr "## ROM di avvio"

#: src/part1/header.md:36
msgid "The header is intimately tied to what is called the **boot ROM**."
msgstr "L'intestazione √® profondamente collegata alla cosiddetta **boot ROM** (ROM di \"avvio\")."

#: src/part1/header.md:38
msgid "The most observant and/or nostalgic of you may have noticed the lack of the boot-up animation and the Game Boy's signature \"ba-ding!\" in Emulicious.\n"
"When the console powers up, the CPU does not begin executing instructions at address $0100 (where our ROM's entry point is), but at $0000."
msgstr ""

#: src/part1/header.md:41
msgid "However, at that time, a small program called the *boot ROM*, burned within the CPU's silicon, is \"overlaid\" on top of our ROM!\n"
"The boot ROM is responsible for the startup animation, but it also checks the ROM's header!\n"
"Specifically, it verifies that the Nintendo logo and header checksums are correct; if either check fails, the boot ROM intentionally *locks up*, and our game never gets to run :("
msgstr "Tuttavia, in quel momento, un piccolo programma chiamato *boot ROM*, masterizzato all'interno del silicio della CPU, viene \"sovrapposto\" alla nostra ROM!\n"
"La ROM di avvio √® responsabile dell'animazione di avvio, ma controlla anche l'intestazione della ROM!\n"
"In particolare, verifica che i checksum del logo Nintendo e della intestazione siano corretti; se uno dei due controlli fallisce, la ROM di avvio si *blocca* intenzionalmente e il nostro gioco non verr√† mai eseguito :("

#: src/part1/header.md:45
msgid "::: tip For the curious"
msgstr "::: tip Per i curiosi"

#: src/part1/header.md:47
msgid "You can find a more detailed description of what the boot ROM does [in the Pan Docs](https://gbdev.io/pandocs/Power_Up_Sequence), as well as an explanation of the logo check.\n"
"Beware that it is quite advanced, though."
msgstr "√à possibile trovare una descrizione pi√π dettagliata di ci√≤ che fa la ROM di avvio [nei Pan Docs](https://gbdev.io/pandocs/Power_Up_Sequence), nonch√© una spiegazione del controllo del logo.\n"
"Attenzione, per√≤, perch√© si tratta di un argomento piuttosto avanzato."

#: src/part1/header.md:50
msgid "If you want to enable the boot ROMs in Emulicious, you must obtain a copy of the boot ROM(s), whose SHA256 checksums can be found [in their disassembly](https://github.com/ISSOtm/gb-bootroms/blob/master/sha256sums.txt) for verification.\n"
"If you wish, you can also compile [SameBoy's boot ROMs](https://github.com/LIJI32/SameBoy#compilation) and use those instead, as a free-software substitute."
msgstr ""

#: src/part1/header.md:53
msgid "Then, in Emulicious' options, go to the `Options` tab, then `Emulation`‚Üí`Game Boy`, and choose which of GB and/or GBC boot roms you want to set.\n"
"Finally, set the path(s) to the boot ROM(s) you wish to use, and click `Open`.\n"
"Now, just reset the emulator, and voil√†!"
msgstr ""

#: src/part1/header.md:59
msgid "A header is typically called \"valid\" if it would pass the boot ROM's checks, and \"invalid\" otherwise."
msgstr "Un header viene tipicamente definito \"valido\" se supera i controlli della ROM di avvio e \"non valido\" in caso contrario."

#: src/part1/header.md:63
msgid "RGBFIX is the third component of RGBDS, whose purpose is to write a ROM's header.\n"
"It is separate from RGBLINK so that it can be used as a stand-alone tool.\n"
"Its name comes from that RGBLINK typically does not produce a ROM with a valid header, so the ROM must be \"fixed\" before it's production-ready."
msgstr "RGBFIX √® il terzo componente di RGBDS, il cui scopo √® scrivere l'header di una ROM.\n"
"√à separato da RGBLINK in modo da poter essere usato come strumento indipendente.\n"
"Il suo nome deriva dal fatto che RGBLINK di solito non produce una ROM con un header valido, quindi la ROM deve essere \"aggiustata\" prima di essere pronta per la produzione."

#: src/part1/header.md:67
msgid "RGBFIX has [a bunch of options](https://rgbds.gbdev.io/docs/rgbfix.1) to set various parts of the header; but the only two that we are using here are `-v`, which produces a **v**alid header (so, correct [Nintendo logo](https://gbdev.io/pandocs/The_Cartridge_Header.html#0104-0133---nintendo-logo) and [checksums](https://gbdev.io/pandocs/The_Cartridge_Header.html#014d---header-checksum)), and <code>-p&nbsp;0xFF</code>, which **p**ads the ROM to the next valid size (using $FF as the filler byte), and writes the appropriate value to the [ROM size byte](https://gbdev.io/pandocs/The_Cartridge_Header.html#0148---rom-size)."
msgstr "RGBFIX ha [molte opzioni](https://rgbds.gbdev.io/docs/rgbfix.1) per impostare varie parti dell'header; ma le uniche due che usiamo qui sono `-v`, che produce un header **v**alido (quindi, [logo Nintendo](https://gbdev.io/pandocs/The_Cartridge_Header.html#0104-0133---nintendo-logo) e [checksum](https://gbdev.io/pandocs/The_Cartridge_Header.html#014d---header-checksum) corretti) e <code>-p&nbsp;0xFF</code>, che **p**osiziona la ROM alla prossima dimensione valida (usando $FF come byte di riempimento) e scrive il valore appropriato nel [byte di dimensione della ROM](https://gbdev.io/pandocs/The_Cartridge_Header.html#0148---rom-size)."

#: src/part1/header.md:69
msgid "If you look at other projects, you may find RGBFIX invocations with more options, but these two should almost always be present."
msgstr "Guardando altri progetti, si possono trovare invocazioni di RGBFIX con pi√π opzioni, ma queste due dovrebbero essere quasi sempre presenti."

#: src/part1/header.md:71
msgid "## So, what's the deal with that line?"
msgstr "## Allora, qual √® il problema con questa linea?"

#: src/part1/header.md:73
msgid "Right!\n"
"This line."
msgstr "Si!\n"
"Questa linea."

#: src/part1/header.md:80
msgid "Well, let's see what happens if we remove it (or comment it out)."
msgstr "Vediamo cosa succede se la rimuoviamo (o la commentiamo)."

#: src/part1/header.md:82
msgid "```console\n"
"$ rgbasm -L -o hello-world.o hello-world.asm\n"
"$ rgblink -o hello-world.gb -n hello-world.sym hello-world.o\n"
"```"
msgstr "```console\n"
"$ rgbasm -L -o hello-world.o hello-world.asm\n"
"$ rgblink -o hello-world.gb -n hello-world.sym hello-world.o\n"
"```"

#: src/part1/header.md:87
msgid "(I am intentionally not running RGBFIX; we will see why in a minute.)"
msgstr "(Sto intenzionalmente NON eseguendo RGBFIX; vedremo perch√© tra poco)."

#: src/part1/header.md:89
msgid "![\"This rom would not work on a real gameboy.\"](../assets/img/bad_warnings.png)"
msgstr "![\"Questa rom non funzionerebbe su un vero gameboy.\"](../assets/img/bad_warnings.png)"

#: src/part1/header.md:91
msgid "As I explained, RGBFIX is responsible for writing the header, so we should use it to fix this exception."
msgstr "Come ho spiegato, RGBFIX √® responsabile della scrittura dell'intestazione, quindi dovremmo usarlo per risolvere questa eccezione."

#: src/part1/header.md:93
msgid "```console\n"
"$ rgbfix -v -p 0xFF hello-world.gb\n"
"warning: Overwrote a non-zero byte in the Nintendo logo\n"
"warning: Overwrote a non-zero byte in the header checksum\n"
"warning: Overwrote a non-zero byte in the global checksum\n"
"```"
msgstr ""

#: src/part1/header.md:100
msgid "*I'm sure these warnings are nothing to be worried about...*\n"
"(Depending on your version of RGBDS, you may have gotten different warnings, or none at all.)"
msgstr "*Sono sicuro che questi avvisi non sono nulla di cui preoccuparsi...*\n"
"(A seconda della versione di RGBDS in uso, √® possibile che siano stati visualizzati avvisi diversi, o addirittura nessuno)."

#: src/part1/header.md:103
msgid "Let's run the ROM, click on Console on the debugger's bottom window, press <kbd><kbd>F5</kbd></kbd> a few times, and..."
msgstr ""

#: src/part1/header.md:105
msgid "<figure>\n"
"  <img src=\"../assets/img/invalid_opcode.png\" alt=\"Screenshot of Emulicious' debugger, PC won't advance past $0105\">\n"
"  <figcaption>\n"
"    When the console reads \"Executing illegal instruction\", you <i>might</i> have screwed up somewhere.\n"
"  </figcaption>\n"
"</figure>"
msgstr ""

#: src/part1/header.md:112
msgid "![\"This is fine\" meme strip](../assets/img/fine.png)"
msgstr "![\"This is fine\" meme](../assets/img/fine.png)"

#: src/part1/header.md:114
msgid "Okay, so, what happened?"
msgstr "Ok, allora, cos'√® successo?"

#: src/part1/header.md:116
msgid "As we can see from the screenshot, PC is at $0105.\n"
"What is it doing there?"
msgstr "Come si pu√≤ vedere dallo screenshot, PC si trova a $0105.\n"
"Cosa sta facendo l√¨?"

#: src/part1/header.md:119
msgid "...Oh, `EntryPoint` is at $0103.\n"
"So the `jp` at $0100 went there, and started executing instructions (`3E CE` is the raw form of `ld a, $CE`), but then $ED does not encode any valid instruction, so the CPU locks up."
msgstr "...Oh, `EntryPoint` √® a $0103.\n"
"Quindi il `jp` a $0100 √® andato l√¨ e ha iniziato a eseguire le istruzioni (`3E CE` √® la forma grezza di `ld a, $CE`), ma poi $ED non codifica alcuna istruzione valida, quindi la CPU si blocca."

#: src/part1/header.md:122
msgid "But why is `EntryPoint` there?\n"
"Well, as you may have figured out from the warnings RGBFIX printed, it *overwrites* the header area in the ROM.\n"
"However, RGBLINK is **not** aware of the header (because RGBLINK is not only used to generate ROMs!), so you must explicitly reserve space for the header area."
msgstr "Ma perch√© `EntryPoint` √® l√¨?\n"
"Come avrete capito dagli avvisi stampati da RGBFIX, esso *sovrascrive* l'area dell'header nella ROM.\n"
"Tuttavia, RGBLINK **non** √® a conoscenza dell'header (perch√© RGBLINK non √® usato solo per generare ROM!), quindi √® necessario riservare esplicitamente spazio per l'area dell'header."

#: src/part1/header.md:126
msgid "::: danger:ü•¥"
msgstr ""

#: src/part1/header.md:128
msgid "Forgetting to reserve this space, and having a piece of code or data ending up there then overwritten, is a common beginner mistake that can be quite puzzling.\n"
"Fortunately, RGBFIX since version 0.5.1 warns when it detects this mistake, as shown above."
msgstr "Dimenticare di riservare questo spazio pu√≤ far s√¨ che un pezzo di codice o di dati finisca l√¨ e poi venga sovrascritto. Questo √® un errore comune di chi √® alle prime armi che pu√≤ lasciare perplessi.\n"
"Fortunatamente, dalla versione 0.5.1 RGBFIX avverte quando rileva questo errore, come mostrato sopra."

#: src/part1/header.md:133
msgid "So, we prevent disaster like this:"
msgstr "Cos√¨, preveniamo disastri come questo:"

#: src/part1/header.md:135
#: src/part2/getting-started.md:35
msgid "```rgbasm,linenos,start=3\n"
"SECTION \"Header\", ROM0[$100]"
msgstr "```rgbasm,linenos,start=3\n"
"SECTION \"Header\", ROM0[$100]"

#: src/part1/header.md:143
msgid "The directive `ds` stands for \"define space\", and allows filling a range of memory.\n"
"This specific line fills all bytes from $103 to $14F (inclusive) with the value $00.\n"
"Since different pieces of code and/or data cannot overlap, this ensures that the header's memory range can safely be overwritten by RGBFIX, and that nothing else accidentally gets steamrolled instead."
msgstr "La direttiva `ds` sta per \"define space\" e consente di riempire un intervallo di memoria.\n"
"Questa riga specifica riempie tutti i byte da $103 a $14F (inclusi) con il valore $00.\n"
"Poich√© parti diverse di codice e/o di dati non possono sovrapporsi, questo assicura che l'intervallo di memoria dell'header possa essere sovrascritto in modo sicuro da RGBFIX e che nessun altro venga accidentalmente sovrascritto."

#: src/part1/header.md:147
msgid "It may not be obvious how this `ds` ends up filling that specific memory range.\n"
"The 3-byte `jp` covers memory addresses $100, $101, and $102.\n"
"(We start at $100 because that's where the `SECTION` is hardcoded to be.)\n"
"When RGBASM processes the `ds` directive, `@` (which is a special symbol that evaluates to \"the current address\") thus has the value $103, so it fills `$150 - $103 = $4D` bytes with zeros, so $103, $104, ..., $14E, $14F."
msgstr "Potrebbe non essere ovvio come questo `ds` finisca per riempire quello specifico intervallo di memoria.\n"
"Il `jp` a 3 byte copre gli indirizzi di memoria $100, $101 e $102.  \n"
"(Iniziamo da $100 perch√© √® dove si trova la `SECTION` definita manualmente).  \n"
"Quando RGBASM elabora la direttiva `ds`, `@` (che √® un simbolo speciale che valuta \"l'indirizzo corrente\") ha quindi il valore $103, quindi riempie `$150 - $103 = $4D` byte con zeri, quindi $103, $104, ..., $14E, $14F."

#: src/part1/header.md:152
msgid "## Bonus: the infinite loop"
msgstr "## Bonus: il ciclo infinito"

#: src/part1/header.md:154
msgid "(This is not really linked to the header, but I need to explain it somewhere, and here is as good a place as any.)"
msgstr "(Questo non √® propriamente collegato all'header, ma devo spiegarlo da qualche parte e questo √® un posto come un altro)"

#: src/part1/header.md:156
msgid "You may also be wondering what the point of the infinite loop at the end of the code is for."
msgstr "Ci si potrebbe anche chiedere a cosa serva il ciclo infinito alla fine del codice."

#: src/part1/header.md:158
msgid "```rgbasm\n"
"Done:\n"
"\tjp Done\n"
"```"
msgstr "```rgbasm\n"
"Fatto:\n"
"\tjp Fatto\n"
"```"

#: src/part1/header.md:163
msgid "Well, simply enough, the CPU never stops executing instructions; so when our little Hello World is done and there is nothing left to do, we must still give the CPU some busy-work: so we make it do nothing, forever."
msgstr "Semplicemente, la CPU non smette mai di eseguire istruzioni; quindi, quando il nostro piccolo Hello World √® finito e non c'√® pi√π nulla da fare, dobbiamo comunque dare alla CPU un po' di lavoro: quindi, le facciamo fare nulla, per sempre."

#: src/part1/header.md:165
msgid "We cannot let the CPU just run off, as it would then start executing other parts of memory as code, possibly crashing.\n"
"(See for yourself: remove or comment out these two lines, re-[compile the ROM](hello_world.md), and see what happens!)"
msgstr "Non possiamo lasciare che la CPU se ne vada, perch√© inizierebbe a eseguire altre parti della memoria come codice, con il rischio di bloccarsi.\n"
"(Per verificare: rimuovete o commentate queste due righe, compilate nuovamente la [ROM](hello_world.md) e vedete cosa succede)"

#: src/part1/operations.md:1
msgid "# Operations & flags"
msgstr "# Operazioni e flag"

#: src/part1/operations.md:3
msgid "Alright, we know how to pass values around, but just copying numbers is no fun; we want to modify them!"
msgstr "Va bene, sappiamo come passare i valori, ma copiare semplicemente i numeri non √® divertente; vogliamo modificarli!"

#: src/part1/operations.md:5
msgid "The GB CPU does not provide every operation under the sun (for example, there is no multiplication instruction), but we can just program those ourselves with what we have.\n"
"Let's talk about some of the operations that it *does* have; I will be omitting some not used in the Hello World for now."
msgstr "La CPU GB non fornisce tutte le operazioni sotto il sole (per esempio, non esiste un'istruzione di moltiplicazione), ma possiamo programmarle da soli con ci√≤ che abbiamo.\n"
"Parliamo di alcune delle operazioni di cui dispone; per ora ne ometter√≤ alcune non utilizzate in Hello World."

#: src/part1/operations.md:8
msgid "## Arithmetic"
msgstr "## Aritmetica"

#: src/part1/operations.md:10
msgid "The simplest arithmetic instructions the CPU supports are `inc` and `dec`, which INCrement and DECrement their operand, respectively.\n"
"(If you aren't sure, \"to increment\" means \"to add 1\", and \"to decrement\" means \"to subtract 1\".)\n"
"So for example, the `dec bc` at line 32 of `hello-world.asm` simply subtracts 1 from `bc`."
msgstr "Le istruzioni aritmetiche pi√π semplici supportate dalla CPU sono `inc` e `dec`, che rispettivamente INCrementano e DECrementano il loro operando.\n"
"(Se non siete sicuri, \"incrementare\" significa \"aggiungere 1\" e \"decrementare\" significa \"sottrarre 1\").\n"
"Quindi, per esempio, il `dec bc` alla riga 32 di `hello-world.asm` sottrae semplicemente 1 da `bc`."

#: src/part1/operations.md:14
msgid "Okay, cool!\n"
"Can we go a bit faster, though?\n"
"Sure we can, with `add` and `sub`!\n"
"These respectively ADD and SUBtract arbitrary values (either a constant, or a register).\n"
"Neither is used in the tutorial, but a sibling of `sub`'s is: have you noticed little `cp` over at line 17?\n"
"`cp` allows ComParing values.\n"
"It works the same as `sub`, but it discards the result instead of writing it back.\n"
"\"Wait, so it does nothing?\" you may ask; well, it *does* update the **flags**."
msgstr "Ok, bene!\n"
"Possiamo per√≤ andare un po' pi√π veloci?\n"
"Certo che s√¨, con `add` e `sub`!\n"
"Questi rispettivamente aggiungono e sottraggono valori arbitrari (una costante o un registro).\n"
"Nessuno dei due viene usato nel tutorial, ma c'√® un parente di `sub`: avete notato il piccolo `cp` alla riga 17?\n"
"`cp` permette di confrontare i valori.\n"
"Funziona come `sub`, ma scarta il risultato invece di riscriverlo.\n"
"\"Aspettate, quindi non fa nulla?\", vi chiederete; beh, aggiorna le **flag**."

#: src/part1/operations.md:23
msgid "## Flags"
msgstr "## Flag"

#: src/part1/operations.md:25
msgid "The time has come to talk about the special-purpose register (remember those?) `f`, for, well, *flags*.\n"
"The `f` register contains 4 bits, called \"flags\", which are updated depending on an operation's results.\n"
"These 4 flags are:"
msgstr "√à arrivato il momento di parlare del registro speciale (ve lo ricordate?) `f`, per, beh, *flag*.\n"
"Il registro `f` contiene 4 bit, chiamati \"flag\", che vengono aggiornati a seconda dei risultati di un'operazione.\n"
"Questi 4 flag sono:"

#: src/part1/operations.md:29
msgid "Name | Description\n"
"-----|---------------------\n"
"  Z  | Zero flag\n"
"  N  | Addition/subtraction\n"
"  H  | Half-carry\n"
"  C  | Carry"
msgstr "Nome | Descrizione\n"
"-----|---------------------\n"
"  Z | Flag di zero\n"
"  N | Addizione/sottrazione\n"
"  H | Half-carry\n"
"  C | Carry"

#: src/part1/operations.md:36
msgid "Yes, there is a flag called \"C\" and a register called \"c\", and **they are different, unrelated things**.\n"
"This makes the syntax a bit confusing at the beginning, but they are always used in different contexts, so it's fine."
msgstr "S√¨, esistono sia un flag chiamato \"C\" che un registro chiamato \"c\" e **sono cose diverse e non correlate**.\n"
"Questo rende la sintassi un po' confusa all'inizio, ma vengono sempre usati in contesti diversi, quindi basta farci caso."

#: src/part1/operations.md:39
msgid "We will forget about N and H for now; let's focus on Z and C.\n"
"Z is the simplest flag: it gets set when an operation's result is 0, and gets reset otherwise.\n"
"C is set when an operation *overflows* or *underflows*."
msgstr "Per ora dimentichiamo N e H; concentriamoci su Z e C.\n"
"Z √® il flag pi√π semplice: viene impostato quando il risultato di un'operazione √® 0 e viene azzerato altrimenti.\n"
"C viene impostato quando un'operazione va in *overflow* o in *underflow*."

#: src/part1/operations.md:43
msgid "What's an overflow?\n"
"Let's take the simple instruction `add a, 42`.\n"
"This simply adds 42 to the contents of register `a`, and writes the result back into `a`."
msgstr "Che cos'√® un overflow?\n"
"Prendiamo la semplice istruzione `add a, 42`.\n"
"Questa istruzione aggiunge semplicemente 42 al contenuto del registro `a` e scrive il risultato in `a`."

#: src/part1/operations.md:47
msgid "```rgbasm\n"
"    ld a, 200\n"
"    add a, 42\n"
"```"
msgstr "``rgbasm\n"
"    ld a, 200\n"
"    add a, 42\n"
"````"

#: src/part1/operations.md:52
msgid "At the end of this snippet, `a` equals 200 + 42 = 242, great!\n"
"But what if I write this instead?"
msgstr "Alla fine di questo snippet, `a` √® uguale a 200 + 42 = 242, fantastico!\n"
"Ma se invece scrivessi questo?"

#: src/part1/operations.md:55
msgid "```rgbasm\n"
"    ld a, 220\n"
"    add a, 42\n"
"```"
msgstr "``rgbasm\n"
"    ld a, 220\n"
"    add a, 42\n"
"````"

#: src/part1/operations.md:60
msgid "Well, one could think that `a` would be equal to 220 + 42 = 262, but that would be incorrect.\n"
"Remember, `a` is an 8-bit register, *it can only store eight bits of information*!\n"
"And if we were to write 262 in binary, we would get %100000110, which requires at least 9 bits...\n"
"So what happens?\n"
"Simply, that ninth bit is *lost*, and the value that we end up with is %00000110 = 6.\n"
"This is called an *overflow*: after **adding**, we get a value **smaller** than what we started with."
msgstr "Si potrebbe pensare che `a` sia uguale a 220 + 42 = 262, ma non sarebbe corretto.\n"
"Ricordate che `a` √® un registro a 8 bit, *pu√≤ memorizzare solo otto bit di informazione*!\n"
"E se dovessimo scrivere 262 in binario, otterremmo %100000110, che richiede almeno 9 bit...\n"
"Quindi cosa succede?\n"
"Semplicemente, il nono bit viene *perduto* e il valore che otteniamo √® %00000110 = 6. Questo si chiama *overflow*.\n"
"Questo si chiama *overflow*: dopo l'**aggiunta**, otteniamo un valore **pi√π piccolo** di quello con cui abbiamo iniziato."

#: src/part1/operations.md:67
msgid "We can also do the opposite with `sub`, and&mdash;for example&mdash;subtract 42 from 6; as we know, for all `X` and `Y`, `X + Y - Y = X`, and we just saw that 220 + 42 = 6 (this is called *modulo 256 arithmetic*, by the way); so, 6 - 42 = (220 + 42) - 42 = 220.\n"
"This is called an *underflow*: after **subtracting**, we get a value **greater** than what we started with."
msgstr "Possiamo anche fare l'opposto con `sub`, e &mdash;per esempio&mdash; sottrarre 42 da 6; come sappiamo, per tutti gli `X` e `Y`, `X + Y - Y = X`, e abbiamo appena visto che 220 + 42 = 6 (questo √® chiamato *modulo 256 aritmetico*, a proposito); quindi, 6 - 42 = (220 + 42) - 42 = 220.\n"
"Questo si chiama *underflow*: dopo la **sottrazione**, otteniamo un valore **superiore** a quello di partenza."

#: src/part1/operations.md:70
msgid "When an operation is performed, it sets the carry flag if an overflow or underflow occurred, and clears it otherwise.\n"
"(We will see later that not all operations update the carry flag, though.)"
msgstr "Quando viene eseguita un'operazione, imposta il flag di riporto se si √® verificato un overflow o un underflow, altrimenti lo azzera.\n"
"(Vedremo pi√π avanti che non tutte le operazioni aggiornano il flag di riporto)"

#: src/part1/operations.md:73
msgid "::: tip Summary"
msgstr "::: tip Riassunto"

#: src/part1/operations.md:75
msgid "- We can add and subtract numbers.\n"
"- The Z flag lets us know if the result was 0.\n"
"- However, registers can only store a limited range of integers.\n"
"- Going outside this range is called an **overflow** or **underflow**, for addition and subtraction respectively.\n"
"- The C flag lets us know if either occurred."
msgstr "- Possiamo sommare e sottrarre numeri.\n"
"- Il flag Z ci permette di sapere se il risultato √® 0.\n"
"- Tuttavia, i registri possono memorizzare solo un intervallo limitato di numeri interi.\n"
"- L'uscita da questo intervallo √® chiamata **overflow** o **underflow**, rispettivamente per l'addizione e la sottrazione.\n"
"- Il flag C ci permette di sapere se si √® verificato uno dei due casi."

#: src/part1/operations.md:83
msgid "## Comparison"
msgstr "## Confronto"

#: src/part1/operations.md:85
msgid "Now, let's talk more about how `cp` is used to compare numbers.\n"
"Here is a refresher: `cp` subtracts its operand from `a` and updates flags accordingly, but doesn't write the result back.\n"
"We can use flags to check properties about the values being compared, and we will see in the next lesson how to use the flags."
msgstr "Parliamo ora di come `cp` viene utilizzato per confrontare i numeri.\n"
"Ecco un ripasso: `cp` sottrae il suo operando da `a` e aggiorna i flag di conseguenza, ma non scrive il risultato.\n"
"Possiamo usare i flag per controllare le propriet√† dei valori confrontati e vedremo nella prossima lezione come usarli."

#: src/part1/operations.md:89
msgid "The simplest interaction is with the Z flag.\n"
"If it's set, we know that the subtraction yielded 0, i.e. `a - operand == 0`; therefore, `a == operand`!\n"
"If it's not set, well, then we know that `a != operand`."
msgstr "L'interazione pi√π semplice √® quella con il flag Z.\n"
"Se √® impostato, sappiamo che la sottrazione ha prodotto 0, cio√® `a - operando == 0`; quindi, `a == operando`!\n"
"Se non √® impostato, allora sappiamo che `a != operando`."

#: src/part1/operations.md:93
msgid "Okay, checking for equality is nice, but we may also want to perform *comparisons*.\n"
"Fret not, for the carry flag is here to do just that!\n"
"See, when performing a subtraction, the carry flag gets set when the result goes below 0‚Äîbut that's just a fancy way of saying \"becomes negative\"!"
msgstr "Ok, controllare l'uguaglianza √® bello, ma potremmo anche voler eseguire dei *confronti*.\n"
"Non preoccupatevi, perch√© il flag di riporto serve proprio a questo!\n"
"Quando si esegue una sottrazione, il flag di riporto viene impostato quando il risultato scende sotto lo 0, ma √® solo un modo elegante per dire \"diventa negativo\"!"

#: src/part1/operations.md:97
msgid "So, when the carry flag gets set, we know that `a - operand < 0`, therefore that `a < operand`..!\n"
"And, conversely, we know that if it's *not* set, `a >= operand`.\n"
"Great!"
msgstr "Quindi, quando il flag di riporto viene impostato, sappiamo che `a - operando < 0` e di conseguenza che `a < operando`...!\n"
"E, al contrario, sappiamo che se non √® impostato, `a >= operando`.\n"
"Ottimo!"

#: src/part1/operations.md:101
msgid "## Instruction summary"
msgstr "## Riassunto dell'istruzione"

#: src/part1/operations.md:103
msgid "Instruction | Mnemonic | Effect\n"
"------------|----------|---------------------------------------------\n"
"Add         | `add`    | Adds values to `a`\n"
"Subtract    | `sub`    | Subtracts values from `a`\n"
"Compare     | `cp`     | Compares values with what's contained in `a`"
msgstr "Istruzione | Mnemonico | Effetto\n"
"-----------------|----------|---------------------------------------------\n"
"Add           | `add`  | Aggiunge valori ad `a`\n"
"Subtract   | `sub`  | Sottrae valori da `a`\n"
"Compare  | `cp`    | Confronta valori con quelli contenuti in `a`"

#: src/part1/jumps.md:1
msgid "# Jumps"
msgstr "# Jumps"

#: src/part1/jumps.md:5
msgid "Once this lesson is done, we will be able to understand all of `CopyTiles`!"
msgstr "Una volta terminata questa lezione, saremo in grado di capire tutto di `CopyTiles`!"

#: src/part1/jumps.md:9
msgid "So far, all the code we have seen was linear: it executes top to bottom.\n"
"But this doesn't scale: sometimes, we need to perform certain actions depending on the result of others (\"if the cr√™pes start sticking, grease the pan again\"), and sometimes, we need to perform actions repeatedly (\"If there is some batter left, repeat from step 5\")."
msgstr "Finora tutto il codice che abbiamo visto era lineare: veniva eseguito dall'alto verso il basso.\n"
"Ma questo non √® sufficiente: a volte √® necessario eseguire alcune azioni in base al risultato di altre (\"se le cr√™pes iniziano ad attaccarsi, ungi di nuovo la padella\"), e a volte √® necessario eseguire azioni ripetutamente (\"se √® rimasta della pastella, ripeti dal passo 5\")."

#: src/part1/jumps.md:12
msgid "Both of these imply reading the recipe non-linearly.\n"
"In assembly, this is achieved using *jumps*."
msgstr "Entrambe le cose implicano una lettura non lineare della ricetta.\n"
"In assembly, questo si ottiene con i *salti*."

#: src/part1/jumps.md:15
msgid "The CPU has a special-purpose register called \"PC\", for Program Counter.\n"
"It contains the address of the instruction currently being executed[^pc_updates], like how you'd keep in mind the number of the recipe step you're currently doing.\n"
"PC increases automatically as the CPU reads instructions, so \"by default\" they are read sequentially; however, jump instructions allow writing a different value to PC, effectively *jumping* to another piece of the program.\n"
"Hence the name."
msgstr "La CPU dispone di un registro speciale chiamato \"PC\", che sta per Program Counter.\n"
"Esso contiene l'indirizzo dell'istruzione in corso di esecuzione[^pc_updates], come se si tenesse a mente il numero del passo della ricetta che si sta eseguendo.\n"
"Il PC aumenta automaticamente quando la CPU legge le istruzioni, quindi \"per impostazione predefinita\" vengono lette in sequenza; tuttavia, le istruzioni di salto consentono di scrivere un valore diverso nel PC, saltando di fatto a un'altra parte del programma.\n"
"Da qui il nome."

#: src/part1/jumps.md:20
msgid "Okay, so, let's talk about those jump instructions, shall we?\n"
"There are four of them:"
msgstr "Ok, allora parliamo di queste istruzioni di salto, che ne dite?\n"
"Ce ne sono quattro:"

#: src/part1/jumps.md:23
msgid "Instruction   | Mnemonic | Effect\n"
"--------------|----------|---------------------------------------------\n"
"Jump          | `jp`     | Jump execution to a location\n"
"Jump Relative | `jr`     | Jump to a location close by\n"
"Call          | `call`   | Call a subroutine\n"
"Return        | `ret`    | Return from a subroutine"
msgstr "Istruzione | Mnemonico | Effetto\n"
"--------------|----------|---------------------------------------------\n"
"Jump | `jp` | Salta l'esecuzione a una locazione\n"
"Jump Relativo | `jr` | Salta a una locazione vicina\n"
"Call | `call` | Chiama una subroutine\n"
"Return | `ret` | Ritorna da una subroutine"

#: src/part1/jumps.md:30
msgid "We will focus on `jp` for now.\n"
"`jp`, such as the one line 5, simply sets PC to its argument, jumping execution there.\n"
"In other words, after executing `jp EntryPoint` (line 5), the next instruction executed is the one below `EntryPoint` (line <!-- should be 9 + 1 --> 16)."
msgstr "Per ora ci concentreremo su `jp`.\n"
"`jp`, come quello della riga 5, imposta semplicemente PC al suo argomento, saltando l'esecuzione a quel punto.\n"
"In altre parole, dopo l'esecuzione di `jp EntryPoint` (riga 5), l'istruzione successiva eseguita √® quella sotto `EntryPoint` (riga <!-- should be 9 + 1 --> 16)."

#: src/part1/jumps.md:36
msgid "You may be wondering what is the point of that specific `jp`.\n"
"Don't worry, we will see later why it's required."
msgstr "Ci si potrebbe chiedere a cosa serva questo specifico `jp`.\n"
"Non preoccupatevi, vedremo pi√π avanti perch√© √® necessario."

#: src/part1/jumps.md:41
msgid "## Conditional jumps"
msgstr "## Salti condizionati"

#: src/part1/jumps.md:43
msgid "Now to the *really* interesting part.\n"
"Let's examine the loop responsible for copying tiles:"
msgstr "Passiamo ora alla parte *davvero* interessante.\n"
"Esaminiamo il ciclo responsabile della copia delle tile:"

#: src/part1/jumps.md:46
msgid "```rgbasm,linenos,start=24\n"
"\t; Copy the tile data\n"
"\tld de, Tiles\n"
"\tld hl, $9000\n"
"\tld bc, TilesEnd - Tiles\n"
"CopyTiles:\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"\tinc de\n"
"\tdec bc\n"
"\tld a, b\n"
"\tor a, c\n"
"\tjp nz, CopyTiles\n"
"```"
msgstr "```rgbasm,linenos,start=24\n"
"\t; Copia i dati delle tile\n"
"\tld de, Tiles\n"
"\tld hl, $9000\n"
"\tld bc, TilesEnd - Tiles\n"
"CopyTiles:\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"\tinc de\n"
"\tdec bc\n"
"\tld a, b\n"
"\tor a, c\n"
"\tjp nz, CopyTiles\n"
"```"

#: src/part1/jumps.md:63
msgid "Don't worry if you don't quite get all the following, as we'll see it live in action in the next lesson.\n"
"If you're having trouble, try going to the next lesson, watch the code execute step by step; then, coming back here, it should make more sense."
msgstr "Non preoccupatevi se non capite bene quanto segue, perch√© lo vedremo in azione nella prossima lezione.\n"
"Se avete problemi, provate ad andare alla prossima lezione e guardate il codice eseguito passo per passo; poi, tornando a questo punto, dovrebbe avere tutto pi√π senso."

#: src/part1/jumps.md:68
msgid "First, we copy `Tiles`, the address of the first byte of tile data, into `de`.\n"
"Then, we set `hl` to $9000, which is the address where we will start copying the tile data to.\n"
"`ld bc, TilesEnd - Tiles` sets `bc` to the length of the tile data: `TilesEnd` is the address of the first byte *after* the tile data, so subtracting `Tiles` to that yields the length."
msgstr "Per prima cosa, copiamo `Tiles`, l'indirizzo del primo byte dei dati delle tile, in `de`.\n"
"Poi, impostiamo `hl` a $9000, che √® l'indirizzo in cui inizieremo a copiare i dati delle tile.\n"
"`ld bc, TilesEnd - Tiles` imposta `bc` sulla lunghezza dei dati delle tile: `TilesEnd` √® l'indirizzo del primo byte *dopo* i dati delle tile, quindi sottraendogli `Tiles` si ottiene la lunghezza."

#: src/part1/jumps.md:72
msgid "So, basically:"
msgstr "Quindi, in pratica:"

#: src/part1/jumps.md:74
msgid "- `de` contains the address where data will be copied from;\n"
"- `hl` contains the address where data will be copied to;\n"
"- `bc` contains how many bytes we have to copy."
msgstr "- `de` contiene l'indirizzo da cui verranno copiati i dati;\n"
"- `hl` contiene l'indirizzo in cui verranno copiati i dati;\n"
"- `bc` contiene il numero di byte da copiare."

#: src/part1/jumps.md:78
msgid "Then we arrive at the main loop.\n"
"We read one byte from the source (line 29), and write it to the destination (line 30).\n"
"We increment the destination (via the implicit `inc hl` done by `ld [hli], a`) and source pointers (line 31), so the following loop iteration processes the next byte."
msgstr "Arriviamo quindi al ciclo principale.\n"
"Leggiamo un byte dalla sorgente (riga 29) e lo scriviamo nella destinazione (riga 30).\n"
"Incrementiamo i puntatori alla destinazione (tramite l'implicito `inc hl` fatto da `ld [hli], a`) e alla sorgente (riga 31), in modo che la successiva iterazione del ciclo elabori il byte successivo."

#: src/part1/jumps.md:82
msgid "Here's the interesting part: since we've just copied one byte, that means we have one less to go, so we `dec bc`.\n"
"(We have seen `dec` two lessons ago; as a refresher, it simply decreases the value stored in `bc` by one.)\n"
"Since `bc` contains the amount of bytes that still need to be copied, it's trivial to see that we should simply repeat the operation if `bc` != 0."
msgstr "Ecco la parte interessante: poich√© abbiamo appena copiato un byte, significa che ne abbiamo uno in meno, quindi dobbiamo fare `dec bc`.\n"
"(Abbiamo gi√† visto `dec` due lezioni fa; per rinfrescare la memoria, si tratta semplicemente di diminuire di uno il valore memorizzato in `bc`).\n"
"Poich√© `bc` contiene la quantit√† di byte che devono ancora essere copiati, √® facile capire che dobbiamo semplicemente ripetere l'operazione se `bc` != 0."

#: src/part1/jumps.md:86
msgid "::: danger:üòì"
msgstr ""

#: src/part1/jumps.md:88
msgid "`dec` usually updates flags, but unfortunately `dec bc` doesn't, so we must check if `bc` reached 0 manually."
msgstr "`dec` di solito aggiorna i flag, ma sfortunatamente `dec bc` non lo fa, quindi dobbiamo controllare manualmente se `bc` ha raggiunto 0."

#: src/part1/jumps.md:92
msgid "`ld a, b` and `or a, c` \"bitwise OR\" `b` and `c` together; it's enough to know for now that it leaves 0 in `a` if and only if `bc` == 0.\n"
"And `or` updates the Z flag!\n"
"So, after line 34, the Z flag is set if and only if `bc` == 0, that is, if we should exit the loop."
msgstr "`ld a, b` e `or a, c` applicano \"bitwise OR\" a `b` e `c` insieme; per ora √® sufficiente sapere che lascia 0 in `a` se e solo se `bc` == 0.\n"
"E `or` aggiorna il flag Z!\n"
"Quindi, dopo la riga 34, il flag Z √® impostato se e solo se `bc` == 0, cio√® se dobbiamo uscire dal ciclo."

#: src/part1/jumps.md:96
msgid "And this is where conditional jumps come into the picture!\n"
"See, it's possible to **conditionally** \"take\" a jump depending on the state of the flags."
msgstr "Ed √® qui che entrano in gioco i salti condizionati!\n"
"√à possibile \"prendere\" **condizionatamente** un salto a seconda dello stato dei flag."

#: src/part1/jumps.md:99
msgid "There are four \"conditions\":"
msgstr "Le \"condizioni\" sono quattro:"

#: src/part1/jumps.md:101
msgid "Name     | Mnemonic | Description\n"
"---------|----------|----------------------------------------------------\n"
"Zero     | `z`      | Z is set (last operation had a result of 0)\n"
"Non-zero | `nz`     | Z is not set (last operation had a non-zero result)\n"
"Carry    | `c`      | C is set (last operation overflowed)\n"
"No carry | `nc`     | C is not set (last operation did not overflow)"
msgstr "Nome | Mnemonico | Descrizione\n"
"---------------|--------|----------------------------------------------------\n"
"Zero         | `z`   | Z √® impostato (l'ultima operazione ha avuto un risultato pari a 0)\n"
"Non zero | `nz` | Z non √® impostato (l'ultima operazione ha avuto un risultato diverso da 0)\n"
"Carry        | `c`   | C √® impostato (l'ultima operazione √® andata in overflow)\n"
"No carry  | `nc` | C non √® impostato (l'ultima operazione non √® andata in overflow)"

#: src/part1/jumps.md:108
msgid "Thus, `jp nz, CopyTiles` can be read as \"if the Z flag is not set, then jump to `CopyTiles`\".\n"
"Since we're jumping *backwards*, we will repeat the instructions again: we have just created a **loop**!"
msgstr "Quindi, `jp nz, CopyTiles` pu√≤ essere letto come \"se il flag Z non √® impostato, allora salta a `CopyTiles`\".\n"
"Poich√© stiamo saltando *all'indietro*, ripeteremo di nuovo le istruzioni: abbiamo appena creato un **ciclo**!"

#: src/part1/jumps.md:111
msgid "Okay, we've been talking about the code a lot, and we have seen it run, but we haven't really seen *how* it runs.\n"
"Let's watch the magic unfold in slow-motion in the next lesson!"
msgstr "Ok, abbiamo parlato molto del codice e lo abbiamo visto girare, ma non abbiamo visto *come* gira.\n"
"Guardiamo la magia che si svolge al rallentatore nella prossima lezione!"

#: src/part1/jumps.md:116
msgid "[^pc_updates]:\n"
"Not exactly; instructions may be several bytes long, and PC increments after reading each byte.\n"
"Notably, this means that when an instruction finishes executing, PC is pointing to the following instruction.\n"
"Still, it's pretty much \"where the CPU is currently reading from\", but it's better to keep it simple and avoid mentioning instruction encoding for now."
msgstr "[^pc_updates]:\n"
"Non esattamente; le istruzioni possono essere lunghe diversi byte e PC si incrementa dopo aver letto ogni byte.\n"
"In particolare, ci√≤ significa che quando un'istruzione finisce di essere eseguita, PC punta all'istruzione successiva.\n"
"Comunque, √® pi√π o meno \"da dove la CPU sta leggendo\", ma √® meglio mantenere le cose semplici ed evitare di parlare della codifica delle istruzioni per ora."

#: src/part1/tracing.md:1
msgid "# Tracing"
msgstr "# Tracciamento"

#: src/part1/tracing.md:3
msgid "Ever dreamed of being a wizard?\n"
"Well, this won't give you magical powers, but let's see how emulators can be used to control time!"
msgstr "Avete mai sognato di essere dei maghi?\n"
"Beh, questo non vi dar√† poteri magici, ma vediamo come gli emulatori possono essere usati per controllare il tempo!"

#: src/part1/tracing.md:6
msgid "First, make sure to focus the debugger window.\n"
"Let's first explain the debugger's layout:\n"
"![](../assets/img/debugger.png)\n"
"Top-left is the code viewer, bottom-left is the data viewer, top-right are some registers (as we saw in [the registers lesson](registers.html)), and bottom-right is the stack viewer.\n"
"What's the stack?\n"
"We will answer that question a bit later... in Part ‚Ö° üòÖ"
msgstr "Per prima cosa, assicuratevi di mettere a fuoco la finestra del debugger.\n"
"Spieghiamo innanzitutto il layout del debugger:\n"
"![](../assets/img/debugger.png)\n"
"In alto a sinistra c'√® il visualizzatore del codice, in basso a sinistra c'√® il visualizzatore dei dati, in alto a destra ci sono alcuni registri (come abbiamo visto nella [lezione sui registri](registers.html)) e in basso a destra c'√® il visualizzatore dello stack.\n"
"Che cos'√® lo stack?\n"
"Risponderemo a questa domanda un po' pi√π avanti... nella Parte ‚Ö° üòÖ"

#: src/part1/tracing.md:13
msgid "## Setup"
msgstr "## Preparazione"

#: src/part1/tracing.md:15
msgid "For now, let's focus on the code viewer."
msgstr ""

#: src/part1/tracing.md:17
msgid "As Emulicious can load our source code, our code's labels and comments are automatically shown in the debugger.\n"
"As we have seen a couple of lessons ago, labels are merely a convenience provided by RGBASM, but they are not part of the ROM itself.\n"
"In other emulators, it is very much inconvenient to debug without them, and so sym files (for \"**sym**bols\") have been developed.\n"
"Let's run RGBLINK to generate a sym file for our ROM:"
msgstr ""

#: src/part1/tracing.md:22
msgid "```console\n"
"$ rgblink -n hello-world.sym hello-world.o\n"
"```"
msgstr "```console\n"
"$ rgblink -n hello-world.sym hello-world.o\n"
"```"

#: src/part1/tracing.md:26
msgid "::: warning:‚ÄºÔ∏è"
msgstr ""

#: src/part1/tracing.md:28
msgid "The file names matter!\n"
"When looking for a ROM's sym file, emulators take the ROM's file name, strip the extension (here, `.gb`), replace it with `.sym`, and look for a file **in the same directory** with that name."
msgstr ""

#: src/part1/tracing.md:33
msgid "## Stepping"
msgstr "## Passo"

#: src/part1/tracing.md:35
msgid "When pausing execution, the debugger will automatically focus on the instruction the CPU is about to execute, as indicated by the line highlighted in blue.\n"
"![Screenshot of the debugger showing that the highlighted line corresponds to PC](../assets/img/pc.png)"
msgstr "Quando si mette in pausa l'esecuzione, il debugger si concentra automaticamente sull'istruzione che la CPU sta per eseguire, come indicato dalla riga evidenziata in blu.\n"
"![Schermata del debugger che mostra che la riga evidenziata corrisponde a PC](../assets/img/pc.png)"

#: src/part1/tracing.md:40
msgid "The instruction highlighted in blue is always what the CPU is _about to execute_, not what it _just executed_. Keep this in mind."
msgstr ""

#: src/part1/tracing.md:44
msgid "If we want to watch execution from the beginning, we need to reset the emulator.\n"
"Go into the emulator's \"File\" menu, and select \"Reset\", or press <kbd><kbd>Ctrl</kbd>+<kbd>Backspace</kbd></kbd>."
msgstr ""

#: src/part1/tracing.md:47
msgid "The blue line should automatically move to address $0100[^boot_addr], and now we're ready to trace!\n"
"All the commands for that are in the \"Run\" menu."
msgstr "La linea blu dovrebbe spostarsi automaticamente all'indirizzo $0100[^boot_addr] e ora siamo pronti a tracciare!\n"
"Tutti i comandi per farlo si trovano nel menu \"Esegui\"."

#: src/part1/tracing.md:50
msgid "- \"Resume\" simply unpauses the emulator.\n"
"- \"Step Into\" and \"Step Over\" advance the emulator by one instruction.\n"
"  They only really differ on the `call` instruction, interrupts, and when encountering a conditional jump, neither of which we are using here, so we will use \"Step Into\".\n"
"- The other options are not relevant for now."
msgstr ""

#: src/part1/tracing.md:55
msgid "We will have to \"Step Into\" a bunch of times, so it's a good idea to use the key shortcut.\n"
"If we press <kbd><kbd>F5</kbd></kbd> once, the `jp EntryPoint` is executed.\n"
"And if we press it a few more times, can see the instructions being executed, one by one!"
msgstr ""

#: src/part1/tracing.md:59
msgid "<video controls poster=\"../assets/vid/reset_trace.poster.png\">\n"
"  <source src=\"../assets/vid/reset_trace.webm\" type=\"video/webm\">\n"
"  <source src=\"../assets/vid/reset_trace.mp4\" type=\"video/mp4\">"
msgstr "<video controls poster=\"../assets/vid/reset_trace.poster.png\">\n"
"  <source src=\"../assets/vid/reset_trace.webm\" type=\"video/webm\">\n"
"  <source src=\"../assets/vid/reset_trace.mp4\" type=\"video/mp4\">"

#: src/part1/tracing.md:63
msgid "  <img src=\"../assets/vid/reset_trace.gif\" alt=\"Video demonstration in Emulicious\">\n"
"</video>"
msgstr "  <img src=\"../assets/vid/reset_trace.gif\" alt=\"Dimostrazione video in Emulicious\">\n"
"</video>"

#: src/part1/tracing.md:66
msgid "Now, you may notice the `WaitVBlank` loop runs a _lot_ of times, but what we are interested in is the `CopyTiles` loop.\n"
"We can easily skip over it in several ways; this time, we will use a _breakpoint_.\n"
"We will place the breakpoint on the `ld de, Tiles` at `00:0162`; either double-click on that line, or select it and press <kbd><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>B</kbd></kbd>."
msgstr ""

#: src/part1/tracing.md:70
msgid "![Debugger screenshot showcasing the breakpoint](../assets/img/breakpoint.png)"
msgstr "![Schermata del debugger che mostra il punto di interruzione](../assets/img/breakpoint.png)"

#: src/part1/tracing.md:72
msgid "Then you can resume execution by pressing <kbd><kbd>F8</kbd></kbd>.\n"
"Whenever Emulicious is running, and the (emulated) CPU is about to execute an instruction a breakpoint was placed on, it automatically pauses."
msgstr ""

#: src/part1/tracing.md:75
msgid "![Debugger screenshot showcasing execution paused on the breakpoint](../assets/img/bkpt_pause.png)"
msgstr "![Schermata del debugger che mostra l'esecuzione in pausa sul punto di interruzione](../assets/img/bkpt_pause.png)"

#: src/part1/tracing.md:77
msgid "You can see where execution is being paused both from the green arrow and the value of PC."
msgstr "La freccia verde e il valore di PC indicano il punto in cui l'esecuzione √® in pausa."

#: src/part1/tracing.md:79
msgid "If we trace the next three instructions, we can see the three arguments to the `CopyTiles` loop getting loaded into registers."
msgstr "Se tracciamo le tre istruzioni successive, possiamo vedere che i tre argomenti del ciclo `CopyTiles` vengono caricati nei registri."

#: src/part1/tracing.md:81
msgid "![The state of some registers at the beginning of the CopyTiles loop](../assets/img/regs_copytiles.png)"
msgstr "![Lo stato di alcuni registri all'inizio del ciclo CopyTiles](../assets/img/regs_copytiles.png)"

#: src/part1/tracing.md:83
msgid "For fun, let's watch the tiles as they're being copied.\n"
"For that, obviously, we will use the Memory Editor, and position it at the destination.\n"
"As we can see from the image above, that would be $9000!"
msgstr ""

#: src/part1/tracing.md:87
msgid "Click on \"Memory\" on the bottom window, then \"VRAM\", and press <kbd><kbd>Ctrl</kbd>+<kbd>G</kbd></kbd> (for \"Goto\")."
msgstr ""

#: src/part1/tracing.md:89
msgid "<video controls poster=\"../assets/vid/trace_copy.poster.png\">\n"
"  <source src=\"../assets/vid/trace_copy.webm\" type=\"video/webm\">\n"
"  <source src=\"../assets/vid/trace_copy.mp4\" type=\"video/mp4\">"
msgstr "<video controls poster=\"../assets/vid/trace_copy.poster.png\">\n"
"  <source src=\"../assets/vid/trace_copy.webm\" type=\"video/webm\">\n"
"  <source src=\"../assets/vid/trace_copy.mp4\" type=\"video/mp4\">"

#: src/part1/tracing.md:93
msgid "  <img src=\"../assets/vid/trace_copy.gif\" alt=\"Video demonstration in Emulicious\">\n"
"</video>"
msgstr "  <img src=\"../assets/vid/trace_copy.gif\" alt=\"Dimostrazione video in Emulicious\">\n"
"</video>"

#: src/part1/tracing.md:96
msgid "Awesome, right?"
msgstr "Fantastico, vero?"

#: src/part1/tracing.md:98
msgid "## What next?"
msgstr "## E poi?"

#: src/part1/tracing.md:100
msgid "Congrats, you have just learned how to use a debugger!\n"
"We have only scratched the surface, though; we will use more of Emulicious' tools to illustrate the next parts.\n"
"Don't worry, from here on, lessons will go with a lot more images‚Äîyou've made it through the hardest part!"
msgstr ""

#: src/part1/tracing.md:106
msgid "[^boot_addr]:"
msgstr "[^boot_addr]:"

#: src/part1/tracing.md:108
msgid "Why does execution start at $0100?\n"
"That's because it's where the [boot ROM](https://gbdev.io/pandocs/Power_Up_Sequence) hands off control to our game once it's done."
msgstr ""

#: src/part1/tiles.md:1
msgid "# Tiles"
msgstr "# Tile"

#: src/part1/tiles.md:3
msgid "::: tip:üí≠"
msgstr ""

#: src/part1/tiles.md:5
msgid "\"Tiles\" were called differently in documentation of yore.\n"
"They were usually called \"patterns\" or \"characters\", the latter giving birth to the \"CHR\" abbreviation which is sometimes used to refer to tiles."
msgstr "Le \"tile\" venivano chiamate in modo diverso nella documentazione di un tempo.\n"
"Di solito venivano chiamate \"schemi\" o \"caratteri\" e quest'ultima ha dato origine all'abbreviazione \"CHR\", che a volte viene usata per riferirsi alle tile."

#: src/part1/tiles.md:8
msgid "For example, on the NES, tile data is usually provided by the cartridge in either [CHR ROM or CHR RAM](http://wiki.nesdev.com/w/index.php/CHR_ROM_vs._CHR_RAM).\n"
"The term \"CHR\" is typically not used on the Game Boy, though exchanges between communities cause terms to \"leak\", so some refer to the area of VRAM where tiles are stored as \"CHR RAM\" or \"CHR VRAM\", for example."
msgstr "Ad esempio, sul NES, i dati dei tile sono solitamente forniti dalla cartuccia in [CHR ROM o CHR RAM](http://wiki.nesdev.com/w/index.php/CHR_ROM_vs._CHR_RAM).\n"
"Il termine \"CHR\" non √® tipicamente utilizzato sul Game Boy, anche se gli scambi tra le comunit√† fanno s√¨ che i termini \"trapelino\", per cui alcuni si riferiscono all'area della VRAM in cui sono memorizzati i tile come \"CHR RAM\" o \"CHR VRAM\", ad esempio."

#: src/part1/tiles.md:11
msgid "As with all such jargon whose meaning may depend on who you are talking to, I will stick to \"tiles\" across this entire tutorial for consistency, being what is the most standard in the GB dev community now."
msgstr "Come per tutti i gerghi di questo tipo, il cui significato pu√≤ dipendere dall'interlocutore, per coerenza mi atterr√≤ a \"tile\" in tutto il tutorial, essendo ormai lo standard pi√π diffuso nella comunit√† degli sviluppatori di GB."

#: src/part1/tiles.md:15
msgid "Well, copying this data blindly is fine and dandy, but why exactly is the data \"graphics\"?"
msgstr "Copiare questi dati alla cieca va benissimo, ma perch√© i dati sono \"grafici\"?"

#: src/part1/tiles.md:17
msgid "<figure>\n"
"  <img src=\"../assets/img/ah_yes_pixels.png\" alt=\"Screenshot of some tile definitions in the code\">\n"
"  <figcaption><q>Ah, yes, pixels.</q></figcaption>\n"
"</figure>"
msgstr "<figure>\n"
"  <img src=\"../assets/img/ah_yes_pixels.png\" alt=\"Screenshot of some tile definitions in the code\">\n"
"  <figcaption><q>Ah, s√¨, i pixel.</q></figcaption>\n"
"</figure>"

#: src/part1/tiles.md:22
msgid "Let's see about that!"
msgstr "Vediamo un po'!"

#: src/part1/tiles.md:24
msgid "## Helpful hand"
msgstr "## Un Aiuto"

#: src/part1/tiles.md:26
msgid "Now, figuring out the format with an explanation alone is going to be very confusing; but fortunately, Emulicious got us covered thanks to its *Tile Viewer*.\n"
"You can open it either by selecting \"Tools\" then \"Tile Viewer\", or by clicking on the grid of colored tiles in the debugger's toolbar."
msgstr ""

#: src/part1/tiles.md:29
msgid "![Screenshot of the Tile Viewer](../assets/img/vram_viewer.png)"
msgstr "![Schermata del Tile Viewer](../assets/img/vram_viewer.png)"

#: src/part1/tiles.md:31
msgid "You can combine the various VRAM viewers by going to \"View\", then \"Combine Video Viewers\".\n"
"We will come to the other viewers in due time.\n"
"This one shows the tiles present in the Game Boy's video memory (or \"<abbr title=\"Video RAM\">VRAM</abbr>\")."
msgstr ""

#: src/part1/tiles.md:37
msgid "I encourage you to experiment with the VRAM viewer, hover over things, tick and untick checkboxes, see by yourself what's what. Any questions you might have will be answered in due time, don't worry! And if what you're seeing later on doesn't match my screenshots, ensure that the checkboxes match mine."
msgstr "Vi invito a sperimentare con il visualizzatore di VRAM, a passare il mouse sulle cose, a spuntare e deselezionare le caselle di controllo, a scoprire da soli cosa √® cosa. Tutte le domande che vi porrete troveranno risposta a tempo debito, non preoccupatevi! E se quello che vedete in seguito non corrisponde alle mie schermate, assicuratevi di avere le mie stesse caselle spuntate."

#: src/part1/tiles.md:41
msgid "Don't mind the \"¬Æ\" icon in the top-left; we did not put it there ourselves, and we will see why it's there later."
msgstr ""

#: src/part1/tiles.md:43
msgid "## Short primer"
msgstr "## Primer breve"

#: src/part1/tiles.md:45
msgid "You may have heard of tiles before, especially as they were really popular in 8-bit and 16-bit systems.\n"
"That's no coincidence: tiles are very useful.\n"
"Instead of storing every on-screen pixel (144 √ó 160 pixels √ó 2 bits/pixel = 46080 bits = 5760 bytes, compared to the console's 8192 bytes of VRAM), pixels are grouped into tiles, and then tiles are assembled in various ways to produce the final image."
msgstr "Potreste aver gi√† sentito parlare di tiles, soprattutto perch√© erano molto popolari nei sistemi a 8 e 16 bit.\n"
"Non √® una coincidenza: le tile sono molto utili.\n"
"Invece di memorizzare ogni pixel sullo schermo (144 √ó 160 pixel √ó 2 bit/pixel = 46080 bit = 5760 byte, rispetto agli 8192 byte di VRAM della console), i pixel vengono raggruppati in tile, che vengono poi assemblate in vari modi per produrre l'immagine finale."

#: src/part1/tiles.md:49
msgid "In particular, tiles can be reused very easily and at basically no cost, saving a lot of memory!\n"
"In addition, manipulating whole tiles at once is much cheaper than manipulating the individual pixels, so this spares processing time as well."
msgstr "In particolare, le tile possono essere riutilizzate molto facilmente e praticamente a costo zero, risparmiando molta memoria!\n"
"Inoltre, la manipolazione di intere tile in una sola volta √® molto pi√π economica rispetto alla manipolazione dei singoli pixel e questo fa risparmiare tempo di elaborazione."

#: src/part1/tiles.md:52
msgid "The concept of a \"tile\" is very general, but on the Game Boy, tiles are *always* 8 by 8 pixels.\n"
"Often, hardware tiles are grouped to manipulate them as larger tiles (often 16√ó16); to avoid the confusion, those are referred to as **meta-tiles**."
msgstr "Il concetto di \"tile\" √® molto generico, ma sul Game Boy le tile sono *sempre* di 8 per 8 pixel.\n"
"Spesso le tile hardware vengono raggruppate per essere manipolate come tile pi√π grandi (spesso 16√ó16); per evitare la confusione, queste vengono chiamate **meta-tile**."

#: src/part1/tiles.md:55
msgid "### \"bpp\"?"
msgstr "### \"bpp\"?"

#: src/part1/tiles.md:57
msgid "You may be wondering where that \"2 bits/pixel\" figure earlier came from...\n"
"This is something called \"bit depth\"."
msgstr "Vi starete chiedendo da dove provenga la cifra di \"2 bit/pixel\" di cui sopra...\n"
"Si tratta della cosiddetta \"profondit√† di bit\"."

#: src/part1/tiles.md:60
msgid "See, colors are *not* stored in the tiles themselves!\n"
"Instead, it works like a coloring book: the tile itself contains 8 by 8 *indices*, not colors; you give the hardware a tile and a set of colors‚Äîa **palette**‚Äîand it colorizes them!\n"
"(This is also why color swaps were very common back then: you could create enemy variations by storing tiny palettes instead of large different graphics.)"
msgstr "I colori non sono memorizzati nelle tile stesse!\n"
"Invece, funziona come un libro da colorare: la tile in s√© contiene *indici* di 8 x 8, non colori; si d√† all'hardware una tile e un insieme di colori - una **tavolozza** - e lui li colora!\n"
"(Questo √® anche il motivo per cui le varianti di colore erano molto comuni all'epoca: si potevano creare diverse versioni di un nemico memorizzando piccole tavolozze invece di grandi grafiche diverse.)"

#: src/part1/tiles.md:64
msgid "Anyway, as it is, Game Boy palettes are 4 colors large.[^pal_size]\n"
"This means that the indices into those palettes, stored in the tiles, can be represented in only *two bits*!\n"
"This is called \"2 bits per pixel\", noted \"2bpp\"."
msgstr "In ogni caso, le tavolozze del Game Boy sono grandi 4 colori.[^pal_size]\n"
"Ci√≤ significa che gli indici di tali tavolozze, memorizzati nelle tile, possono essere rappresentati con solo *due bit*!\n"
"Questo si definisce \"2 bit per pixel\", noto come \"2bpp\"."

#: src/part1/tiles.md:68
msgid "With that in mind, we are ready to explain how these bytes turn into pixels!"
msgstr "Con queste premesse, siamo pronti a spiegare come questi byte si trasformano in pixel!"

#: src/part1/tiles.md:70
msgid "## Encoding"
msgstr "## Codifica"

#: src/part1/tiles.md:72
msgid "As I explained, each pixel takes up 2 bits.\n"
"Since there are 8 bits in a byte, you might expect each byte to contain 4 pixels... and you would be neither entirely right, nor entirely wrong.\n"
"See, each row of 8 pixels is stored in 2 bytes, but neither of these bytes contains the info for 4 pixels.\n"
"(Think of it like a 10 ‚Ç¨ banknote torn in half: neither half is worth anything, but the full bill is worth, well, 10 ‚Ç¨.)"
msgstr "Come ho spiegato, ogni pixel occupa 2 bit.\n"
"Poich√© ci sono 8 bit in un byte, ci si potrebbe aspettare che ogni byte contenga 4 pixel... e non sarebbe n√© del tutto giusto n√© del tutto sbagliato.\n"
"Ogni riga di 8 pixel √® memorizzata in 2 byte, ma nessuno di questi byte contiene le informazioni per 4 pixel.\n"
"(Pensate a una banconota da 10 ‚Ç¨ strappata a met√†: nessuna delle due met√† ha valore, ma la banconota intera vale, beh, 10 ‚Ç¨)."

#: src/part1/tiles.md:77
msgid "For each pixel, the least significant bit of its index is stored in the first byte, and the most significant bit is stored in the second byte.\n"
"Since each byte is a collection of one of the bits for each pixel, it's called a **bitplane**."
msgstr "Per ogni pixel, il bit meno significativo del suo indice √® memorizzato nel primo byte, mentre il bit pi√π significativo √® memorizzato nel secondo byte.\n"
"Poich√© ogni byte √® una raccolta di uno dei bit di ciascun pixel, questo insieme viene chiamato **bitplane**."

#: src/part1/tiles.md:80
msgid "The leftmost pixel is stored in the leftmost bit of both bytes, the pixel to its right in the second leftmost bit, and so on.\n"
"The first pair of bytes stores the topmost row, the second byte the row below that, and so on."
msgstr "Il pixel pi√π a sinistra √® memorizzato nel primo bit da sinistra di entrambi i byte, il pixel alla sua destra nel secondo bit da sinistra e cos√¨ via.\n"
"La prima coppia di byte memorizza la riga superiore, il secondo byte quella inferiore e cos√¨ via."

#: src/part1/tiles.md:83
msgid "Here is a more visual demonstration:"
msgstr "Ecco una dimostrazione pi√π visiva:"

#: src/part1/tiles.md:85
msgid "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/txkHN6izK2Y\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>"
msgstr "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/txkHN6izK2Y\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>"

#: src/part1/tiles.md:87
msgid "This encoding may seem a little weird at first, and it can be; it's made to be more convenient for the hardware to decode, keeping the circuitry simple and low-power.\n"
"It even makes a few cool tricks possible, as we will see (much) later!"
msgstr "Questa codifica pu√≤ sembrare un po' strana all'inizio, e pu√≤ esserlo; √® fatta per essere pi√π conveniente per l'hardware da decodificare, mantenendo la circuiteria semplice e a basso consumo.\n"
"Rende possibili anche alcuni trucchi interessanti, come vedremo (molto) pi√π avanti!"

#: src/part1/tiles.md:90
msgid "You can read up more about the encoding [in the Pan Docs](https://gbdev.io/pandocs/Tile_Data.html) and [ShantyTown's site](https://www.huderlem.com/demos/gameboy2bpp.html)."
msgstr "Si possono trovare ulteriori informazioni sulla codifica [nei Pan Docs](https://gbdev.io/pandocs/Tile_Data.html) e [nel sito di ShantyTown](https://www.huderlem.com/demos/gameboy2bpp.html)."

#: src/part1/tiles.md:92
msgid "In the next lesson, we shall see how colors are applied!"
msgstr "Nella prossima lezione vedremo come si applicano i colori!"

#: src/part1/tiles.md:96
msgid "[^pal_size]:\n"
"Other consoles can have varying bit depths; for example, the SNES has 2bpp, 4bpp, and 8bpp depending on the graphics mode and a few other parameters."
msgstr "[^pal_size]:\n"
"Altre console possono avere profondit√† di bit diverse; ad esempio, lo SNES ha 2bpp, 4bpp e 8bpp a seconda della modalit√† grafica e di alcuni altri parametri."

#: src/part1/palettes.md:1
msgid "# Palettes"
msgstr "# Tavolozze"

#: src/part1/palettes.md:3
msgid "In the previous lesson, I briefly mentioned that colors are applied to tiles via _palettes_, but we haven't talked much about those yet."
msgstr ""

#: src/part1/palettes.md:5
msgid "The black & white Game Boy has three palettes, one for the background called [`BGP`](https://gbdev.io/pandocs/Palettes.html#ff47---bgp-bg-palette-data-rw---non-cgb-mode-only) (\"BackGround Palette\"), and two for the objects called [`OBP0`](https://gbdev.io/pandocs/Palettes.html#ff48---obp0-object-palette-0-data-rw---non-cgb-mode-only) and [`OBP1`](https://gbdev.io/pandocs/Palettes.html#ff48---obp1-object-palette-1-data-rw---non-cgb-mode-only) (\"OBject Palette 0/1\").\n"
"If you are wondering what \"objects\" are, you will have to wait until Part ‚Ö° to find out; for now, let's focus on the background."
msgstr "Il Game Boy in bianco e nero ha tre tavolozze, una per lo sfondo chiamata [`BGP`](https://gbdev.io/pandocs/Palettes.html#ff47---bgp-bg-palette-data-rw---non-cgb-mode-only) (\"BackGround Palette\") e due per gli oggetti chiamate [`OBP0`](https://gbdev.io/pandocs/Palettes.html#ff48---obp0-object-palette-0-data-rw---non-cgb-mode-only) e [`OBP1`](https://gbdev.io/pandocs/Palettes.html#ff48---obp1-object-palette-1-data-rw---non-cgb-mode-only) (\"OBject Palette 0/1\").\n"
"Se vi state chiedendo cosa siano gli \"oggetti\", dovrete aspettare la Parte ‚Ö° per scoprirlo; per ora, concentriamoci sullo sfondo."

#: src/part1/palettes.md:8
msgid "::: tip:üåà"
msgstr ""

#: src/part1/palettes.md:10
msgid "The Game Boy Color introduced, obviously, colors, and this was mainly done by reworking the way palettes are handled.\n"
"We will not talk about Game Boy Color features in Part ‚Ö† for the sake of simplicity, but we will do so in later parts."
msgstr "Il Game Boy Color ha introdotto, ovviamente, i colori e questo √® stato fatto principalmente rielaborando il modo in cui vengono gestite le tavolozze.\n"
"Non parleremo delle caratteristiche del Game Boy Color nella Parte ‚Ö† per semplicit√†, ma lo faremo nelle parti successive."

#: src/part1/palettes.md:15
msgid "If you chose to combine the video viewers in the previous chapter, the palette viewer should show up on the bottom right of the video viewer.\n"
"Otherwise, please select Emulicious' \"Tools\" tab, then select `Palette Viewer`."
msgstr ""

#: src/part1/palettes.md:18
msgid "![Screenshot of the VRAM viewer's Palette tab](../assets/img/pal_viewer.png)"
msgstr "![Schermata della scheda Palette del visualizzatore VRAM](../assets/img/pal_viewer.png)"

#: src/part1/palettes.md:20
msgid "We will be taking a look at the \"BGP\" line.\n"
"As I explained before, tiles store \"color indices\" for each pixel, which are used to index into the palette.\n"
"Color number 0[^numbering_zero] is the leftmost in that line, and number 3 is the rightmost."
msgstr "Daremo un'occhiata alla linea \"BGP\".\n"
"Come ho spiegato in precedenza, le tile memorizzano gli \"indici di colore\" per ciascun pixel, i quali vengono utilizzati per indicizzare la tavolozza.\n"
"Il colore numero 0[^numbering_zero] √® quello pi√π a sinistra in questa riga e il numero 3 √® quello pi√π a destra."

#: src/part1/palettes.md:24
msgid "So, in our case, color number 0 is \"white\", color number 1 is \"light gray\", number 2 is \"dark gray\", and number 3 \"black\".\n"
"I put air quotes because \"black\" isn't true black, and \"white\" isn't true white.\n"
"Further, note that the original Game Boy had shades of green, but the later Game Boy Pocket's screen produced shades of gray instead.\n"
"And, even better, the Game Boy Color will automatically colorize games that lack Game Boy Color support!"
msgstr "Quindi, nel nostro caso, il colore numero 0 √® \"bianco\", il numero 1 √® \"grigio chiaro\", il numero 2 √® \"grigio scuro\" e il numero 3 √® \"nero\".\n"
"Ho messo le virgolette perch√© \"nero\" non √® nero puro e \"bianco\" non √® bianco puro.\n"
"Inoltre, notate che il Game Boy originale aveva sfumature di verde, mentre lo schermo del successivo Game Boy Pocket produceva sfumature di grigio.\n"
"E, meglio ancora, il Game Boy Color √® in grado di colorare automaticamente i giochi che non supportano il Game Boy Color!"

#: src/part1/palettes.md:29
msgid "![Screenshot of our Hello World, automatically colorized by the Game Boy Color](../assets/img/hello_world_autocolor.png)"
msgstr "![Schermata del nostro Hello World, colorato automaticamente dal Game Boy Color](../assets/img/hello_world_autocolor.png)"

#: src/part1/palettes.md:31
msgid "All this to say, one shouldn't expect specific colors out of a Game Boy game[^console_detection], just four more or less bright colors."
msgstr "Tutto questo per dire che non ci si deve aspettare colori specifici da un gioco per Game Boy[^console_detection], ma solo quattro colori pi√π o meno luminosi."

#: src/part1/palettes.md:33
msgid "## Getting our hands dirty"
msgstr "## Sporchiamoci le mani"

#: src/part1/palettes.md:35
msgid "Well, so far in this tutorial, besides running the Hello World, we have been pretty passive, watching it unfold.\n"
"What do you say we start prodding the ROM a bit?"
msgstr "In questo tutorial, finora, a parte l'esecuzione di Hello World siamo stati piuttosto passivi, osservando il suo svolgimento.\n"
"Che ne dite se iniziamo a smuovere un po' la ROM?"

#: src/part1/palettes.md:38
msgid "In Emulicious' debugger, select the \"Variables\" tab on the left to show the IO registers."
msgstr ""

#: src/part1/palettes.md:40
msgid "![Screenshot of the IO map](../assets/img/io_map.png)"
msgstr "![Schermata della IO map](../assets/img/io_map.png)"

#: src/part1/palettes.md:42
msgid "While the VRAM viewer offers a visual representation of the palette, the IO map shows the nitty-gritty: how it's encoded.\n"
"The IO map also lets us modify BGP easily; but to do so, we need to understand _how_ values we write are turned into colors."
msgstr ""

#: src/part1/palettes.md:45
msgid "### Encoding"
msgstr "### Codifica"

#: src/part1/palettes.md:47
msgid "Fortunately, the encoding is very simple.\n"
"I will explain it, and at the same time, give an example with the palette we have at hand, $E4."
msgstr "Fortunatamente, la codifica √® molto semplice.\n"
"La spiegher√≤ e allo stesso tempo fornir√≤ un esempio con la tavolozza che abbiamo a portata di mano, $E4."

#: src/part1/palettes.md:50
msgid "Take the byte, break its 8 bits into 4 groups of 2."
msgstr ""

#: src/part1/palettes.md:52
msgid "```\n"
"[BGP] = $E4\n"
"$E4 = %11100100 (refresh your memory in the \"Binary and hexadecimal\" lesson if needed!)\n"
"That gets broken down into %11, %10, %01, %00\n"
"```"
msgstr ""

#: src/part1/palettes.md:58
msgid "Color number 0 is the rightmost \"group\", color number 3 is the leftmost one.\n"
"Simple!\n"
"And this matches what the VRAM viewer is showing us: color number 0, the rightmost, is the brightest (%00), up to color number 3, the leftmost and the darkest (%11)."
msgstr "Il colore numero 0 √® il \"gruppo\" pi√π a destra, il colore numero 3 √® quello pi√π a sinistra.\n"
"Semplice!\n"
"E questo corrisponde a ci√≤ che ci mostra il visualizzatore VRAM: il colore numero 0, quello pi√π a destra, √® quello pi√π chiaro (%00), fino al colore numero 3, che √® quello pi√π a sinistra e il pi√π scuro (%11)."

#: src/part1/palettes.md:62
msgid "### Lights out"
msgstr "### Luci spente"

#: src/part1/palettes.md:64
msgid "For fun, let's make the screen completely black.\n"
"We can easily do this by setting all colors in the palette to black (%11).\n"
"This would be `%11 %11 %11 %11 = $FF`."
msgstr "Per divertimento, rendiamo lo schermo completamente nero.\n"
"Lo si pu√≤ fare facilmente impostando tutti i colori della tavolozza sul nero (%11).\n"
"Questo si traduce in `%11 %11 %11 %11 = $FF`."

#: src/part1/palettes.md:68
msgid "In the \"Variables\" tab in the debugger, click on the byte to the right of BGP, erase the \"E4\", type \"FF\", and hit Enter.\n"
"BGP immediately updates, turning the screen black!"
msgstr ""

#: src/part1/palettes.md:71
msgid "<figure>\n"
"\t<img src=\"../assets/img/pal_viewer_black.png\" alt=\"Screenshot of the palette viewer with the BGP line entirely black\">\n"
"\t<figcaption>Observe how the BGP line is entirely black now. Also, I could have shown a screenshot of the black screen, but that would have been silly.</figcaption>\n"
"</figure>"
msgstr "<figure>\n"
"\t<img src=\"../assets/img/pal_viewer_black.png\" alt=\"Screenshot of the palette viewer with the BGP line entirely black\">\n"
"\t<figcaption>Osservate come la linea BGP sia ora completamente nera. Inoltre, avrei potuto mostrare un'immagine della schermata nera, ma sarebbe stato stupido.</figcaption>\n"
"</figure>"

#: src/part1/palettes.md:76
msgid "What if we wanted to take the original palette, but invert it?\n"
"%11 would become %00, %01 would become %10, %10 would become %01, and %00 would become %11.\n"
"We would get thus:"
msgstr "E se volessimo prendere la tavolozza originale, ma invertirla?\n"
"%11 diventerebbe %00, %01 diventerebbe %10, %10 diventerebbe %01 e %00 diventerebbe %11.\n"
"Otterremmo cos√¨:"

#: src/part1/palettes.md:80
msgid "```\n"
"%11_10_01_00\n"
" ‚Üì  ‚Üì  ‚Üì  ‚Üì\n"
"%00_01_10_11\n"
"```"
msgstr "```\n"
"%11_10_01_00\n"
" ‚Üì  ‚Üì  ‚Üì  ‚Üì\n"
"%00_01_10_11\n"
"```"

#: src/part1/palettes.md:86
msgid "(I'm not giving the value in hexadecimal, use this as an opportunity to exercise your bin-to-hex conversions!)"
msgstr "(Non fornir√≤ il valore in esadecimale, usate questa opportunit√† per esercitare le vostre conversioni da bin a esadecimale!)"

#: src/part1/palettes.md:88
msgid "<figure>\n"
"\t<img src=\"../assets/img/hello_world_inv.png\" alt=\"Screenshot of the color-inverted Hello World\">\n"
"\t<figcaption>If you got it right, it should look like this!</figcaption>\n"
"</figure>"
msgstr "<figure>\n"
"\t<img src=\"../assets/img/hello_world_inv.png\" alt=\"Screenshot of the color-inverted Hello World\">\n"
"\t<figcaption>Se avete fatto bene, dovrebbe apparire cos√¨!</figcaption>\n"
"</figure>"

#: src/part1/palettes.md:93
msgid "If you go to the Tile Viewer and change \"Palette\" to \"Gray\", you will notice that the tile data stays the same regardless of how the palette is modified!\n"
"This is an advantage of using palettes: fading the screen in and out is very cheap, just modifying a single byte, instead of having to update every single on-screen pixel."
msgstr ""

#: src/part1/palettes.md:96
msgid "Got all that?\n"
"Then let's take a look at the last missing puzzle piece in the Hello World's rendering process, the **tilemap**!"
msgstr "Avete capito tutto?\n"
"Allora diamo un'occhiata all'ultimo pezzo mancante del puzzle nel processo di rendering di Hello World, la **tilemap**!"

#: src/part1/palettes.md:101
msgid "[^numbering_zero]:"
msgstr "[^numbering_zero]:"

#: src/part1/palettes.md:103
msgid "Numbering often starts at 0 when working with computers.\n"
"We will understand why later, but for now, please bear with it!"
msgstr ""

#: src/part1/palettes.md:106
msgid "[^console_detection]:"
msgstr "[^console_detection]:"

#: src/part1/palettes.md:108
msgid "Well, it is possible to detect these different models and account for them, but this would require taking plenty of corner cases into consideration, so it's probably not worth the effort."
msgstr ""

#: src/part1/tilemap.md:1
msgid "# Tilemap"
msgstr "# Tilemap"

#: src/part1/tilemap.md:3
msgid "::: tip:üßê"
msgstr ""

#: src/part1/tilemap.md:5
msgid "Some spell them \"tile map\", some \"tilemap\".\n"
"I will be using the latter by preference, but I also stay consistent with it in the code (`Tilemap` and not `TileMap`), as well as later when we will talk about attribute maps (\"attrmap\" and `Attrmap` instead of `AttrMap`)."
msgstr "Alcuni li chiamano \"tile map\", altri \"tilemap\".\n"
"Io user√≤ quest'ultimo di preferenza, ma lo user√≤ anche nel codice (`Tilemap` e non `TileMap`), cos√¨ come pi√π avanti quando parleremo di mappe di attributi (\"attrmap\" e `Attrmap` invece di `AttrMap`)."

#: src/part1/tilemap.md:10
msgid "We are *almost* there.\n"
"We have seen how graphics on the Game Boy are composed of 8√ó8 \"tiles\", and we have seen how color is added into the mix."
msgstr "Ci siamo quasi.\n"
"Abbiamo visto come la grafica del Game Boy sia composta da \"tessere\" 8√ó8 e come il colore venga aggiunto al mix."

#: src/part1/tilemap.md:13
msgid "But we have not seen yet how those tiles are arranged into a final picture!"
msgstr "Ma non abbiamo ancora visto come queste tessere vengono disposte in un'immagine finale!"

#: src/part1/tilemap.md:15
msgid "Tiles are basically a grid of pixels; well, the tilemaps are basically a grid of tiles!\n"
"To allow for cheap reuse, tiles aren't stored in the tilemap directly; instead, tiles are referred to by an *ID*, which you can see in Emulicious' Tile Viewer."
msgstr ""

#: src/part1/tilemap.md:18
msgid "<figure>\n"
"  <img src=\"../assets/img/tile_id.png\" alt=\"Screenshot highlighting where a tile's ID can be seen\">\n"
"  <figcaption>\n"
"    The ID is displayed in hexadecimal without a prefix, so this is tile number $10, aka 16.\n"
"    As you may have noticed, the tiles are displayed in rows of 16, so it's easier to locate them by hexadecimal ID.\n"
"    Nifty!\n"
"  </figcaption>\n"
"</figure>"
msgstr "<figure>\n"
"  <img src=\"../assets/img/tile_id.png\" alt=\"Screenshot highlighting where a tile's ID can be seen\">\n"
"  <figcaption>\n"
"    L'ID √® visualizzato in esadecimale senza prefisso, quindi questa √® la tessera numero 10$, ovvero 16.\n"
"    Come avrete notato, le tessere sono visualizzate in file da 16, cos√¨ √® pi√π facile individuarle in base all'ID esadecimale.\n"
"    Fantastico!\n"
"  </figcaption>\n"
"</figure>"

#: src/part1/tilemap.md:27
msgid "Now, of course, tile IDs are numbers, like everything that computers deal with.\n"
"IDs are stored in bytes, so there are 256 possible tile IDs.\n"
"However, the astute reader will have noticed that there are 384 tiles in total[^tile_blocks]!\n"
"By virtue of the [pigeonhole principle](https://en.wikipedia.org/wiki/Pigeonhole_principle), this means that some IDs refer to several tiles at the same time."
msgstr "Naturalmente gli ID delle tessere sono numeri, come tutti i computer.\n"
"Gli ID sono memorizzati in byte, quindi ci sono 256 possibili ID di piastrelle.\n"
"Tuttavia, il lettore pi√π attento avr√† notato che ci sono 384 tessere in totale[^blocchi_di_tile]!\n"
"In virt√π del [principio della piccionaia](https://en.wikipedia.org/wiki/Pigeonhole_principle), ci√≤ significa che alcuni ID si riferiscono a pi√π piastrelle contemporaneamente."

#: src/part1/tilemap.md:32
msgid "Indeed, Emulicious reports that the first 128 tiles have the same IDs as the last 128.\n"
"There exists a mechanism to select whether IDs 0‚Äì127 reference the first or last 128 tiles, but for simplicity's sake, we will overlook this for now, so please ignore the first (topmost) 128 tiles for the time being."
msgstr ""

#: src/part1/tilemap.md:35
msgid "Now, please turn your attention to Emulicious' Tilemap Viewer, pictured below."
msgstr ""

#: src/part1/tilemap.md:37
msgid "![Screenshot of the tilemap viewer](../assets/img/tilemap_viewer.png)"
msgstr "![Schermata del visualizzatore delle mappe Tiles](../assets/img/tilemap_viewer.png)"

#: src/part1/tilemap.md:41
msgid "You may notice that the image shown is larger than what is displayed on-screen.\n"
"Only part of the tilemap, outlined by a thicker border in the Tilemap Viewer, is displayed on-screen at a given time.\n"
"We will explain this in more detail in Part ‚Ö°."
msgstr ""

#: src/part1/tilemap.md:47
msgid "Here we will be able to see the power of tile reuse in full force.\n"
"As a convenience and a refresher, here are the tiles our Hello World loads into VRAM:"
msgstr "Qui potremo vedere la potenza del riutilizzo dei tile in tutta la sua forza.\n"
"Per comodit√† e per rinfrescare la memoria, ecco le tessere che il nostro Hello World carica nella VRAM:"

#: src/part1/tilemap.md:50
msgid "![Enlarged view of the tiles loaded in VRAM](../assets/img/hello_world_tiles.png)"
msgstr "![Vista ingrandita delle tessere caricate nella VRAM](../assets/img/hello_world_tiles.png)"

#: src/part1/tilemap.md:52
msgid "You can see that we only loaded a single \"blank\" tile ($00, the first aka. top-left one), but it can be repeated to cover the whole background at no extra cost!"
msgstr "Si pu√≤ notare che abbiamo caricato una sola tessera \"vuota\" ($00, la prima a sinistra in alto), ma pu√≤ essere ripetuta per coprire l'intero sfondo senza costi aggiuntivi!"

#: src/part1/tilemap.md:54
msgid "Repetition can be more subtle: for example, tile $01 is used for the top-left corner of the H, E, L, L, and W (red lines below)!\n"
"The R, L, and D also both share their top-left tile ($2D, blue lines below); and so on.\n"
"You can confirm this by hovering over tiles in the BG map tab, which shows the ID of the tile at that position."
msgstr "La ripetizione pu√≤ essere pi√π sottile: ad esempio, la tessera $01 √® utilizzata per l'angolo superiore sinistro di H, E, L, L e W (linee rosse in basso)!\n"
"Anche la R, la L e la D condividono la loro tessera in alto a sinistra ($2D, linee blu in basso); e cos√¨ via.\n"
"√à possibile confermarlo passando il mouse sulle tessere nella scheda BG map, che mostra l'ID della tessera in quella posizione."

#: src/part1/tilemap.md:58
msgid "<figure>\n"
"  <img src=\"../assets/img/hello_world_mappings.svg\" alt=\"Diagram of some tile mappings\">\n"
"  <figcaption>\n"
"    Here are some examples of tile reuse. Not everything is drawn, as it would become a mess.\n"
"  </figcaption>\n"
"</figure>"
msgstr "<figure>\n"
"  <img src=\"../assets/img/hello_world_mappings.svg\" alt=\"Diagram of some tile mappings\">\n"
"  <figcaption>\n"
"    Ecco alcuni esempi di riutilizzo delle tessere. Non tutto √® disegnato, perch√© diventerebbe un pasticcio.\n"
"  </figcaption>\n"
"</figure>"

#: src/part1/tilemap.md:65
msgid "All in all, we can surmise that displaying graphics on the Game Boy consists of loading \"patterns\" (the tiles), and then telling the console which tile to display for each given location."
msgstr "Tutto sommato, possiamo dedurre che la visualizzazione della grafica sul Game Boy consiste nel caricare i \"modelli\" (le tessere) e nel dire alla console quale tessera visualizzare per ciascuna posizione."

#: src/part1/tilemap.md:69
msgid "[^tile_blocks]:\n"
"The even more astute (astuter?) reader will have noticed that 384 = 3 √ó 128.\n"
"Thus, tiles are often conceptually grouped into three \"blocks\" of 128 tiles each, which Emulicious shows as separated by thicker horizontal lines."
msgstr ""

#: src/part1/wrapup.md:1
msgid "# Wrapping up"
msgstr "# In conclusione"

#: src/part1/wrapup.md:3
msgid "Congrats!\n"
"You have made it through the first part of this tutorial.\n"
"By this point, you have a basic enough understanding of the console that you know how to display a picture.\n"
"And hey, that doesn't sound like much, but consider everything you have seen so far‚Äîthere *is* a lot that goes into it!"
msgstr "Congratulazioni!\n"
"Avete superato la prima parte di questa guida.\n"
"A questo punto, avete una conoscenza di base della console tale da sapere come visualizzare un'immagine.\n"
"Non sembra molto, ma considerate tutto ci√≤ che avete visto finora: c'√® stato molto da fare!"

#: src/part1/wrapup.md:8
msgid "::: tip:ü•≥"
msgstr ""

#: src/part1/wrapup.md:10
msgid "Honestly, congrats on coming this far‚Äîmany people have given up earlier than this.\n"
"So you can give yourself a pat on the back, you honestly deserve it!\n"
"**Now may also be a good time to take a break** if you are reading all this in a single trait.\n"
"I encourage you to give it a little time to sink in, and maybe go back to the lessons you struggled on the most.\n"
"Maybe a second read can help."
msgstr "Sinceramente, congratulazioni per essere arrivati fino a questo punto: molte persone si sono arrese prima.\n"
"Quindi potete darvi una pacca sulla spalla, ve la meritate davvero!\n"
"Se state leggendo tutto questo in un solo tratto, **potrebbe essere un buon momento per fare una pausa**.\n"
"Vi incoraggio a dare un po' di tempo per assimilare il tutto e magari a tornare alle lezioni su cui avete fatto pi√π fatica.\n"
"Forse una seconda lettura pu√≤ aiutarvi."

#: src/part1/wrapup.md:20
msgid "And yes, you could simply have let a library handle all that.\n"
"However, the details always leak through eventually, so knowing about them is helpful, if only for debugging."
msgstr "E s√¨, si poteva semplicemente lasciare che fosse una libreria a gestire tutto questo.\n"
"Tuttavia, i dettagli trapelano sempre alla fine, quindi conoscerli √® utile, anche solo per il debug."

#: src/part1/wrapup.md:23
msgid "Plus, understanding what's really going on under the hood makes you a better programmer, even if you don't end up using ASM in the long run.\n"
"Amusingly, even modern systems work similarly to older ones in unexpected places, so some things you just learned will carry over!\n"
"Trust me, everything you have learned and will learn is worth it! ‚úä"
msgstr "Inoltre, capire cosa succede davvero sotto il cofano vi render√† programmatori migliori, anche se alla fine non userete ASM.\n"
"√à divertente notare che anche i sistemi moderni funzionano in modo simile a quelli pi√π vecchi in punti inaspettati, quindi alcune cose che avete appena imparato si ripeteranno!\n"
"Fidatevi, tutto ci√≤ che avete imparato e imparerete ne vale la pena! ‚úä"

#: src/part1/wrapup.md:27
msgid "That said, right now, you may have a lot of questions.\n"
"- Why do we turn off the LCD?\n"
"- We know how to make a static picture, but how to we add motion into the mix?\n"
"- Also, how do I get input from the player?\n"
"- The code mentions shutting down audio, but how do I play some of those famed beeps and bloops?\n"
"- Writing graphics in that way sound tedious, is there no other way?\n"
"- Actually, wait, how do we make a game out of all this??"
msgstr "Detto questo, in questo momento potreste avere molte domande.\n"
"- Perch√© spegnere l'LCD?\n"
"- Sappiamo come creare un'immagine statica, ma come aggiungere il movimento al mix?\n"
"- Inoltre, come si ottiene l'input dal lettore?\n"
"- Il codice menziona l'interruzione dell'audio, ma come faccio a riprodurre alcuni di quei famosi bip e bloop?\n"
"- Scrivere la grafica in questo modo sembra noioso, non c'√® altro modo?\n"
"- Anzi, aspettate, come facciamo a fare un gioco con tutto questo?"

#: src/part1/wrapup.md:35
msgid "... All of that answered, and more, in Part ‚Ö°! üëÄ"
msgstr "... Tutte queste risposte, e altre ancora, nella Parte ‚Ö°! üëÄ"

#: src/part2/getting-started.md:1
msgid "# Getting started"
msgstr "# Come iniziare"

#: src/part2/getting-started.md:3
msgid "In this lesson, we will start a new project from scratch.\n"
"We will make a [Breakout](https://en.wikipedia.org/wiki/Breakout_%28video_game%29) / [Arkanoid](https://en.wikipedia.org/wiki/Arkanoid) clone, which we'll call \"Unbricked\"!\n"
"(Though you are free to give it any other name you like, as it will be *your* project.)"
msgstr "In questa lezione inizieremo un nuovo progetto da zero.\n"
"Creeremo un clone di [Breakout](https://en.wikipedia.org/wiki/Breakout_%28video_game%29) / [Arkanoid](https://en.wikipedia.org/wiki/Arkanoid), che chiameremo \"Unbricked\"!\n"
"(Anche se siete liberi di dargli qualsiasi altro nome, perch√© sar√† il *vostro* progetto)."

#: src/part2/getting-started.md:7
msgid "Open a terminal and make a new directory (`mkdir unbricked`), and then enter it (`cd unbricked`), just like you did for [\"Hello, world!\"](../part1/hello_world.md)."
msgstr "Aprire un terminale e creare una nuova directory (`mkdir unbricked`), quindi entrarvi (`cd unbricked`), proprio come si √® fatto per [\"Hello, world!\"](../part1/hello_world.md)."

#: src/part2/getting-started.md:9
msgid "Start by creating a file called `main.asm`, and include `hardware.inc` in your code."
msgstr "Si inizia creando un file chiamato `main.asm` e si include `hardware.inc` nel codice."

#: src/part2/getting-started.md:11
msgid "```rgbasm,linenos,start=1\n"
"INCLUDE \"hardware.inc\"\n"
"```\n"
"You may be wondering what purpose `hardware.inc` serves.\n"
"Well, the code we write only really affects the CPU, but does not do anything with the rest of the console (not directly, anyway).\n"
"To interact with other components (like the graphics system, say), [Memory-Mapped <abbr title=\"Input/Output\">I/O</abbr>](https://en.wikipedia.org/wiki/Memory-mapped_I/O) (MMIO) is used: basically, [memory](../part1/memory.md) in a certain range (addresses $FF00‚ÄìFF7F) does special things when accessed."
msgstr "``rgbasm,linenos,start=1\n"
"INCLUDE \"hardware.inc\"\n"
"```\n"
"Vi starete chiedendo a cosa serva `hardware.inc`.\n"
"Beh, il codice che scriviamo influisce solo sulla CPU, ma non fa nulla con il resto della console (non direttamente, comunque).\n"
"Per interagire con altri componenti (come il sistema grafico, per esempio), si usa [Memory-Mapped <abbr title=\"Input/Output\">I/O</abbr>](https://en.wikipedia.org/wiki/Memory-mapped_I/O) (MMIO): in pratica, [memory](../part1/memory.md) in un certo intervallo (indirizzi $FF00-FF7F) fa cose speciali quando vi si accede."

#: src/part2/getting-started.md:18
msgid "These bytes of memory being interfaces to the hardware, they are called *hardware registers* (not to be mistaken with [the CPU registers](../part1/registers.md)).\n"
"For example, the \"PPU status\" register is located at address $FF41.\n"
"Reading from that address reports various bits of info regarding the graphics system, and writing to it allows changing some parameters.\n"
"But, having to remember all the numbers ([non-exhaustive list](https://gbdev.io/pandocs/Power_Up_Sequence.html#hardware-registers)) would be very tedious‚Äîand this is where `hardware.inc` comes into play!\n"
"`hardware.inc` defines one constant for each of these registers (for example, `rSTAT` for the aforementioned \"PPU status\" register), plus some additional constants for values read from or written to these registers."
msgstr "Essendo questi byte di memoria interfacce per l'hardware, sono chiamati *registri hardware* (da non confondere con [i registri della CPU](../part1/registers.md)).\n"
"Ad esempio, il registro \"stato PPU\" si trova all'indirizzo $FF41.\n"
"La lettura di questo indirizzo riporta varie informazioni sul sistema grafico e la scrittura consente di modificare alcuni parametri.\n"
"Ma dover ricordare tutti i numeri ([elenco non esaustivo](https://gbdev.io/pandocs/Power_Up_Sequence.html#hardware-registers)) sarebbe molto noioso, ed √® qui che entra in gioco `hardware.inc`!\n"
"`hardware.inc` definisce una costante per ciascuno di questi registri (per esempio, `rSTAT` per il gi√† citato registro \"stato della PPU\"), pi√π alcune costanti aggiuntive per i valori letti o scritti in questi registri."

#: src/part2/getting-started.md:26
msgid "Don't worry if this flew over your head, we'll see an example below with `rLCDC` and `LCDCF_ON`."
msgstr "Non preoccupatevi se tutto questo vi √® sfuggito di mano: di seguito vedremo un esempio con `rLCDC` e `LCDCF_ON`."

#: src/part2/getting-started.md:28
msgid "By the way, the `r` stands for \"register\", and the `F` in `LCDCF` stands for \"flag\"."
msgstr "A proposito, la `r` sta per \"registro\" e la `F` in `LCDCF` sta per \"flag\"."

#: src/part2/getting-started.md:32
msgid "Next, make room for the header.\n"
"[Remember from Part ‚Ö†](../part1/header.md) that the header is where some information that the Game Boy relies on is stored, so you don't want to accidentally leave it out."
msgstr "Quindi, fare spazio per l'intestazione.\n"
"[Ricordiamo dalla Parte ‚Ö†](../part1/header.md) che l'intestazione √® il luogo in cui vengono memorizzate alcune informazioni su cui il Game Boy fa affidamento, quindi non bisogna lasciarla fuori per sbaglio."

#: src/part2/getting-started.md:43
msgid "The header jumps to `EntryPoint`, so let's write that now:"
msgstr "L'intestazione salta a `EntryPoint`, quindi scriviamola ora:"

#: src/part2/getting-started.md:45
msgid "```rgbasm,linenos,start=9\n"
"EntryPoint:\n"
"\t; Do not turn the LCD off outside of VBlank\n"
"WaitVBlank:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp c, WaitVBlank"
msgstr "``rgbasm,linenos,start=9\n"
"EntryPoint:\n"
"\t; Non spegnere l'LCD al di fuori di VBlank\n"
"WaitVBlank:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp c, WaitVBlank"

#: src/part2/getting-started.md:53
msgid "\t; Turn the LCD off\n"
"\tld a, 0\n"
"\tld [rLCDC], a\n"
"```"
msgstr "\t; Spegnere l'LCD\n"
"\tld a, 0\n"
"\tld [rLCDC], a\n"
"````"

#: src/part2/getting-started.md:58
msgid "The next few lines wait until \"VBlank\", which is the only time you can safely turn off the screen (doing so at the wrong time could damage a real Game Boy, so this is very crucial).\n"
"We'll explain what VBlank is and talk about it more later in the tutorial."
msgstr "Le righe successive attendono fino a \"VBlank\", che √® l'unico momento in cui √® possibile spegnere lo schermo in modo sicuro (farlo nel momento sbagliato potrebbe danneggiare un vero Game Boy, quindi √® molto importante).\n"
"Spiegheremo cos'√® il VBlank e ne parleremo pi√π avanti nel corso dell'esercitazione."

#: src/part2/getting-started.md:61
msgid "Turning off the screen is important because loading new tiles while the screen is on is tricky‚Äîwe'll touch on how to do that in Part 3."
msgstr "Spegnere lo schermo √® importante perch√© il caricamento di nuove tessere a schermo acceso √® complicato, come vedremo nella terza parte."

#: src/part2/getting-started.md:63
msgid "Speaking of tiles, we're going to load some into VRAM next, using the following code:"
msgstr "A proposito di tessere, ora ne caricheremo alcune nella VRAM, utilizzando il seguente codice:"

#: src/part2/getting-started.md:65
#: src/part2/functions.md:41
msgid "```rgbasm,linenos,start=20\n"
"\t; Copy the tile data\n"
"\tld de, Tiles\n"
"\tld hl, $9000\n"
"\tld bc, TilesEnd - Tiles\n"
"CopyTiles:\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"\tinc de\n"
"\tdec bc\n"
"\tld a, b\n"
"\tor a, c\n"
"\tjp nz, CopyTiles\n"
"```"
msgstr "``rgbasm,linenos,start=20\n"
"\t; Copia i dati delle tessere\n"
"\tld de, Tiles\n"
"\tld hl, $9000\n"
"\tld bc, TilesEnd - Tiles\n"
"CopyTiles:\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"\tinc de\n"
"\tdec bc\n"
"\tld a, b\n"
"\tor a, c\n"
"\tjp nz, CopyTiles\n"
"````"

#: src/part2/getting-started.md:80
msgid "This loop might be [reminiscent of part ‚Ö†](../part1/jumps.md#conditional-jumps).\n"
"It copies starting at `Tiles` to `$9000` onwards, which is the part of VRAM where our [tiles](../part1/tiles.md) are going to be stored.\n"
"Recall that `$9000` is where the data of background tile $00 lies, and the data of subsequent tiles follows right after.\n"
"To get the number of bytes to copy, we will do just like in Part ‚Ö†: using another label at the end, called `TilesEnd`, the difference between it (= the address after the last byte of tile data) and `Tiles` (= the address of the first byte) will be exactly that length."
msgstr "Questo ciclo potrebbe essere [che ricorda la parte ‚Ö†](../part1/jumps.md#conditional-jumps).\n"
"Copia a partire da `Tiles` fino a `$9000`, che √® la parte di VRAM in cui verr√† memorizzato il nostro [tiles](../part1/tiles.md).\n"
"Ricordiamo che `$9000` √® il luogo in cui si trovano i dati del tile di sfondo $00, e i dati dei tile successivi seguono subito dopo.\n"
"Per ottenere il numero di byte da copiare, faremo come nella parte ‚Ö†: usando un'altra etichetta alla fine, chiamata `TilesEnd`, la differenza tra questa (= l'indirizzo dopo l'ultimo byte dei dati delle tile) e `Tiles` (= l'indirizzo del primo byte) sar√† esattamente quella lunghezza."

#: src/part2/getting-started.md:85
msgid "That said, we haven't written `Tiles` nor any of the related data yet.\n"
"We'll get to that later!"
msgstr "Detto questo, non abbiamo ancora scritto `Tiles` n√© i relativi dati.\n"
"Ci arriveremo pi√π tardi!"

#: src/part2/getting-started.md:88
msgid "Almost done now‚Äînext, write another loop, this time for copying [the tilemap](../part1/tilemap.md)."
msgstr "Quasi finito ora - il prossimo, scrivere un altro ciclo, questa volta per copiare [la mappa delle piastrelle](../part1/tilemap.md)."

#: src/part2/getting-started.md:90
#: src/part2/functions.md:68
msgid "```rgbasm,linenos,start=33\n"
"\t; Copy the tilemap\n"
"\tld de, Tilemap\n"
"\tld hl, $9800\n"
"\tld bc, TilemapEnd - Tilemap\n"
"CopyTilemap:\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"\tinc de\n"
"\tdec bc\n"
"\tld a, b\n"
"\tor a, c\n"
"\tjp nz, CopyTilemap\n"
"```"
msgstr "``rgbasm,linenos,start=33\n"
"\t; Copia la tilemap\n"
"\tld de, Tilemap\n"
"\tld hl, $9800\n"
"\tld bc, TilemapEnd - Tilemap\n"
"CopyTilemap:\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"\tinc de\n"
"\tdec bc\n"
"\tld a, b\n"
"\to a, c\n"
"\tjp nz, CopyTilemap\n"
"````"

#: src/part2/getting-started.md:105
msgid "Note that while this loop's body is exactly the same as `CopyTiles`'s, the 3 values loaded into `de`, `hl`, and `bc` are different.\n"
"These determine the source, destination, and size of the copy, respectively."
msgstr "Si noti che, mentre il corpo di questo ciclo √® esattamente lo stesso di `CopyTiles`, i 3 valori caricati in `de`, `hl` e `bc` sono diversi.\n"
"Questi determinano rispettivamente l'origine, la destinazione e la dimensione della copia."

#: src/part2/getting-started.md:108
msgid "::: tip \"[<abbr title=\"Don't Repeat Yourself\">DRY</abbr>](https://en.wikipedia.org/wiki/Don't_Repeat_Yourself)\""
msgstr "::: suggerimento \"[<abbr title=\"Don't Repeat Yourself\">DRY</abbr>](https://en.wikipedia.org/wiki/Don't_Repeat_Yourself)\"."

#: src/part2/getting-started.md:110
msgid "If you think that this is super redundant, you are not wrong, and we will see later how to write actual, reusable *functions*.\n"
"But there is more to them than meets the eye, so we will start tackling them much later."
msgstr "Se pensate che tutto ci√≤ sia superfluo, non avete torto: vedremo pi√π avanti come scrivere delle vere e proprie *funzioni* riutilizzabili.\n"
"Ma c'√® molto di pi√π di quello che sembra, quindi inizieremo ad affrontarle molto pi√π avanti."

#: src/part2/getting-started.md:115
msgid "Finally, let's turn the screen back on, and set a [background palette](../part1/palettes.md).\n"
"Rather than writing the non-descript number `%10000001` (or $81 or 129, to taste), we make use of two constants graciously provided by `hardware.inc`: `LCDCF_ON` and `LCDCF_BGON`.\n"
"When written to [`rLCDC`](https://gbdev.io/pandocs/LCDC), the former causes the PPU and screen to turn back on, and the latter enables the background to be drawn.\n"
"(There are other elements that could be drawn, but we are not enabling them yet.)\n"
"Combining these constants must be done using `|`, the *binary \"or\"* operator; we'll see why later."
msgstr "Infine, riaccendiamo lo schermo e impostiamo una [palette di sfondo](../part1/palettes.md).\n"
"Invece di scrivere il numero non descritto `%10000001` (o $81 o 129, a seconda dei gusti), usiamo due costanti gentilmente fornite da `hardware.inc`: `LCDCF_ON` e `LCDCF_BGON`.\n"
"Quando vengono scritte su [`rLCDC`](https://gbdev.io/pandocs/LCDC), la prima fa s√¨ che la PPU e lo schermo si riaccendano, mentre la seconda permette di disegnare lo sfondo.\n"
"(Ci sono altri elementi che potrebbero essere disegnati, ma non li abilitiamo ancora).\n"
"La combinazione di queste costanti deve essere fatta usando `|`, l'operatore *binario \"o \"*; vedremo perch√© pi√π avanti."

#: src/part2/getting-started.md:121
msgid "```rgbasm,linenos,start=46\n"
"\t; Turn the LCD on\n"
"\tld a, LCDCF_ON | LCDCF_BGON\n"
"\tld [rLCDC], a"
msgstr "``rgbasm,linenos,start=46\n"
"\t; Accendere l'LCD\n"
"\tld a, LCDCF_ON | LCDCF_BGON\n"
"\tld [rLCDC], a"

#: src/part2/getting-started.md:126
msgid "\t; During the first (blank) frame, initialize display registers\n"
"\tld a, %11100100\n"
"\tld [rBGP], a"
msgstr "\tDurante il primo fotogramma (vuoto), inizializzare i registri del display\n"
"\tld a, %11100100\n"
"\tld [rBGP], a"

#: src/part2/getting-started.md:130
msgid "Done:\n"
"\tjp Done\n"
"```"
msgstr "Fatto:\n"
"\tjp Fatto\n"
"````"

#: src/part2/getting-started.md:134
msgid "There's one last thing we need before we can build the ROM, and that's the graphics.\n"
"We will draw the following screen:"
msgstr "C'√® un'ultima cosa di cui abbiamo bisogno prima di costruire la ROM: la grafica.\n"
"Disegneremo la seguente schermata:"

#: src/part2/getting-started.md:137
msgid "![Layout of unbricked](../assets/part2/img/tilemap.png)"
msgstr "![Layout di unbricked](../assets/part2/img/tilemap.png)"

#: src/part2/getting-started.md:139
msgid "In `hello-world.asm`, tile data had been written out by hand in hexadecimal; this was to let you see how the sausage is made at the lowest level, but *boy* is it impractical to write!\n"
"This time, we will employ a more friendly way, which will let us write each row of pixels more easily.\n"
"For each row of pixels, instead of writing [the bitplanes](../part1/tiles.md#encoding) directly, we will use a backtick (`` ` ``) followed by 8 characters.\n"
"Each character defines a single pixel, intuitively from left to right; it must be one of 0, 1, 2, and 3, representing the corresponding color index in [the palette](../part1/palettes.md)."
msgstr "In `hello-world.asm', i dati delle mattonelle erano stati scritti a mano in esadecimale; questo per farvi vedere come viene fatta la salsiccia al livello pi√π basso, ma *ragazzo* √® poco pratico da scrivere!\n"
"Questa volta utilizzeremo un metodo pi√π semplice, che ci permetter√† di scrivere pi√π facilmente ogni riga di pixel.\n"
"Per ogni riga di pixel, invece di scrivere direttamente [i bitplanes](../part1/tiles.md#encoding), useremo un backtick (`` ` ``) seguito da 8 caratteri.\n"
"Ogni carattere definisce un singolo pixel, intuitivamente da sinistra a destra; deve essere uno tra 0, 1, 2 e 3, che rappresenta l'indice di colore corrispondente nella [tavolozza](../part1/palettes.md)."

#: src/part2/getting-started.md:146
msgid "If the character selection isn't to your liking, you can use [RGBASM's `-g` option](https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.1#g) or [`OPT g`](https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.5/#Changing_options_while_assembling) to pick others.\n"
"For example, `rgbasm -g '.xXO' (...)` or `OPT g.xXO` would swap the four characters to `.`, `x`, `X`, and `O` respectively."
msgstr "Se la selezione dei caratteri non √® di vostro gradimento, potete usare [l'opzione `-g` di RGBASM](https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.1#g) o [`OPT g`](https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.5/#Changing_options_while_assembling) per sceglierne altri.\n"
"Per esempio, `rgbasm -g '.xXO' (...)` o `OPT g.xXO` scambiano i quattro caratteri rispettivamente con `.`, `x`, `X` e `O`."

#: src/part2/getting-started.md:151
msgid "For example:"
msgstr "Ad esempio:"

#: src/part2/getting-started.md:153
msgid "```rgbasm\n"
"\tdw `01230123 ; This is equivalent to `db $55,$33`\n"
"```"
msgstr "``rgbasm\n"
"\tdw `01230123 ; Questo √® equivalente a `db $55,$33`\n"
"```"

#: src/part2/getting-started.md:157
msgid "You may have noticed that we are using `dw` instead of `db`; the difference between these two will be explained later.\n"
"We already have tiles made for this project, so you can copy [this premade file](https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tileset.asm), and paste it at the end of your code."
msgstr "Avrete notato che stiamo usando `dw` invece di `db`; la differenza tra questi due elementi sar√† spiegata pi√π avanti.\n"
"Abbiamo gi√† delle piastrelle per questo progetto, quindi potete copiare [questo file premade](https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tileset.asm) e incollarlo alla fine del vostro codice."

#: src/part2/getting-started.md:160
msgid "Then copy the tilemap from [this file](https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tilemap.asm), and paste it after the `TilesEnd` label."
msgstr "Quindi copiare la mappa delle piastrelle da [questo file] (https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tilemap.asm) e incollarla dopo l'etichetta `TilesEnd`."

#: src/part2/getting-started.md:162
msgid "You can build the ROM now, by running the following commands in your terminal:"
msgstr "√à possibile creare la ROM ora, eseguendo i seguenti comandi nel terminale:"

#: src/part2/getting-started.md:164
msgid "```console\n"
"$ rgbasm -L -o main.o main.asm\n"
"$ rgblink -o unbricked.gb main.o\n"
"$ rgbfix -v -p 0xFF unbricked.gb\n"
"```"
msgstr "``console\n"
"$ rgbasm -L -o main.o main.asm\n"
"$ rgblink -o unbricked.gb main.o\n"
"$ rgbfix -v -p 0xFF unbricked.gb\n"
"````"

#: src/part2/getting-started.md:170
msgid "If you run this in your emulator, you should see the following:"
msgstr "Se si esegue questa operazione nell'emulatore, si dovrebbe vedere quanto segue:"

#: src/part2/getting-started.md:172
msgid "![Screenshot of our game](../assets/part2/img/screenshot.png)"
msgstr "![Schermata del nostro gioco](../assets/part2/img/screenshot.png)"

#: src/part2/getting-started.md:174
msgid "That white square seems to be missing!\n"
"You may have noticed this comment earlier, somewhere in the tile data:"
msgstr "Quel quadrato bianco sembra essere scomparso!\n"
"Forse avete notato questo commento in precedenza, da qualche parte nei dati delle piastrelle:"

#: src/part2/getting-started.md:177
msgid "```rgbasm,linenos,start=135\n"
"\tdw `22322232\n"
"\tdw `23232323\n"
"\tdw `33333333\n"
"\t; Paste your logo here:"
msgstr "``rgbasm,linenos,start=135\n"
"\tdw `22322232\n"
"\tdw `23232323\n"
"\tdw `333333\n"
"\t; Incollare qui il proprio logo:"

#: src/part2/getting-started.md:183
msgid "TilesEnd:\n"
"```"
msgstr "TilesEnd:\n"
"````"

#: src/part2/getting-started.md:186
msgid "The logo tiles were left intentionally blank so that you can choose your own.\n"
"You can use one of the following pre-made logos, or try coming up with your own!"
msgstr "Le tessere del logo sono state lasciate intenzionalmente vuote, in modo che possiate scegliere il vostro.\n"
"Potete utilizzare uno dei seguenti loghi gi√† pronti, oppure provare a crearne uno vostro!"

#: src/part2/getting-started.md:189
msgid "- **RGBDS Logo**"
msgstr "- Logo RGBDS**"

#: src/part2/getting-started.md:191
msgid "  ![The RGBDS Logo](../assets/part2/img/rgbds.png)"
msgstr "  ![Il logo di RGBDS](../assets/part2/img/rgbds.png)"

#: src/part2/getting-started.md:193
msgid "  [Source](https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/rgbds.asm)"
msgstr "  [Source](https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/rgbds.asm)"

#: src/part2/getting-started.md:195
msgid "- **Duck**"
msgstr "- **Anatra**"

#: src/part2/getting-started.md:197
msgid "  ![A pixel-art duck](../assets/part2/img/duck.png)"
msgstr "  ![Un'anatra in pixel-art](../assets/part2/img/duck.png)"

#: src/part2/getting-started.md:199
msgid "  [Source](https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/duck.asm)"
msgstr "  [Source](https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/duck.asm)"

#: src/part2/getting-started.md:201
msgid "- **Tail**"
msgstr "- **Coda**"

#: src/part2/getting-started.md:203
msgid "  ![A silhouette of a tail](../assets/part2/img/tail.png)"
msgstr "  ![Sagoma di una coda](../assets/part2/img/tail.png)"

#: src/part2/getting-started.md:205
msgid "  [Source](https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tail.asm)"
msgstr "  [Source](https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tail.asm)"

#: src/part2/getting-started.md:207
msgid "Add your chosen logo's data (click one of the \"Source\" links above) after the comment, build the game again, and you should see your logo of choice in the bottom-right!"
msgstr "Aggiungete i dati del logo scelto (cliccate su uno dei link \"Source\" qui sopra) dopo il commento, create di nuovo il gioco e dovreste vedere il logo scelto in basso a destra!"

#: src/part2/objects.md:1
msgid "# Objects"
msgstr "# Oggetti"

#: src/part2/objects.md:3
msgid "The background is very useful when the whole screen should move at once, but this is not ideal for everything.\n"
"For example, a cursor in a menu, NPCs and the player in a RPG, bullets in a shmup, or balls in an *Arkanoid* clone... all need to move independently of the background.\n"
"Thankfully, the Game Boy has a feature that's perfect for these!\n"
"In this lesson, we will talk about *objects* (sometimes called \"OBJ\")."
msgstr "Lo sfondo √® molto utile quando l'intero schermo deve muoversi contemporaneamente, ma non √® l'ideale per tutto.\n"
"Ad esempio, il cursore in un menu, i PNG e il giocatore in un RPG, i proiettili in uno shmup o le palline in un clone di *Arkanoid*... devono tutti muoversi indipendentemente dallo sfondo.\n"
"Fortunatamente, il Game Boy ha una funzione perfetta per queste situazioni!\n"
"In questa lezione parleremo di *oggetti* (talvolta chiamati \"OBJ\")."

#: src/part2/objects.md:10
msgid "The above description may have made you think of the term \"sprite\" instead of \"object\".\n"
"The term \"sprite\" has a *lot* of meanings depending on context, so, to avoid confusion, this tutorial tries to use specific alternatives instead, such as *object*, *metasprite*, *actor*, etc."
msgstr "La descrizione precedente potrebbe avervi fatto pensare al termine \"sprite\" invece che a \"oggetto\".\n"
"Il termine \"sprite\" ha *molti* significati a seconda del contesto, quindi, per evitare confusione, questo tutorial cerca di usare alternative specifiche, come *oggetto*, *metasprite*, *attore*, ecc."

#: src/part2/objects.md:15
msgid "Each object allows drawing one or two tiles (so 8√ó8 or 8√ó16 pixels, respectively) at any on-screen position‚Äîunlike the background, where all the tiles are drawn in a grid.\n"
"Therefore, an object consists of its on-screen position, a tile ID (like [with the tilemap](../part1/tilemap.md)), and some extra properties called \"attributes\".\n"
"These extra properties allow, for example, to display the tile flipped.\n"
"We'll see more about them later."
msgstr "Ogni oggetto permette di disegnare una o due piastrelle (rispettivamente 8√ó8 o 8√ó16 pixel) in qualsiasi posizione sullo schermo, a differenza dello sfondo, dove tutte le piastrelle sono disegnate in una griglia.\n"
"Pertanto, un oggetto √® composto dalla sua posizione sullo schermo, da un ID tile (come [con la tilemap](../part1/tilemap.md)) e da alcune propriet√† extra chiamate \"attributi\".\n"
"Queste propriet√† extra consentono, ad esempio, di visualizzare la piastrella capovolta.\n"
"Ne parleremo pi√π avanti."

#: src/part2/objects.md:20
msgid "Just like how the tilemap is stored in VRAM, objects live in a region of memory called OAM, meaning **Object Attribute Memory**.\n"
"Recall from above that an object consists of:\n"
"- Its on-screen position\n"
"- A tile ID\n"
"- The \"attributes\""
msgstr "Proprio come la tilemap √® memorizzata nella VRAM, gli oggetti vivono in una regione di memoria chiamata OAM, ovvero **Object Attribute Memory**.\n"
"Ricordiamo che un oggetto √® composto da:\n"
"- La sua posizione sullo schermo\n"
"- Un ID tile\n"
"- Gli \"attributi\""

#: src/part2/objects.md:26
msgid "These are stored in 4 bytes: one for the Y coordinate, one for the X coordinate, one for the tile ID, and one for the attributes.\n"
"OAM is 160 bytes long, and since 160 ‚àï 4 = 40, the Game Boy stores a total of **40** objects at any given time."
msgstr "Questi sono memorizzati in 4 byte: uno per la coordinata Y, uno per la coordinata X, uno per l'ID della piastrella e uno per gli attributi.\n"
"L'OAM √® lungo 160 byte e poich√© 160 ‚àï 4 = 40, il Game Boy memorizza un totale di **40** oggetti in qualsiasi momento."

#: src/part2/objects.md:29
msgid "There is a catch, though: an object's Y and X coordinate bytes in OAM do *not* store its on-screen position!\n"
"Instead, the *on-screen* X position is the *stored* X position **minus 8**, and the *on-screen* Y position is the *stored* Y position **minus 16**.\n"
"To stop displaying an object, we can simply put it off-screen, e.g. by setting its Y position to 0."
msgstr "C'√® per√≤ un problema: i byte delle coordinate Y e X di un oggetto in OAM non memorizzano la sua posizione sullo schermo!\n"
"Invece, la posizione X *sullo schermo* √® la posizione X *memorizzata* **meno 8**, e la posizione Y *sullo schermo* √® la posizione Y *memorizzata* **meno 16**.\n"
"Per interrompere la visualizzazione di un oggetto, √® sufficiente metterlo fuori dallo schermo, ad esempio impostando la sua posizione Y a 0."

#: src/part2/objects.md:35
msgid "These offsets are not arbitrary!\n"
"Consider an object's maximum size: 8 by 16 pixels.\n"
"These offsets allow objects to be clipped by the left and top edges of the screen.\n"
"The NES, for example, lacks such offsets, so you will notice that objects always disappear after hitting the left or top edge of the screen."
msgstr "Questi offset non sono arbitrari!\n"
"Si consideri la dimensione massima di un oggetto: 8 x 16 pixel.\n"
"Questi offset consentono agli oggetti di essere tagliati dai bordi sinistro e superiore dello schermo.\n"
"Il NES, ad esempio, non dispone di tali offset, per cui si noter√† che gli oggetti scompaiono sempre dopo aver toccato il bordo sinistro o superiore dello schermo."

#: src/part2/objects.md:42
msgid "Let's discover objects by experimenting with them!"
msgstr "Scopriamo gli oggetti sperimentandoli!"

#: src/part2/objects.md:44
msgid "First off, when the Game Boy is powered on, OAM is filled with a bunch of semi-random values, which may cover the screen with some random garbage.\n"
"Let's fix that by first clearing OAM before enabling objects for the first time.\n"
"Let's add the following just after the `CopyTilemap` loop:"
msgstr "Innanzitutto, all'accensione del Game Boy, l'OAM si riempie di valori semicasuali, che possono coprire lo schermo di spazzatura casuale.\n"
"Risolviamo questo problema cancellando l'OAM prima di attivare gli oggetti per la prima volta.\n"
"Aggiungiamo quanto segue subito dopo il ciclo `CopyTilemap`:"

#: src/part2/objects.md:48
msgid "```rgbasm\n"
"\tld a, 0\n"
"\tld b, 160\n"
"\tld hl, _OAMRAM\n"
"ClearOam:\n"
"\tld [hli], a\n"
"\tdec b\n"
"\tjp nz, ClearOam\n"
"```"
msgstr "``rgbasm\n"
"\tld a, 0\n"
"\tld b, 160\n"
"\tld hl, _OAMRAM\n"
"ClearOam:\n"
"\tld [hli], a\n"
"\tdec b\n"
"\tjp nz, ClearOam\n"
"````"

#: src/part2/objects.md:58
msgid "This is a good time to do that, since just like VRAM, the screen must be off to safely access OAM."
msgstr "Questo √® un buon momento per farlo, poich√© proprio come la VRAM, lo schermo deve essere spento per accedere in modo sicuro alla OAM."

#: src/part2/objects.md:60
msgid "Once OAM is clear, we can draw an object by writing its properties."
msgstr "Una volta che l'OAM √® svuotato, possiamo disegnare un oggetto scrivendo le sue propriet√†."

#: src/part2/objects.md:62
msgid "```rgbasm,linenos,start=67\n"
"\tld hl, _OAMRAM\n"
"\tld a, 128 + 16\n"
"\tld [hli], a\n"
"\tld a, 16 + 8\n"
"\tld [hli], a\n"
"\tld a, 0\n"
"\tld [hli], a\n"
"\tld [hl], a\n"
"```"
msgstr "``rgbasm,linenos,start=67\n"
"\tld hl, _OAMRAM\n"
"\tld a, 128 + 16\n"
"\tld [hli], a\n"
"\tld a, 16 + 8\n"
"\tld [hli], a\n"
"\tld a, 0\n"
"\tld [hli], a\n"
"\tld [hl], a\n"
"```"

#: src/part2/objects.md:73
msgid "Remember that each object in OAM is 4 bytes, in the order Y, X, Tile ID, Attributes.\n"
"So, the object's top-left pixel lies 128 pixels from the top of the screen, and 16 from its left.\n"
"The tile ID and attributes are both set to 0."
msgstr "Si ricordi che ogni oggetto in OAM √® composto da 4 byte, nell'ordine Y, X, Tile ID, Attributi.\n"
"Quindi, il pixel in alto a sinistra dell'oggetto si trova a 128 pixel dalla parte superiore dello schermo e a 16 da quella sinistra.\n"
"L'ID tessera e gli attributi sono entrambi impostati a 0."

#: src/part2/objects.md:77
msgid "You may remember from the previous lesson that we're already using tile ID 0, as it's the start of our background's graphics.\n"
"However, by default objects and backgrounds use a different set of tiles, at least for the first 128 IDs.\n"
"Tiles with IDs 128‚Äì255 are shared by both, which is useful if you have a tile that's used both on the background and by an object."
msgstr "Come si ricorder√† dalla lezione precedente, stiamo gi√† usando l'ID 0, che √® l'inizio della grafica del nostro sfondo.\n"
"Tuttavia, per impostazione predefinita, gli oggetti e gli sfondi utilizzano un insieme diverso di piastrelle, almeno per i primi 128 ID.\n"
"Le mattonelle con ID 128-255 sono condivise da entrambi, il che √® utile se si ha una mattonella che viene utilizzata sia dallo sfondo che da un oggetto."

#: src/part2/objects.md:81
msgid "If you go to \"Tools\", then \"Tile Viewer\" in Emulicious' debugger, you should see three distinct sections."
msgstr ""

#: src/part2/objects.md:83
msgid "![image](../assets/img/vram_viewer.png)"
msgstr "![image](../assets/img/vram_viewer.png)"

#: src/part2/objects.md:85
msgid "Because we need to load this to a different area, we'll use the address $8000 and load a graphic for our game's paddle.\n"
"Let's do so right after `CopyTilemap`:"
msgstr "Poich√© dobbiamo caricarla in un'area diversa, useremo l'indirizzo $8000 e caricheremo una grafica per la paletta del gioco.\n"
"Lo faremo subito dopo `CopyTilemap`:"

#: src/part2/objects.md:88
#: src/part2/functions.md:95
msgid "```rgbasm,linenos,start=46\n"
"\t; Copy the tile data\n"
"\tld de, Paddle\n"
"\tld hl, $8000\n"
"\tld bc, PaddleEnd - Paddle\n"
"CopyPaddle:\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"\tinc de\n"
"\tdec bc\n"
"\tld a, b\n"
"\tor a, c\n"
"\tjp nz, CopyPaddle\n"
"```"
msgstr "``rgbasm,linenos,start=46\n"
"\t; Copia i dati della piastrella\n"
"\tld de, Paddle\n"
"\tld hl, $8000\n"
"\tld bc, PaddleEnd - Paddle\n"
"CopyPaddle:\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"\tinc de\n"
"\tdec bc\n"
"\tld a, b\n"
"\tor a, c\n"
"\tjp nz, CopyPaddle\n"
"````"

#: src/part2/objects.md:103
msgid "And don't forget to add `Paddle` to the bottom of your code."
msgstr "E non dimenticate di aggiungere `Paddle` alla fine del codice."

#: src/part2/objects.md:105
msgid "```rgbasm\n"
"Paddle:\n"
"\tdw `13333331\n"
"\tdw `30000003\n"
"\tdw `13333331\n"
"\tdw `00000000\n"
"\tdw `00000000\n"
"\tdw `00000000\n"
"\tdw `00000000\n"
"\tdw `00000000\n"
"PaddleEnd:\n"
"```"
msgstr "``rgbasm\n"
"Paddle:\n"
"\tdw `13333331\n"
"\tdw `30000003\n"
"\tdw `13333331\n"
"\tdw `00000000\n"
"\tdw `00000000\n"
"\tdw `00000000\n"
"\tdw `00000000\n"
"\tdw `00000000\n"
"PaddleEnd:\n"
"````"

#: src/part2/objects.md:118
msgid "Finally, let's enable objects and see the result.\n"
"Objects must be enabled by the familiar `rLCDC` register, otherwise they just don't show up.\n"
"(This is why we didn't have to clear OAM in the previous lessons.)\n"
"We will also need to initialize one of the object palettes, `rOBP0`.\n"
"There are actually two object palettes, but we're only going to use one."
msgstr "Infine, abilitiamo gli oggetti e vediamo il risultato.\n"
"Gli oggetti devono essere abilitati dal noto registro `rLCDC`, altrimenti non vengono visualizzati.\n"
"(Questo √® il motivo per cui non abbiamo dovuto cancellare l'OAM nelle lezioni precedenti).\n"
"Dobbiamo anche inizializzare una delle tavolozze degli oggetti, `rOBP0`.\n"
"In realt√† ci sono due tavolozze di oggetti, ma ne useremo solo una."

#: src/part2/objects.md:124
msgid "```rgbasm,linenos,start=76\n"
"\t; Turn the LCD on\n"
"\tld a, LCDCF_ON | LCDCF_BGON | LCDCF_OBJON\n"
"\tld [rLCDC], a"
msgstr "``rgbasm,linenos,start=76\n"
"\t; Accendere lo schermo LCD\n"
"\tld a, LCDCF_ON | LCDCF_BGON | LCDCF_OBJON\n"
"\tld [rLCDC], a"

#: src/part2/objects.md:129
msgid "\t; During the first (blank) frame, initialize display registers\n"
"\tld a, %11100100\n"
"\tld [rBGP], a\n"
"\tld a, %11100100\n"
"\tld [rOBP0], a\n"
"```"
msgstr "\t; Durante il primo fotogramma (vuoto), inizializzare i registri di visualizzazione\n"
"\tld a, %11100100\n"
"\tld [rBGP], a\n"
"\tld a, %11100100\n"
"\tld [rOBP0], a\n"
"```"

#: src/part2/objects.md:136
msgid "## Movement"
msgstr "## Movimento"

#: src/part2/objects.md:138
msgid "Now that you have an object on the screen, let's move it around.\n"
"Previously, the `Done` loop did nothing; let's rename it to `Main` and use it to move our object.\n"
"We're going to wait for VBlank before changing OAM, just like we did before turning off the screen."
msgstr "Ora che abbiamo un oggetto sullo schermo, spostiamolo.\n"
"In precedenza, il ciclo `Done` non faceva nulla; rinominiamolo in `Main` e usiamolo per spostare il nostro oggetto.\n"
"Aspetteremo il VBlank prima di cambiare OAM, proprio come abbiamo fatto prima di spegnere lo schermo."

#: src/part2/objects.md:142
msgid "```rgbasm,linenos,start=89\n"
"Main:\n"
"    ; Wait until it's *not* VBlank\n"
"    ld a, [rLY]\n"
"    cp 144\n"
"    jp nc, Main\n"
"WaitVBlank2:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp c, WaitVBlank2"
msgstr "``rgbasm,linenos,start=89\n"
"Main:\n"
"    ; Attendere finch√© non √® *non* VBlank\n"
"    ld a, [rLY]\n"
"    cp 144\n"
"    jp nc, Main\n"
"WaitVBlank2:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp c, WaitVBlank2"

#: src/part2/objects.md:153
#: src/part2/objects.md:209
msgid "\t; Move the paddle one pixel to the right.\n"
"\tld a, [_OAMRAM + 1]\n"
"\tinc a\n"
"\tld [_OAMRAM + 1], a\n"
"\tjp Main\n"
"```"
msgstr "\t; Sposta la paletta di un pixel a destra.\n"
"\tld a, [_OAMRAM + 1]\n"
"\tinc a\n"
"\tld [_OAMRAM + 1], a\n"
"\tjp Main\n"
"````"

#: src/part2/objects.md:160
msgid "::: tip:ü§®"
msgstr ""

#: src/part2/objects.md:162
msgid "Here, we are accessing OAM without turning the LCD off, but it's still safe.\n"
"Explaining why requires a more thorough explanation of the Game Boy's rendering, so let's ignore it for now."
msgstr "In questo caso, si accede all'OAM senza spegnere lo schermo LCD, ma √® comunque sicuro.\n"
"Per spiegarne il motivo √® necessaria una spiegazione pi√π approfondita del rendering del Game Boy, quindi per ora ignoriamolo."

#: src/part2/objects.md:167
msgid "Now you should see the paddle moving... very quickly.\n"
"Because it moves by a pixel every frame, it's going at a speed of 60 pixels per second!\n"
"To slow this down, we'll use a *variable*."
msgstr ""

#: src/part2/objects.md:171
msgid "So far, we have only worked with the CPU registers, but you can create global variables too!\n"
"To do this, let's create another section, but putting it in `WRAM0` instead of `ROM0`.\n"
"Unlike ROM (\"Read-Only Memory\"), RAM (\"Random-Access Memory\") can be written to; thus, WRAM, or Work RAM, is where we can store our game's variables."
msgstr "Finora abbiamo lavorato solo con i registri della CPU, ma √® possibile creare anche variabili globali!\n"
"Per farlo, creiamo un'altra sezione, ma mettiamola in `WRAM0` invece che in `ROM0`.\n"
"A differenza della ROM (\"Read-Only Memory\", memoria di sola lettura), la RAM (\"Random-Access Memory\", memoria ad accesso casuale) pu√≤ essere scritta; quindi, la WRAM, o Work RAM, √® il luogo in cui possiamo memorizzare le variabili del nostro gioco."

#: src/part2/objects.md:175
msgid "Add this to the bottom of your file:"
msgstr "Aggiungete questo in fondo al vostro file:"

#: src/part2/objects.md:177
msgid "```rgbasm,linenos,start=358\n"
"SECTION \"Counter\", WRAM0\n"
"wFrameCounter: db\n"
"```"
msgstr "``rgbasm,linenos,start=358\n"
"SECTION \"Counter\", WRAM0\n"
"wFrameCounter: db\n"
"````"

#: src/part2/objects.md:182
msgid "Now we'll use the `wFrameCounter` variable to count how many frames have passed since we last moved the paddle.\n"
"Every 10th frame, we'll move the paddle by one pixel, slowing it down to 6 pixels per second.\n"
"Don't forget that RAM is filled with garbage values when the Game Boy starts, so we need to initialize our variables before first using them."
msgstr "Ora useremo la variabile `wFrameCounter` per contare quanti fotogrammi sono passati dall'ultimo spostamento della paletta.\n"
"Ogni 10¬∞ fotogramma, sposteremo la racchetta di un pixel, rallentandola a 6 pixel al secondo.\n"
"Non dimenticate che all'avvio del Game Boy la RAM si riempie di valori spazzatura, quindi √® necessario inizializzare le variabili prima di utilizzarle."

#: src/part2/objects.md:186
msgid "```rgbasm,linenos,start=86\n"
"\tld a, 0\n"
"\tld [wFrameCounter], a"
msgstr "``rgbasm,linenos,start=86\n"
"\tld a, 0\n"
"\tld [wFrameCounter], a"

#: src/part2/objects.md:190
msgid "Main:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp nc, Main\n"
"WaitVBlank2:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp c, WaitVBlank2"
msgstr "Main:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp nc, Main\n"
"WaitVBlank2:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp c, WaitVBlank2"

#: src/part2/objects.md:199
msgid "\tld a, [wFrameCounter]\n"
"\tinc a\n"
"\tld [wFrameCounter], a\n"
"\tcp a, 15 ; Every 15 frames (a quarter of a second), run the following code\n"
"\tjp nz, Main"
msgstr "\tld a, [wFrameCounter]\n"
"\tinc a\n"
"\tld [wFrameCounter], a\n"
"\tcp a, 15 ; Ogni 15 fotogrammi (un quarto di secondo), eseguire il seguente codice\n"
"\tjp nz, Main"

#: src/part2/objects.md:205
msgid "\t; Reset the frame counter back to 0\n"
"\tld a, 0\n"
"\tld [wFrameCounter], a"
msgstr "\t; Azzeramento del contatore di frame a 0\n"
"\tld a, 0\n"
"\tld [wFrameCounter], a"

#: src/part2/objects.md:216
msgid "Alright!\n"
"Up next is us taking control of that little paddle."
msgstr "Bene!\n"
"Il prossimo passo √® prendere il controllo della tessera."

#: src/part2/functions.md:1
msgid "# Functions"
msgstr "# Funzioni"

#: src/part2/functions.md:3
msgid "So far, we have only written a single \"flow\" of code, but we can already spot some snippets that look redundant.\n"
"Let's use **functions** to \"factor out\" code!"
msgstr "Finora abbiamo scritto un solo \"flusso\" di codice, ma possiamo gi√† individuare alcuni frammenti che sembrano ridondanti.\n"
"Usiamo le **funzioni** per \"sfoltire\" il codice!"

#: src/part2/functions.md:6
msgid "For example, in three places, we are copying chunks of memory around.\n"
"Let's write a function below the `jp Main`, and let's call it `Memcpy`, like [the similar C function](https://man7.org/linux/man-pages/man3/memcpy.3.html):"
msgstr "Per esempio, in tre punti stiamo copiando pezzi di memoria.\n"
"Scriviamo una funzione sotto la `jp Main` e chiamiamola `Memcpy`, come [l'analoga funzione C](https://man7.org/linux/man-pages/man3/memcpy.3.html):"

#: src/part2/functions.md:9
msgid "```rgbasm,linenos,start=93\n"
"; Copy bytes from one area to another.\n"
"; @param de: Source\n"
"; @param hl: Destination\n"
"; @param bc: Length\n"
"Memcopy:\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"\tinc de\n"
"\tdec bc\n"
"\tld a, b\n"
"\tor a, c\n"
"\tjp nz, Memcopy\n"
"\tret\n"
"```"
msgstr "``rgbasm,linenos,start=93\n"
"; Copia i byte da un'area all'altra.\n"
"; @param de: Sorgente\n"
"; @param hl: Destinazione\n"
"; @param bc: Lunghezza\n"
"Memcopia:\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"\tinc de\n"
"\tdec bc\n"
"\tld a, b\n"
"\to a, c\n"
"\tjp nz, Memcopy\n"
"\tret\n"
"````"

#: src/part2/functions.md:25
msgid "The new `ret` instruction should immediately catch our eye.\n"
"It is, unsurprisingly, what makes execution *return* to where the function was *called* from.\n"
"Importantly, many languages have a definite \"end\" to a function: in C or Rust, that's the closing brace `}`; in Pascal or Lua, the keyword `end`, and so on; the function implicitly returns when execution reaches its end.\n"
"However, **this is not the case in assembly**, so you must remember to add a `ret` instruction at the end of the function to return from it!\n"
"Otherwise, the results are unpredictable."
msgstr "La nuova istruzione `ret' dovrebbe catturare immediatamente l'attenzione.\n"
"√à, senza sorpresa, quella che fa s√¨ che l'esecuzione *ritorni* al punto in cui la funzione √® stata *chiamata*.\n"
"√à importante notare che molti linguaggi prevedono una \"fine\" precisa per una funzione: in C o Rust, √® la parentesi graffa di chiusura `}`; in Pascal o Lua, la parola chiave `end`, e cos√¨ via; la funzione ritorna implicitamente quando l'esecuzione raggiunge la sua fine.\n"
"Tuttavia, **non √® cos√¨ in assembly**, quindi bisogna ricordarsi di aggiungere un'istruzione `ret` alla fine della funzione per ritornare da essa!\n"
"Altrimenti, i risultati sono imprevedibili."

#: src/part2/functions.md:31
msgid "Notice the comment above the function, explaining which registers it takes as input.\n"
"This comment is important so that you know how to interface with the function; assembly has no formal parameters, so comments explaining them are even more important than with other languages.\n"
"We'll see more of those as we progress."
msgstr "Notate il commento sopra la funzione, che spiega quali registri prende in ingresso.\n"
"Questo commento √® importante per sapere come interfacciarsi con la funzione; l'assembly non ha parametri formali, quindi i commenti che li spiegano sono ancora pi√π importanti che in altri linguaggi.\n"
"Ne vedremo altri man mano che procediamo."

#: src/part2/functions.md:35
msgid "There are three places in the initialization code where we can use the `Memcpy` function.\n"
"Find each of these copy loops and replace them with a call to `Memcpy`; for this, we use the `call` instruction.\n"
"The registers serve as parameters to the function, so we'll leave them as-is."
msgstr "Ci sono tre punti nel codice di inizializzazione in cui possiamo usare la funzione `Memcpy`.\n"
"Trovate ognuno di questi cicli di copia e sostituiteli con una chiamata a `Memcpy`; per questo, utilizziamo l'istruzione `call`.\n"
"I registri servono come parametri alla funzione, quindi li lasceremo cos√¨ come sono."

#: src/part2/functions.md:39
msgid "<div class=\"table-wrapper\"><table><thead><tr><th>Before</th><th>After</th></tr></thead><tbody><tr><td>"
msgstr "<div class=\"table-wrapper\"><table><thead><tr><th>Prima di</th><th>Dopo</th></tr></thead><tbody><tr><td>"

#: src/part2/functions.md:56
#: src/part2/functions.md:83
#: src/part2/functions.md:110
msgid "</td><td>"
msgstr "</td><td>"

#: src/part2/functions.md:58
msgid "```rgbasm,linenos,start=20\n"
"\t; Copy the tile data\n"
"\tld de, Tiles\n"
"\tld hl, $9000\n"
"\tld bc, TilesEnd - Tiles\n"
"\tcall Memcopy\n"
"```"
msgstr "``rgbasm,linenos,start=20\n"
"\t; Copia i dati delle piastrelle\n"
"\tld de, Tiles\n"
"\tld hl, $9000\n"
"\tld bc, TilesEnd - Tiles\n"
"\tcall Memcopy\n"
"````"

#: src/part2/functions.md:66
#: src/part2/functions.md:93
msgid "</td></tr><tr><td>"
msgstr "</td></tr><tr><td>"

#: src/part2/functions.md:85
msgid "```rgbasm,linenos,start=26\n"
"\t; Copy the tilemap\n"
"\tld de, Tilemap\n"
"\tld hl, $9800\n"
"\tld bc, TilemapEnd - Tilemap\n"
"\tcall Memcopy\n"
"```"
msgstr "``rgbasm,linenos,start=26\n"
"\t; Copia il tilemap\n"
"\tld de, Tilemap\n"
"\tld hl, $9800\n"
"\tld bc, TilemapEnd - Tilemap\n"
"\tchiama Memcopy\n"
"````"

#: src/part2/functions.md:112
msgid "```rgbasm,linenos,start=32\n"
"\t; Copy the tile data\n"
"\tld de, Paddle\n"
"\tld hl, $8000\n"
"\tld bc, PaddleEnd - Paddle\n"
"\tcall Memcopy\n"
"```"
msgstr "``rgbasm,linenos,start=32\n"
"\t; Copia i dati della piastrella\n"
"\tld de, Paddle\n"
"\tld hl, $8000\n"
"\tld bc, PaddleEnd - Paddle\n"
"\tcall Memcopy\n"
"````"

#: src/part2/functions.md:120
msgid "</td></tr></tbody></table></div>"
msgstr "</td></tr></tbody></table></div>"

#: src/part2/functions.md:122
msgid "In the next chapter, we'll write another function, this time to read player input."
msgstr "Nel prossimo capitolo, scriveremo un'altra funzione, questa volta per leggere gli input del giocatore."

#: src/part2/input.md:1
msgid "# Input"
msgstr "# Input Giocatore"

#: src/part2/input.md:3
msgid "We have the building blocks of a game here, but we're still lacking player input.\n"
"A game that plays itself isn't very much fun, so let's fix that."
msgstr "Abbiamo le fondamenta di un gioco, ma manca ancora l'input del giocatore.\n"
"Un gioco che si gioca da solo non √® molto divertente, quindi cerchiamo di risolvere questo problema."

#: src/part2/input.md:6
msgid "Paste this code below your `Main` loop.\n"
"Like `Memcpy`, this is a function that can be reused from different places, using the `call` instruction."
msgstr "Incollare questo codice sotto il ciclo `Main`.\n"
"Come `Memcpy`, questa √® una funzione che pu√≤ essere riutilizzata da diversi punti, utilizzando l'istruzione `call`."

#: src/part2/input.md:9
msgid "```rgbasm,linenos,start=110\n"
"UpdateKeys:\n"
"  ; Poll half the controller\n"
"  ld a, P1F_GET_BTN\n"
"  call .onenibble\n"
"  ld b, a ; B7-4 = 1; B3-0 = unpressed buttons"
msgstr ""

#: src/part2/input.md:16
msgid "  ; Poll the other half\n"
"  ld a, P1F_GET_DPAD\n"
"  call .onenibble\n"
"  swap a ; A3-0 = unpressed directions; A7-4 = 1\n"
"  xor a, b ; A = pressed buttons + directions\n"
"  ld b, a ; B = pressed buttons + directions"
msgstr "  ; Eseguire il polling dell'altra met√†\n"
"  ld a, P1F_GET_DPAD\n"
"  call .onenibble\n"
"  swap a ; A3-0 = direzioni non premute; A7-4 = 1\n"
"  xor a, b ; A = pulsanti premuti + direzioni\n"
"  ld b, a ; B = pulsanti premuti + direzioni"

#: src/part2/input.md:23
msgid "  ; And release the controller\n"
"  ld a, P1F_GET_NONE\n"
"  ldh [rP1], a"
msgstr "  ; E rilasciare il controllore\n"
"  ld a, P1F_GET_NONE\n"
"  ldh [rP1], a"

#: src/part2/input.md:27
msgid "  ; Combine with previous wCurKeys to make wNewKeys\n"
"  ld a, [wCurKeys]\n"
"  xor a, b ; A = keys that changed state\n"
"  and a, b ; A = keys that changed to pressed\n"
"  ld [wNewKeys], a\n"
"  ld a, b\n"
"  ld [wCurKeys], a\n"
"  ret"
msgstr "  ; Combinare con i precedenti wCurKeys per creare wNewKeys\n"
"  ld a, [wCurKeys]\n"
"  xor a, b ; A = tasti che hanno cambiato stato\n"
"  e a, b ; A = tasti che sono passati a essere premuti\n"
"  ld [wNewKeys], a\n"
"  ld a, b\n"
"  ld [wCurKeys], a\n"
"  ret"

#: src/part2/input.md:36
msgid ".onenibble\n"
"  ldh [rP1], a ; switch the key matrix\n"
"  call .knownret ; burn 10 cycles calling a known ret\n"
"  ldh a, [rP1] ; ignore value while waiting for the key matrix to settle\n"
"  ldh a, [rP1]\n"
"  ldh a, [rP1] ; this read counts\n"
"  or a, $F0 ; A7-4 = 1; A3-0 = unpressed keys\n"
".knownret\n"
"  ret\n"
"```"
msgstr ".onenibble\n"
"  ldh [rP1], a ; commuta la matrice dei tasti\n"
"  call .knownret ; brucia 10 cicli chiamando un noto ret\n"
"  ldh a, [rP1] ; ignora il valore in attesa che la matrice dei tasti si stabilizzi\n"
"  ldh a, [rP1]\n"
"  ldh a, [rP1] ; questa lettura conta\n"
"  o a, $F0 ; A7-4 = 1; A3-0 = tasti non premuti\n"
".knownret\n"
"  ret\n"
"````"

#: src/part2/input.md:47
msgid "Unfortunately, reading input on the Game Boy is fairly involved (as you can see!), and it would be quite difficult to explain what this function does right now.\n"
"So, I ask that you make an exception, and trust me that this function *does* read input.\n"
"Alright? Good!"
msgstr "Sfortunatamente, la lettura degli input sul Game Boy √® piuttosto complessa (come potete vedere!) e sarebbe piuttosto difficile spiegare cosa fa questa funzione in questo momento.\n"
"Vi chiedo quindi di fare un'eccezione e di fidarvi del fatto che questa funzione legge l'input.\n"
"Va bene? Bene!"

#: src/part2/input.md:51
msgid "Now that we know how to use functions, let's call the `UpdateKeys` function in our main loop to read user input.\n"
"`UpdateKeys` writes the held buttons to a location in memory that we called `wCurKeys`, which we can read from after the function returns.\n"
"Because of this, we only need to call `UpdateKeys` once per frame."
msgstr "Ora che sappiamo come usare le funzioni, chiamiamo la funzione `UpdateKeys` nel nostro ciclo principale per leggere l'input dell'utente.\n"
"La funzione `UpdateKeys` scrive i pulsanti tenuti in una posizione in memoria che abbiamo chiamato `wCurKeys`, da cui possiamo leggere dopo il ritorno della funzione.\n"
"Per questo motivo, √® sufficiente chiamare `UpdateKeys` una sola volta per ogni fotogramma."

#: src/part2/input.md:55
msgid "This is important, because not only is it faster to reload the inputs that we've already processed, but it also means that we will always act on the same inputs, even if the player presses or releases a button mid-frame."
msgstr "Questo √® importante, perch√© non solo √® pi√π veloce ricaricare gli input che abbiamo gi√† elaborato, ma significa anche che agiremo sempre sugli stessi input, anche se il giocatore preme o rilascia un pulsante a met√† fotogramma."

#: src/part2/input.md:57
msgid "First, let's set aside some room for the two variables that `UpdateKeys` will use; paste this at the end of the `main.asm`:"
msgstr "Per prima cosa, mettiamo da parte un po' di spazio per le due variabili che `UpdateKeys` utilizzer√†; incollate questo alla fine del file `main.asm`:"

#: src/part2/input.md:59
msgid "```rgbasm,linenos,start=407\n"
"SECTION \"Input Variables\", WRAM0\n"
"wCurKeys: db\n"
"wNewKeys: db\n"
"```"
msgstr "``rgbasm,linenos,start=407\n"
"SECTION \"Input Variables\", WRAM0\n"
"wCurKeys: db\n"
"wNewKeys: db\n"
"```"

#: src/part2/input.md:65
msgid "Each variable must reside in RAM, and not ROM, because ROM is \"Read-Only\" (so you can't modify it).\n"
"Additionally, each variable only needs to be one byte large, so we use `db` (\"Define Byte\") to reserve one byte of RAM for each."
msgstr "Ogni variabile deve risiedere nella RAM e non nella ROM, perch√© la ROM √® \"Read-Only\" (quindi non pu√≤ essere modificata).\n"
"Inoltre, ogni variabile deve essere grande solo un byte, quindi si usa `db` (\"Define Byte\") per riservare un byte di RAM a ciascuna."

#: src/part2/input.md:68
msgid "We're going to use the `and` opcode, which we can use to set the zero flag (`z`) to the value of the bit.\n"
"We can use this along with the `PADF` constants in hardware.inc to read a particular key."
msgstr "Utilizzeremo l'opcode `and`, che pu√≤ essere utilizzato per impostare il flag di zero (`z`) sul valore del bit.\n"
"Possiamo usare questo insieme alle costanti `PADF` in hardware.inc per leggere un particolare tasto."

#: src/part2/input.md:71
msgid "```rgbasm,linenos,start=68\n"
"Main:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp nc, Main\n"
"WaitVBlank2:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp c, WaitVBlank2"
msgstr "``rgbasm,linenos,start=68\n"
"Principale:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp nc, Principale\n"
"WaitVBlank2:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp c, WaitVBlank2"

#: src/part2/input.md:81
msgid "\t; Check the current keys every frame and move left or right.\n"
"\tcall UpdateKeys"
msgstr ""

#: src/part2/input.md:84
msgid "\t; First, check if the left button is pressed.\n"
"CheckLeft:\n"
"\tld a, [wCurKeys]\n"
"\tand a, PADF_LEFT\n"
"\tjp z, CheckRight\n"
"Left:\n"
"\t; Move the paddle one pixel to the left.\n"
"\tld a, [_OAMRAM + 1]\n"
"\tdec a\n"
"\t; If we've already hit the edge of the playfield, don't move.\n"
"\tcp a, 15\n"
"\tjp z, Main\n"
"\tld [_OAMRAM + 1], a\n"
"\tjp Main"
msgstr "\t; Per prima cosa, verificare se il pulsante sinistro √® premuto.\n"
"CheckLeft:\n"
"\tld a, [wCurKeys]\n"
"\te a, PADF_LEFT\n"
"\tjp z, CheckRight\n"
"Left:\n"
"\t; Spostare la racchetta di un pixel a sinistra.\n"
"\tld a, [_OAMRAM + 1]\n"
"\tdec a\n"
"\t; Se abbiamo gi√† toccato il bordo del campo di gioco, non muoviamoci.\n"
"\tcp a, 15\n"
"\tjp z, Main\n"
"\tld [_OAMRAM + 1], a\n"
"\tjp Main"

#: src/part2/input.md:99
msgid "; Then check the right button.\n"
"CheckRight:\n"
"\tld a, [wCurKeys]\n"
"\tand a, PADF_RIGHT\n"
"\tjp z, Main\n"
"Right:\n"
"\t; Move the paddle one pixel to the right.\n"
"\tld a, [_OAMRAM + 1]\n"
"\tinc a\n"
"\t; If we've already hit the edge of the playfield, don't move.\n"
"\tcp a, 105\n"
"\tjp z, Main\n"
"\tld [_OAMRAM + 1], a\n"
"\tjp Main\n"
"```"
msgstr "Quindi controllare il pulsante destro.\n"
"CheckRight:\n"
"\tld a, [wCurKeys]\n"
"\te a, PADF_RIGHT\n"
"\tjp z, Main\n"
"Right:\n"
"\t; Spostare la racchetta di un pixel a destra.\n"
"\tld a, [_OAMRAM + 1]\n"
"\tinc a\n"
"\t; Se abbiamo gi√† toccato il bordo del campo di gioco, non muoviamoci.\n"
"\tcp a, 105\n"
"\tjp z, Main\n"
"\tld [_OAMRAM + 1], a\n"
"\tjp Main\n"
"````"

#: src/part2/input.md:115
msgid "Now, if you compile the project, you should be able to move the paddle left and right using the d-pad!!\n"
"Hooray, we have the beginnings of a game!"
msgstr "Ora, se compilate il progetto, dovreste essere in grado di muovere la racchetta a destra e a sinistra usando il d-pad!!!\n"
"Urr√†, abbiamo l'inizio di un gioco!"

#: src/part2/collision.md:1
msgid "# Collision"
msgstr "# Collisioni"

#: src/part2/collision.md:3
msgid "Being able to move around is great, but there's still one object we need for this game: a ball!\n"
"Just like with the paddle, the first step is to create a tile for the ball and load it into VRAM."
msgstr "Potersi muovere √® fantastico, ma c'√® ancora un oggetto di cui abbiamo bisogno per questo gioco: una palla!\n"
"Come per la racchetta, il primo passo √® creare un riquadro per la palla e caricarlo nella VRAM."

#: src/part2/collision.md:6
msgid "## Graphics"
msgstr "## Grafica"

#: src/part2/collision.md:8
msgid "Add this to the bottom of your file along with the other graphics:\n"
"```rgbasm,linenos,start=570\n"
"Ball:\n"
"\tdw `00033000\n"
"\tdw `00322300\n"
"\tdw `03222230\n"
"\tdw `03222230\n"
"\tdw `00322300\n"
"\tdw `00033000\n"
"\tdw `00000000\n"
"\tdw `00000000\n"
"BallEnd:\n"
"```"
msgstr "Aggiungete questo in fondo al file insieme agli altri elementi grafici:\n"
"```rgbasm,linenos,start=570\n"
"Ball:\n"
"\tdw `00033000\n"
"\tdw `00322300\n"
"\tdw `03222230\n"
"\tdw `03222230\n"
"\tdw `00322300\n"
"\tdw `00033000\n"
"\tdw `000000\n"
"\tdw `000000\n"
"BallEnd:\n"
"```"

#: src/part2/collision.md:22
msgid "Now copy it to VRAM somewhere in your initialization code, e.g. after copying the paddle's tile.\n"
"```rgbasm,linenos,start=38\n"
"\t; Copy the ball tile\n"
"\tld de, Ball\n"
"\tld hl, $8010\n"
"\tld bc, BallEnd - Ball\n"
"\tcall Memcopy\n"
"```"
msgstr "Ora copiatela nella VRAM da qualche parte nel codice di inizializzazione, ad esempio dopo aver copiato la piastrella della paletta.\n"
"``rgbasm,linenos,start=38\n"
"\t; Copia la piastrella della palla\n"
"\tld de, Ball\n"
"\tld hl, $8010\n"
"\tld bc, BallEnd - Ball\n"
"\tchiama Memcopy\n"
"````"

#: src/part2/collision.md:31
msgid "In addition, we need to initialize an entry in OAM, following the code that initializes the paddle.\n"
"```rgbasm,linenos,start=52\n"
"\t; Initialize the paddle sprite in OAM\n"
"\tld hl, _OAMRAM\n"
"\tld a, 128 + 16\n"
"\tld [hli], a\n"
"\tld a, 16 + 8\n"
"\tld [hli], a\n"
"\tld a, 0\n"
"\tld [hli], a\n"
"\tld [hli], a\n"
"\t; Now initialize the ball sprite\n"
"\tld a, 100 + 16\n"
"\tld [hli], a\n"
"\tld a, 32 + 8\n"
"\tld [hli], a\n"
"\tld a, 1\n"
"\tld [hli], a\n"
"\tld a, 0\n"
"\tld [hli], a\n"
"```"
msgstr "Inoltre, dobbiamo inizializzare una voce in OAM, seguendo il codice che inizializza la paletta.\n"
"``rgbasm,linenos,start=52\n"
"\t; Inizializza lo sprite della racchetta in OAM\n"
"\tld hl, _OAMRAM\n"
"\tld a, 128 + 16\n"
"\tld [hli], a\n"
"\tld a, 16 + 8\n"
"\tld [hli], a\n"
"\tld a, 0\n"
"\tld [hli], a\n"
"\tld [hli], a\n"
"\t; Ora inizializziamo lo sprite della palla\n"
"\tld a, 100 + 16\n"
"\tld [hli], a\n"
"\tld a, 32 + 8\n"
"\tld [hli], a\n"
"\tld a, 1\n"
"\tld [hli], a\n"
"\tld a, 0\n"
"\tld [hli], a\n"
"````"

#: src/part2/collision.md:53
msgid "As the ball bounces around the screen its momentum will change, sending it in different directions.\n"
"Let's create two new variables to track the ball's momentum in each axis: `wBallMomentumX` and `wBallMomentumY`.\n"
"```rgbasm,linenos,start=581\n"
"SECTION \"Counter\", WRAM0\n"
"wFrameCounter: db"
msgstr "Mentre la palla rimbalza sullo schermo, la sua quantit√† di moto cambier√†, mandandola in direzioni diverse.\n"
"Creiamo due nuove variabili per tenere traccia del momento della palla su ciascun asse: `wBallMomentumX` e `wBallMomentumY`.\n"
"``rgbasm,linenos,start=581\n"
"SECTION \"Counter\", WRAM0\n"
"wFrameCounter: db"

#: src/part2/collision.md:59
msgid "SECTION \"Input Variables\", WRAM0\n"
"wCurKeys: db\n"
"wNewKeys: db"
msgstr "SEZIONE \"Variabili di ingresso\", WRAM0\n"
"wCurKeys: db\n"
"wNewKeys: db"

#: src/part2/collision.md:63
msgid "SECTION \"Ball Data\", WRAM0\n"
"wBallMomentumX: db\n"
"wBallMomentumY: db\n"
"```"
msgstr "SECTION \"Ball Data\", WRAM0\n"
"wBallMentumX: db\n"
"wBallMomentumY: db\n"
"```"

#: src/part2/collision.md:68
msgid "We will need to initialize these before entering the game loop, so let's do so right after we write the ball to OAM.\n"
"By setting the X momentum to 1, and the Y momentum to -1, the ball will start out by going up and to the right.\n"
"```rgbasm,linenos,start=61\n"
"\t; Now initialize the ball sprite\n"
"\tld a, 100 + 16\n"
"\tld [hli], a\n"
"\tld a, 32 + 8\n"
"\tld [hli], a\n"
"\tld a, 1\n"
"\tld [hli], a\n"
"\tld a, 0\n"
"\tld [hli], a"
msgstr "Dovremo inizializzarli prima di entrare nel ciclo di gioco, quindi lo faremo subito dopo aver scritto la palla in OAM.\n"
"Impostando il momento X a 1 e il momento Y a -1, la palla comincer√† ad andare verso l'alto e verso destra.\n"
"``rgbasm,linenos,start=61\n"
"\t; Ora inizializzate lo sprite della palla\n"
"\tld a, 100 + 16\n"
"\tld [hli], a\n"
"\tld a, 32 + 8\n"
"\tld [hli], a\n"
"\tld a, 1\n"
"\tld [hli], a\n"
"\tld a, 0\n"
"\tld [hli], a"

#: src/part2/collision.md:81
msgid "\t; The ball starts out going up and to the right\n"
"\tld a, 1\n"
"\tld [wBallMomentumX], a\n"
"\tld a, -1\n"
"\tld [wBallMomentumY], a\n"
"```"
msgstr "\tLa palla inizia ad andare verso l'alto e verso destra\n"
"\tld a, 1\n"
"\tld [wBallMomentumX], a\n"
"\tld a, -1\n"
"\tld [wBallMomentumY], a\n"
"````"

#: src/part2/collision.md:88
msgid "## Prep work"
msgstr "## Lavoro di preparazione"

#: src/part2/collision.md:90
msgid "Now for the fun part!\n"
"Add a bit of code at the beginning of your main loop that adds the momentum to the OAM positions.\n"
"Notice that since this is the second OAM entry, we use `+ 4` for Y and `+ 5` for X.\n"
"This can get pretty confusing, but luckily we only have two objects to keep track of.\n"
"In the future, we'll go over a much easier way to use OAM.\n"
"```rgbasm,linenos,start=90\n"
"Main:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp nc, Main\n"
"WaitVBlank2:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp c, WaitVBlank2"
msgstr "Ora la parte divertente!\n"
"Aggiungete un po' di codice all'inizio del ciclo principale che aggiunge il momento alle posizioni OAM.\n"
"Notate che, essendo questa la seconda voce OAM, usiamo `+ 4` per Y e `+ 5` per X.\n"
"Questo pu√≤ creare molta confusione, ma per fortuna abbiamo solo due oggetti da tenere sotto controllo.\n"
"In futuro, vedremo un modo molto pi√π semplice di usare OAM.\n"
"``rgbasm,linenos,start=90\n"
"Main:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp nc, Main\n"
"WaitVBlank2:\n"
"\tld a, [rLY]\n"
"\tcp 144\n"
"\tjp c, WaitVBlank2"

#: src/part2/collision.md:105
msgid "\t; Add the ball's momentum to its position in OAM.\n"
"\tld a, [wBallMomentumX]\n"
"\tld b, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tadd a, b\n"
"\tld [_OAMRAM + 5], a"
msgstr "\tAggiungere la quantit√† di moto della palla alla sua posizione in OAM.\n"
"\tld a, [wBallMomentumX]\n"
"\tld b, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tadd a, b\n"
"\tld [_OAMRAM + 5], a"

#: src/part2/collision.md:112
msgid "\tld a, [wBallMomentumY]\n"
"\tld b, a\n"
"\tld a, [_OAMRAM + 4]\n"
"\tadd a, b\n"
"\tld [_OAMRAM + 4], a\n"
"```"
msgstr "\tld a, [wBallMomentumY]\n"
"\tld b, a\n"
"\tld a, [_OAMRAM + 4]\n"
"\tadd a, b\n"
"\tld [_OAMRAM + 4], a\n"
"````"

#: src/part2/collision.md:119
msgid "You might want to compile your game again to see what this does.\n"
"If you do, you should see the ball moving around, but it will just go through the walls and then fly offscreen."
msgstr "Si consiglia di compilare nuovamente il gioco per vedere cosa fa.\n"
"Se lo fate, dovreste vedere la palla muoversi, ma passer√† attraverso i muri e poi voler√† fuori dallo schermo."

#: src/part2/collision.md:122
msgid "To fix this, we need to add collision detection so that the ball can bounce around.\n"
"We'll need to repeat the collision check a few times, so we're going to make use of two functions to do this."
msgstr "Per risolvere questo problema, dobbiamo aggiungere il rilevamento delle collisioni, in modo che la palla possa rimbalzare.\n"
"Dovremo ripetere il controllo delle collisioni un paio di volte, quindi utilizzeremo due funzioni per farlo."

#: src/part2/collision.md:127
msgid "Please do not get stuck on the details of this next function, as it uses some techniques and instructions we haven't discussed yet.\n"
"The basic idea is that it converts the position of the sprite to a location on the tilemap.\n"
"This way, we can check which tile our ball is touching so that we know when to bounce!"
msgstr "Non perdetevi nei dettagli di questa funzione, perch√© utilizza alcune tecniche e istruzioni che non abbiamo ancora discusso.\n"
"L'idea di base √® che converte la posizione dello sprite in una posizione sulla mappa delle piastrelle.\n"
"In questo modo, possiamo controllare quale piastrella sta toccando la nostra palla, in modo da sapere quando rimbalzare!"

#: src/part2/collision.md:133
msgid "```rgbasm,linenos,start=226\n"
"; Convert a pixel position to a tilemap address\n"
"; hl = $9800 + X + Y * 32\n"
"; @param b: X\n"
"; @param c: Y\n"
"; @return hl: tile address\n"
"GetTileByPixel:\n"
"\t; First, we need to divide by 8 to convert a pixel position to a tile position.\n"
"\t; After this we want to multiply the Y position by 32.\n"
"\t; These operations effectively cancel out so we only need to mask the Y value.\n"
"\tld a, c\n"
"\tand a, %11111000\n"
"\tld l, a\n"
"\tld h, 0\n"
"\t; Now we have the position * 8 in hl\n"
"\tadd hl, hl ; position * 16\n"
"\tadd hl, hl ; position * 32\n"
"\t; Convert the X position to an offset.\n"
"\tld a, b\n"
"\tsrl a ; a / 2\n"
"\tsrl a ; a / 4\n"
"\tsrl a ; a / 8\n"
"\t; Add the two offsets together.\n"
"\tadd a, l\n"
"\tld l, a\n"
"\tadc a, h\n"
"\tsub a, l\n"
"\tld h, a\n"
"\t; Add the offset to the tilemap's base address, and we are done!\n"
"\tld bc, $9800\n"
"\tadd hl, bc\n"
"\tret\n"
"```"
msgstr "``rgbasm,linenos,start=226\n"
"; Converte una posizione pixel in un indirizzo tilemap\n"
"; hl = $9800 + X + Y * 32\n"
"; @param b: X\n"
"; @param c: Y\n"
"; @return hl: indirizzo della piastrella\n"
"GetTileByPixel:\n"
"\t; Per prima cosa, dobbiamo dividere per 8 per convertire la posizione di un pixel in una posizione di una piastrella.\n"
"\t; Dopo di ci√≤, vogliamo moltiplicare la posizione Y per 32.\n"
"\tQueste operazioni si annullano di fatto, quindi √® necessario mascherare solo il valore Y.\n"
"\tld a, c\n"
"\te a, %11111000\n"
"\tld l, a\n"
"\tld h, 0\n"
"\t; Ora abbiamo la posizione * 8 in hl\n"
"\tadd hl, hl ; posizione * 16\n"
"\tadd hl, hl ; posizione * 32\n"
"\t; Convertire la posizione X in un offset.\n"
"\tld a, b\n"
"\tsrl a ; a / 2\n"
"\tsrl a ; a / 4\n"
"\tsrl a ; a / 8\n"
"\t; Sommare i due offset.\n"
"\tadd a, l\n"
"\tld l, a\n"
"\tadc a, h\n"
"\tsub a, l\n"
"\tld h, a\n"
"\t; Aggiungete l'offset all'indirizzo base della tilemap e il gioco √® fatto!\n"
"\tld bc, $9800\n"
"\tadd hl, bc\n"
"\tret\n"
"````"

#: src/part2/collision.md:167
msgid "The next function is called `IsWallTile`, and it's going to contain a list of tiles which the ball can bounce off of.\n"
"```rgbasm,linenos,start=258\n"
"; @param a: tile ID\n"
"; @return z: set if a is a wall.\n"
"IsWallTile:\n"
"\tcp a, $00\n"
"\tret z\n"
"\tcp a, $01\n"
"\tret z\n"
"\tcp a, $02\n"
"\tret z\n"
"\tcp a, $04\n"
"\tret z\n"
"\tcp a, $05\n"
"\tret z\n"
"\tcp a, $06\n"
"\tret z\n"
"\tcp a, $07\n"
"\tret\n"
"```"
msgstr "La prossima funzione si chiama `IsWallTile` e conterr√† un elenco di piastrelle su cui la palla pu√≤ rimbalzare.\n"
"``rgbasm,linenos,start=258\n"
"; @param a: ID della piastrella\n"
"; @return z: imposta se a √® un muro.\n"
"IsWallTile:\n"
"\tcp a, $00\n"
"\tret z\n"
"\tcp a, $01\n"
"\tret z\n"
"\tcp a, $02\n"
"\tret z\n"
"\tcp a, $04\n"
"\tret z\n"
"\tcp a, $05\n"
"\tret z\n"
"\tcp a, $06\n"
"\tret z\n"
"\tcp a, $07\n"
"\tret\n"
"````"

#: src/part2/collision.md:188
msgid "This function might look a bit strange at first.\n"
"Instead of returning its result in a *register*, like `a`, it returns it in [a *flag*](../part1/operations.md#flags): `Z`!\n"
"If at any point a tile matches, the function has found a wall and exits with `Z` set.\n"
"If the target tile ID (in `a`) matches one of the wall tile IDs, the corresponding `cp` will leave `Z` set; if so, we return immediately (via `ret z`), with `Z` set.\n"
"But if we reach the last comparison and it still doesn't set `Z`, then we will know that we haven't hit a wall and don't need to bounce."
msgstr "Questa funzione pu√≤ sembrare un po' strana all'inizio.\n"
"Invece di restituire il risultato in un *registro*, come `a`, lo restituisce in [un *flag*](../part1/operations.md#flags): `Z`!\n"
"Se in qualsiasi punto una piastrella corrisponde, la funzione ha trovato un muro ed esce con `Z` impostato.\n"
"Se l'ID della piastrella di destinazione (in `a`) corrisponde a uno degli ID delle piastrelle del muro, il corrispondente `cp` lascer√† `Z` impostato; in tal caso, si ritorna immediatamente (tramite `ret z`), con `Z` impostato.\n"
"Ma se, dopo aver effettuato l'ultimo confronto, `Z` non viene ancora impostato, sapremo che non abbiamo colpito un muro e non abbiamo bisogno di rimbalzare."

#: src/part2/collision.md:194
msgid "## Putting it together"
msgstr "## Unificare il tutto"

#: src/part2/collision.md:196
msgid "Time to use these new functions to add collision detection!\n"
"Add the following after the code that updates the ball's position:\n"
"```rgbasm,linenos,start=112\n"
"BounceOnTop:\n"
"\t; Remember to offset the OAM position!\n"
"\t; (8, 16) in OAM coordinates is (0, 0) on the screen.\n"
"\tld a, [_OAMRAM + 4]\n"
"\tsub a, 16 + 1\n"
"\tld c, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tsub a, 8\n"
"\tld b, a\n"
"\tcall GetTileByPixel ; Returns tile address in hl\n"
"\tld a, [hl]\n"
"\tcall IsWallTile\n"
"\tjp nz, BounceOnRight\n"
"\tld a, 1\n"
"\tld [wBallMomentumY], a\n"
"```"
msgstr "√à ora di usare queste nuove funzioni per aggiungere il rilevamento delle collisioni!\n"
"Aggiungete quanto segue dopo il codice che aggiorna la posizione della palla:\n"
"``rgbasm,linenos,start=112\n"
"BounceOnTop:\n"
"\t; Ricordate di sfalsare la posizione OAM!\n"
"\t(8, 16) in coordinate OAM √® (0, 0) sullo schermo.\n"
"\tld a, [_OAMRAM + 4]\n"
"\tsub a, 16 + 1\n"
"\tld c, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tsub a, 8\n"
"\tld b, a\n"
"\tcall GetTileByPixel ; Restituisce l'indirizzo della piastrella in hl\n"
"\tld a, [hl]\n"
"\tcall IsWallTile\n"
"\tjp nz, BounceOnRight\n"
"\tld a, 1\n"
"\tld [wBallMomentumY], a\n"
"````"

#: src/part2/collision.md:216
msgid "You'll see that when we load the sprite's positions, we subtract from them before calling `GetTileByPixel`.\n"
"You might remember from the last chapter that OAM positions are slightly offset; that is, (0, 0) in OAM is actually completely offscreen.\n"
"These `sub` instructions undo this offset."
msgstr "Vedrete che quando carichiamo le posizioni dello sprite, le sottraiamo prima di chiamare `GetTileByPixel`.\n"
"Forse ricorderete dall'ultimo capitolo che le posizioni OAM sono leggermente sfalsate; cio√®, (0, 0) in OAM √® in realt√† completamente fuori dallo schermo.\n"
"Queste istruzioni `sub` annullano questo offset."

#: src/part2/collision.md:220
msgid "However, there's a bit more to this: you might have noticed that we subtracted an extra pixel from the Y position.\n"
"That's because (as the label suggests), this code is checking for a tile above the ball.\n"
"We actually need to check *all four* sides of the ball so we know how to change the momentum according to which side collided, so... let's add the rest!"
msgstr "Tuttavia, c'√® dell'altro: avrete notato che abbiamo sottratto un pixel in pi√π dalla posizione Y. Questo perch√© (come suggerisce l'etichetta) questo codice controlla la presenza di una piastrella sopra la palla.\n"
"Questo perch√© (come suggerisce l'etichetta), il codice controlla la presenza di una piastrella sopra la palla.\n"
"In realt√† abbiamo bisogno di controllare *tutti e quattro* i lati della palla, in modo da sapere come cambiare la quantit√† di moto a seconda del lato che si √® scontrato, quindi... aggiungiamo il resto!"

#: src/part2/collision.md:224
msgid "```rgbasm,linenos,start=128\n"
"BounceOnRight:\n"
"\tld a, [_OAMRAM + 4]\n"
"\tsub a, 16\n"
"\tld c, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tsub a, 8 - 1\n"
"\tld b, a\n"
"\tcall GetTileByPixel\n"
"\tld a, [hl]\n"
"\tcall IsWallTile\n"
"\tjp nz, BounceOnLeft\n"
"\tld a, -1\n"
"\tld [wBallMomentumX], a"
msgstr "``rgbasm,linenos,start=128\n"
"BounceOnRight:\n"
"\tld a, [_OAMRAM + 4]\n"
"\tsub a, 16\n"
"\tld c, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tsub a, 8 - 1\n"
"\tld b, a\n"
"\tcall GetTileByPixel\n"
"\tld a, [hl]\n"
"\tcall IsWallTile\n"
"\tjp nz, BounceOnLeft\n"
"\tld a, -1\n"
"\tld [wBallMomentumX], a"

#: src/part2/collision.md:239
msgid "BounceOnLeft:\n"
"\tld a, [_OAMRAM + 4]\n"
"\tsub a, 16\n"
"\tld c, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tsub a, 8 + 1\n"
"\tld b, a\n"
"\tcall GetTileByPixel\n"
"\tld a, [hl]\n"
"\tcall IsWallTile\n"
"\tjp nz, BounceOnBottom\n"
"\tld a, 1\n"
"\tld [wBallMomentumX], a"
msgstr "BounceOnLeft:\n"
"\tld a, [_OAMRAM + 4]\n"
"\tsub a, 16\n"
"\tld c, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tsub a, 8 + 1\n"
"\tld b, a\n"
"\tcall GetTileByPixel\n"
"\tld a, [hl]\n"
"\tcall IsWallTile\n"
"\tjp nz, BounceOnBottom\n"
"\tld a, 1\n"
"\tld [wBallMomentumX], a"

#: src/part2/collision.md:253
msgid "BounceOnBottom:\n"
"\tld a, [_OAMRAM + 4]\n"
"\tsub a, 16 - 1\n"
"\tld c, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tsub a, 8\n"
"\tld b, a\n"
"\tcall GetTileByPixel\n"
"\tld a, [hl]\n"
"\tcall IsWallTile\n"
"\tjp nz, BounceDone\n"
"\tld a, -1\n"
"\tld [wBallMomentumY], a\n"
"BounceDone:\n"
"```"
msgstr "Rimbalzo sul fondo:\n"
"\tld a, [_OAMRAM + 4]\n"
"\tsub a, 16 - 1\n"
"\tld c, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tsub a, 8\n"
"\tld b, a\n"
"\tcall GetTileByPixel\n"
"\tld a, [hl]\n"
"\tcall IsWallTile\n"
"\tjp nz, BounceDone\n"
"\tld a, -1\n"
"\tld [wBallMomentumY], a\n"
"BounceDone:\n"
"````"

#: src/part2/collision.md:269
msgid "That was a lot, but now the ball bounces around your screen!\n"
"There's just one last thing to do before this chapter is over, and thats ball-to-paddle collision."
msgstr "Era molto, ma ora la palla rimbalza sullo schermo!\n"
"C'√® solo un'ultima cosa da fare prima della fine di questo capitolo: la collisione tra palla e paddle."

#: src/part2/collision.md:272
msgid "## Paddle bounce"
msgstr "## Rimbalzo della pagaia"

#: src/part2/collision.md:274
msgid "Unlike with the tilemap, there's no position conversions to do here, just straight comparisons.\n"
"However, for these, we will need [the *carry* flag](../part1/operations.md#flags).\n"
"The carry flag is notated as `C`, like how the zero flag is notated as `Z`, but don't confuse it with the `c` register!"
msgstr "A differenza di quanto accade con la tilemap, qui non √® necessario effettuare conversioni di posizione, ma solo confronti diretti.\n"
"Tuttavia, per questi ultimi, avremo bisogno [del flag *carry*](../part1/operations.md#flags).\n"
"Il flag di riporto √® indicato con `C`, come il flag zero √® indicato con `Z`, ma non bisogna confonderlo con il registro `c`!"

#: src/part2/collision.md:278
msgid "::: tip A refresher on comparisons"
msgstr "::: tip Un ripasso sui confronti"

#: src/part2/collision.md:280
msgid "Just like `Z`, you can use the carry flag to jump conditionally.\n"
"However, while `Z` is used to check if two numbers are equal, `C` can be used to check if a number is greater than or smaller than another one.\n"
"For example, `cp a, b` sets `C` if `a < b`, and clears it if `a >= b`.\n"
"(If you want to check `a <= b` or `a > b`, you can use `Z` and `C` in tandem with two `jp` instructions.)"
msgstr "Proprio come `Z`, √® possibile utilizzare il flag di riporto per fare salti condizionati.\n"
"Tuttavia, mentre `Z` viene utilizzato per verificare se due numeri sono uguali, `C` pu√≤ essere utilizzato per verificare se un numero √® maggiore o minore di un altro.\n"
"Per esempio, `cp a, b` imposta `C` se `a < b` e lo azzera se `a >= b`.\n"
"(Per verificare `a <= b` o `a > b` si possono usare `Z` e `C` in tandem con due istruzioni `jp`)"

#: src/part2/collision.md:287
msgid "Armed with this knowledge, let's work through the paddle bounce code:\n"
"```rgbasm,linenos,start=171\n"
"\t; First, check if the ball is low enough to bounce off the paddle.\n"
"\tld a, [_OAMRAM]\n"
"\tld b, a\n"
"\tld a, [_OAMRAM + 4]\n"
"\tcp a, b\n"
"\tjp nz, PaddleBounceDone ; If the ball isn't at the same Y position as the paddle, it can't bounce.\n"
"\t; Now let's compare the X positions of the objects to see if they're touching.\n"
"\tld a, [_OAMRAM + 5] ; Ball's X position.\n"
"\tld b, a\n"
"\tld a, [_OAMRAM + 1] ; Paddle's X position.\n"
"\tsub a, 8\n"
"\tcp a, b\n"
"\tjp nc, PaddleBounceDone\n"
"\tadd a, 8 + 16 ; 8 to undo, 16 as the width.\n"
"\tcp a, b\n"
"\tjp c, PaddleBounceDone"
msgstr ""

#: src/part2/collision.md:306
msgid "\tld a, -1\n"
"\tld [wBallMomentumY], a"
msgstr "\tld a, -1\n"
"\tld [wBallMomentumY], a"

#: src/part2/collision.md:309
msgid "PaddleBounceDone:\n"
"```"
msgstr "PaddleBounceDone:\n"
"````"

#: src/part2/collision.md:312
msgid "The Y position's check is simple, since our paddle is flat.\n"
"However, the X position has two checks which widen the area the ball can bounce on.\n"
"First we add 16 to the ball's position; if the ball is more than 16 pixels to the right of the paddle, it shouldn't bounce.\n"
"Then we undo this by subtracting 16, and while we're at it, subtract another 8 pixels; if the ball is more than 8 pixels to the left of the paddle, it shouldn't bounce."
msgstr "Il controllo della posizione Y √® semplice, poich√© la nostra racchetta √® piatta.\n"
"Tuttavia, la posizione X ha due controlli che ampliano l'area in cui la palla pu√≤ rimbalzare.\n"
"Innanzitutto aggiungiamo 16 alla posizione della pallina; se la pallina si trova a pi√π di 16 pixel a destra della racchetta, non dovrebbe rimbalzare.\n"
"Poi annulliamo questa operazione sottraendo 16 e, gi√† che ci siamo, sottraiamo altri 8 pixel; se la palla si trova a pi√π di 8 pixel a sinistra della racchetta, non dovrebbe rimbalzare."

#: src/part2/collision.md:317
msgid "<svg viewBox=\"-10 -10 860 520\">\n"
"\t<style>\n"
"\t\ttext { text-anchor: middle; fill: var(--fg); font-size: 20px; }\n"
"\t\t.left { text-anchor: start; }\n"
"\t\t.right { text-anchor: end; }\n"
"\t\t.grid { stroke: var(--fg); opacity: 0.7; }\n"
"\t\t.ball { stroke: teal; }\n"
"\t\t.paddle { stroke: orange; }\n"
"\t\t.excl { stroke: red; } text.excl { stroke: initial; fill: red; font-family: \"Source Code Pro\", Consolas, \"Ubuntu Mono\", Menlo, \"DejaVu Sans Mono\", monospace, monospace !important; }\n"
"\t\t/* Overlays */\n"
"\t\trect, polyline { opacity: 0.5; stroke-width: 3; }\n"
"\t\t/* Arrow */\n"
"\t\tpolygon { stroke: inherit; fill: var(--bg); }\n"
"\t\tuse + line { stroke-dasharray: 0 32 999; stroke-width: 2; }\n"
"\t</style>\n"
"\t<defs>\n"
"\t\t<polygon id=\"arrow-head\" points=\"0,0 -40,-16 -32,0 -40,16\" stroke=\"context-stroke\"/>\n"
"\t\t<pattern id=\"ball-hatched\" viewBox=\"0 0 4 4\" width=\"8\" height=\"8\" patternUnits=\"userSpaceOnUse\">\n"
"\t\t\t<line x1=\"5\" y1=\"-1\" x2=\"-1\" y2=\"5\" class=\"ball\"/>\n"
"\t\t\t<line x1=\"5\" y1=\"3\" x2=\"3\" y2=\"5\" class=\"ball\"/>\n"
"\t\t\t<line x1=\"1\" y1=\"-1\" x2=\"-1\" y2=\"1\" class=\"ball\"/>\n"
"\t\t</pattern>\n"
"\t\t<pattern id=\"paddle-hatched\" viewBox=\"0 0 4 4\" width=\"8\" height=\"8\" patternUnits=\"userSpaceOnUse\">\n"
"\t\t\t<line x1=\"5\" y1=\"-1\" x2=\"-1\" y2=\"5\" class=\"paddle\"/>\n"
"\t\t\t<line x1=\"5\" y1=\"3\" x2=\"3\" y2=\"5\" class=\"paddle\"/>\n"
"\t\t\t<line x1=\"1\" y1=\"-1\" x2=\"-1\" y2=\"1\" class=\"paddle\"/>\n"
"\t\t</pattern>\n"
"\t\t<pattern id=\"excl-hatched\" viewBox=\"0 0 4 4\" width=\"8\" height=\"8\" patternUnits=\"userSpaceOnUse\">\n"
"\t\t\t<line x1=\"5\" y1=\"-1\" x2=\"-1\" y2=\"5\" class=\"excl\"/>\n"
"\t\t\t<line x1=\"5\" y1=\"3\" x2=\"3\" y2=\"5\" class=\"excl\"/>\n"
"\t\t\t<line x1=\"1\" y1=\"-1\" x2=\"-1\" y2=\"1\" class=\"excl\"/>\n"
"\t\t</pattern>\n"
"\t</defs>\n"
"\t<image x=\"128\" y=\"0\" width=\"256\" height=\"256\" href=\"../assets/part2/img/ball.png\"/>\n"
"\t<rect x=\"128\" y=\"0\" width=\"32\" height=\"32\" fill=\"url(#ball-hatched)\"/>\n"
"\t<image x=\"288\" y=\"256\" width=\"256\" height=\"256\" href=\"../assets/part2/img/paddle.png\"/>\n"
"\t<rect x=\"288\" y=\"256\" width=\"32\" height=\"32\" fill=\"url(#paddle-hatched)\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"0\" x2=\"850\" y2=\"0\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"32\" x2=\"850\" y2=\"32\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"64\" x2=\"850\" y2=\"64\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"96\" x2=\"850\" y2=\"96\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"128\" x2=\"850\" y2=\"128\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"160\" x2=\"850\" y2=\"160\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"192\" x2=\"850\" y2=\"192\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"224\" x2=\"850\" y2=\"224\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"256\" x2=\"850\" y2=\"256\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"288\" x2=\"850\" y2=\"288\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"320\" x2=\"850\" y2=\"320\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"352\" x2=\"850\" y2=\"352\"/>\n"
"\t<line class=\"grid\" x1=\"0\" y1=\"-20\" x2=\"0\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"32\" y1=\"-20\" x2=\"32\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"64\" y1=\"-20\" x2=\"64\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"96\" y1=\"-20\" x2=\"96\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"128\" y1=\"-20\" x2=\"128\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"160\" y1=\"-20\" x2=\"160\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"192\" y1=\"-20\" x2=\"192\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"224\" y1=\"-20\" x2=\"224\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"256\" y1=\"-20\" x2=\"256\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"288\" y1=\"-20\" x2=\"288\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"320\" y1=\"-20\" x2=\"320\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"352\" y1=\"-20\" x2=\"352\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"384\" y1=\"-20\" x2=\"384\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"416\" y1=\"-20\" x2=\"416\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"448\" y1=\"-20\" x2=\"448\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"480\" y1=\"-20\" x2=\"480\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"512\" y1=\"-20\" x2=\"512\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"544\" y1=\"-20\" x2=\"544\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"576\" y1=\"-20\" x2=\"576\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"608\" y1=\"-20\" x2=\"608\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"640\" y1=\"-20\" x2=\"640\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"672\" y1=\"-20\" x2=\"672\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"704\" y1=\"-20\" x2=\"704\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"736\" y1=\"-20\" x2=\"736\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"768\" y1=\"-20\" x2=\"768\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"800\" y1=\"-20\" x2=\"800\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"832\" y1=\"-20\" x2=\"832\" y2=\"351\"/>\n"
"\t<rect x=\"128\" y=\"0\" width=\"256\" height=\"256\" class=\"ball\" style=\"fill: none;\"/>\n"
"\t<polyline points=\"288,352 288,256 544,256 544,352\" class=\"paddle\" style=\"fill: none;\"/>\n"
"\t<rect x=\"-15\" y=\"-15\" width=\"47\" height=\"440\" class=\"excl\" fill=\"url(#excl-hatched)\"/>\n"
"\t<text x=\"40\" y=\"430\" class=\"excl left\">jp c, DoNotBounce</text>\n"
"\t<rect x=\"800\" y=\"-15\" width=\"52\" height=\"510\" class=\"excl\" fill=\"url(#excl-hatched)\"/>\n"
"\t<text x=\"790\" y=\"500\" class=\"excl right\">jp nc, DoNotBounce</text>\n"
"\t<use href=\"#arrow-head\" x=\"48\" y=\"380\" transform=\"rotate(-180,48,380)\" class=\"paddle\"/><line x1=\"48\" y1=\"380\" x2=\"304\" y2=\"380\" class=\"paddle\"/>\n"
"\t<text x=\"176\" y=\"400\">- 8</text>\n"
"\t<use href=\"#arrow-head\" x=\"304\" y=\"450\" class=\"paddle\"/><line x1=\"304\" y1=\"450\" x2=\"48\" y2=\"450\" class=\"paddle\"/>\n"
"\t<use href=\"#arrow-head\" x=\"816\" y=\"450\" class=\"paddle\"/><line x1=\"816\" y1=\"450\" x2=\"304\" y2=\"450\" class=\"paddle\"/>\n"
"\t<text x=\"432\" y=\"470\">+ 8 + 16</text>\n"
"</svg>"
msgstr "<svg viewBox=\"-10 -10 860 520\">\n"
"\t<style>\n"
"\t\ttext { text-anchor: middle; fill: var(--fg); font-size: 20px; }\n"
"\t\t.left { text-anchor: start; }\n"
"\t\t.right { text-anchor: end; }\n"
"\t\t.grid { stroke: var(--fg); opacity: 0.7; }\n"
"\t\t.ball { stroke: verde acqua; }\n"
"\t\t.paddle { stroke: orange; }\n"
"\t\t.excl { stroke: red; } text.excl { stroke: initial; fill: red; font-family: \"Source Code Pro\", Consolas, \"Ubuntu Mono\", Menlo, \"DejaVu Sans Mono\", monospace, monospace !important; }\n"
"\t\t/* Sovrapposizioni */\n"
"\t\trect, polyline { opacity: 0.5; stroke-width: 3; }\n"
"\t\t/* Freccia */\n"
"\t\tpoligono { stroke: inherit; fill: var(--bg); }\n"
"\t\tuso + linea { stroke-dasharray: 0 32 999; larghezza tratto: 2; }\n"
"\t</style>\n"
"\t<defs>\n"
"\t\t<polygon id=\"arrow-head\" points=\"0,0 -40,-16 -32,0 -40,16\" stroke=\"context-stroke\"/>\n"
"\t\t<pattern id=\"ball-hatched\" viewBox=\"0 0 4 4\" width=\"8\" height=\"8\" patternUnits=\"userSpaceOnUse\">\n"
"\t\t\t<line x1=\"5\" y1=\"-1\" x2=\"-1\" y2=\"5\" class=\"ball\"/>\n"
"\t\t\t<line x1=\"5\" y1=\"3\" x2=\"3\" y2=\"5\" class=\"ball\"/>\n"
"\t\t\t<line x1=\"1\" y1=\"-1\" x2=\"-1\" y2=\"1\" class=\"ball\"/>\n"
"\t\t</pattern>\n"
"\t\t<pattern id=\"paddle-hatched\" viewBox=\"0 0 4 4\" width=\"8\" height=\"8\" patternUnits=\"userSpaceOnUse\">\n"
"\t\t\t<line x1=\"5\" y1=\"-1\" x2=\"-1\" y2=\"5\" class=\"paddle\"/>\n"
"\t\t\t<line x1=\"5\" y1=\"3\" x2=\"3\" y2=\"5\" class=\"paddle\"/>\n"
"\t\t\t<line x1=\"1\" y1=\"-1\" x2=\"-1\" y2=\"1\" class=\"paddle\"/>\n"
"\t\t</pattern>\n"
"\t\t<pattern id=\"excl-hatched\" viewBox=\"0 0 4 4\" width=\"8\" height=\"8\" patternUnits=\"userSpaceOnUse\">\n"
"\t\t\t<line x1=\"5\" y1=\"-1\" x2=\"-1\" y2=\"5\" class=\"excl\"/>\n"
"\t\t\t<line x1=\"5\" y1=\"3\" x2=\"3\" y2=\"5\" class=\"excl\"/>\n"
"\t\t\t<line x1=\"1\" y1=\"-1\" x2=\"-1\" y2=\"1\" class=\"excl\"/>\n"
"\t\t</pattern>\n"
"\t</defs>\n"
"\t<image x=\"128\" y=\"0\" width=\"256\" height=\"256\" href=\"../assets/part2/img/ball.png\"/>\n"
"\t<rect x=\"128\" y=\"0\" width=\"32\" height=\"32\" fill=\"url(#ball-hatched)\"/>\n"
"\t<image x=\"288\" y=\"256\" width=\"256\" height=\"256\" href=\"../assets/part2/img/paddle.png\"/>\n"
"\t<rect x=\"288\" y=\"256\" width=\"32\" height=\"32\" fill=\"url(#paddle-hatched)\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"0\" x2=\"850\" y2=\"0\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"32\" x2=\"850\" y2=\"32\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"64\" x2=\"850\" y2=\"64\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"96\" x2=\"850\" y2=\"96\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"128\" x2=\"850\" y2=\"128\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"160\" x2=\"850\" y2=\"160\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"192\" x2=\"850\" y2=\"192\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"224\" x2=\"850\" y2=\"224\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"256\" x2=\"850\" y2=\"256\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"288\" x2=\"850\" y2=\"288\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"320\" x2=\"850\" y2=\"320\"/>\n"
"\t<line class=\"grid\" x1=\"-10\" y1=\"352\" x2=\"850\" y2=\"352\"/>\n"
"\t<line class=\"grid\" x1=\"0\" y1=\"-20\" x2=\"0\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"32\" y1=\"-20\" x2=\"32\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"64\" y1=\"-20\" x2=\"64\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"96\" y1=\"-20\" x2=\"96\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"128\" y1=\"-20\" x2=\"128\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"160\" y1=\"-20\" x2=\"160\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"192\" y1=\"-20\" x2=\"192\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"224\" y1=\"-20\" x2=\"224\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"256\" y1=\"-20\" x2=\"256\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"288\" y1=\"-20\" x2=\"288\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"320\" y1=\"-20\" x2=\"320\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"352\" y1=\"-20\" x2=\"352\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"384\" y1=\"-20\" x2=\"384\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"416\" y1=\"-20\" x2=\"416\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"448\" y1=\"-20\" x2=\"448\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"480\" y1=\"-20\" x2=\"480\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"512\" y1=\"-20\" x2=\"512\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"544\" y1=\"-20\" x2=\"544\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"576\" y1=\"-20\" x2=\"576\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"608\" y1=\"-20\" x2=\"608\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"640\" y1=\"-20\" x2=\"640\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"672\" y1=\"-20\" x2=\"672\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"704\" y1=\"-20\" x2=\"704\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"736\" y1=\"-20\" x2=\"736\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"768\" y1=\"-20\" x2=\"768\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"800\" y1=\"-20\" x2=\"800\" y2=\"351\"/>\n"
"\t<line class=\"grid\" x1=\"832\" y1=\"-20\" x2=\"832\" y2=\"351\"/>\n"
"\t<rect x=\"128\" y=\"0\" width=\"256\" height=\"256\" class=\"ball\" style=\"fill: none;\"/>\n"
"\t<polyline points=\"288,352 288,256 544,256 544,352\" class=\"paddle\" style=\"fill: none;\"/>\n"
"\t<rect x=\"-15\" y=\"-15\" width=\"47\" height=\"440\" class=\"excl\" fill=\"url(#excl-hatched)\"/>\n"
"\t<text x=\"40\" y=\"430\" class=\"excl left\">jp c, DoNotBounce</text>\n"
"\t<rect x=\"800\" y=\"-15\" width=\"52\" height=\"510\" class=\"excl\" fill=\"url(#excl-hatched)\"/>\n"
"\t<text x=\"790\" y=\"500\" class=\"excl right\">jp nc, DoNotBounce</text>\n"
"\t<use href=\"#arrow-head\" x=\"48\" y=\"380\" transform=\"rotate(-180,48,380)\" class=\"paddle\"/><line x1=\"48\" y1=\"380\" x2=\"304\" y2=\"380\" class=\"paddle\"/>\n"
"\t<text x=\"176\" y=\"400\">- 8</text>\n"
"\t<use href=\"#arrow-head\" x=\"304\" y=\"450\" class=\"paddle\"/><line x1=\"304\" y1=\"450\" x2=\"48\" y2=\"450\" class=\"paddle\"/>\n"
"\t<use href=\"#arrow-head\" x=\"816\" y=\"450\" class=\"paddle\"/><line x1=\"816\" y1=\"450\" x2=\"304\" y2=\"450\" class=\"paddle\"/>\n"
"\t<text x=\"432\" y=\"470\">+ 8 + 16</text>\n"
"</svg>"

#: src/part2/collision.md:406
msgid "::: tip Paddle width"
msgstr "::: punta Larghezza della paletta"

#: src/part2/collision.md:408
msgid "You might be wondering why we checked 16 pixels to the right but only 8 pixels to the left.\n"
"Remember that OAM positions represent the upper-*left* corner of a sprite, so the center of our paddle is actually 4 pixels to the right of the position in OAM.\n"
"When you consider this, we're actually checking 12 pixels out on either side from the center of the paddle."
msgstr "Ci si potrebbe chiedere perch√© abbiamo controllato 16 pixel a destra ma solo 8 pixel a sinistra.\n"
"Ricordate che le posizioni OAM rappresentano l'angolo superiore *sinistro* di uno sprite, quindi il centro della nostra paletta √® in realt√† 4 pixel a destra della posizione in OAM.\n"
"Se si considera questo, in realt√† stiamo controllando 12 pixel su entrambi i lati dal centro della paletta."

#: src/part2/collision.md:412
msgid "12 pixels might seem like a lot, but it gives some tolerance to the player in case their positioning is off.\n"
"If you'd prefer to make this easier or more difficult, feel free to adjust the values!"
msgstr "12 pixel possono sembrare molti, ma danno un po' di tolleranza al giocatore nel caso in cui il suo posizionamento sia sbagliato.\n"
"Se si preferisce rendere il tutto pi√π facile o pi√π difficile, √® possibile regolare i valori!"

#: src/part2/collision.md:417
msgid "## BONUS: tweaking the bounce height"
msgstr "## BONUS: modifica dell'altezza di rimbalzo"

#: src/part2/collision.md:419
msgid "You might notice that the ball seems to \"sink\" into the paddle a bit before bouncing. This is because the ball bounces when its top row of pixels aligns with the paddle's top row (see the image above). If you want, try to adjust this so that the ball bounces when its bottom row of pixels touches the paddle's top."
msgstr "Si pu√≤ notare che la pallina sembra \"affondare\" un po' nella paletta prima di rimbalzare. Questo perch√© la pallina rimbalza quando la sua riga superiore di pixel si allinea con la riga superiore della paletta (si veda l'immagine sopra). Se volete, provate a regolare questo aspetto in modo che la pallina rimbalzi quando la sua fila di pixel inferiore tocca quella superiore della paletta."

#: src/part2/collision.md:421
msgid "Hint: you can do this with just a single instruction!"
msgstr "Suggerimento: √® possibile farlo con una sola istruzione!"

#: src/part2/collision.md:423
msgid "<details><summary>Answer:</summary>"
msgstr "<details><summary>Risposta:</summary>"

#: src/part2/collision.md:425
msgid "```diff linenos,start=171\n"
"\tld a, [_OAMRAM]\n"
"\tld b, a\n"
"\tld a, [_OAMRAM + 4]\n"
"+\tadd a, 6\n"
"\tcp a, b\n"
"```"
msgstr "```diff linenos,start=171\n"
"\tld a, [_OAMRAM]\n"
"\tld b, a\n"
"\tld a, [_OAMRAM + 4]\n"
"+\tadd a, 6\n"
"\tcp a, b\n"
"```"

#: src/part2/collision.md:433
msgid "Alternatively, you can add `sub a, 6` just after `ld a, [_OAMRAM]`."
msgstr ""

#: src/part2/collision.md:435
msgid "In both cases, try playing with that `6` value; see what feels right!"
msgstr "In entrambi i casi, provate a giocare con il valore `6`; vedete cosa vi sembra giusto!"

#: src/part2/collision.md:437
msgid "</details>"
msgstr "</details>"

#: src/part2/bricks.md:1
msgid "# Bricks"
msgstr ""

#: src/part2/bricks.md:3
msgid "Up until this point our ball hasn't done anything but bounce around, but now we're going to make it destroy the bricks."
msgstr ""

#: src/part2/bricks.md:5
msgid "Before we start, let's go over a new concept: constants.\n"
"We've already used some constants, like `rLCDC` from `hardware.inc`, but we can also create our own for anything we want.\n"
"Let's make three constants at the top of our file, representing the tile IDs of left bricks, right bricks, and blank tiles.\n"
"```rgbasm,linenos,start=1\n"
"INCLUDE \"hardware.inc\""
msgstr ""

#: src/part2/bricks.md:11
msgid "DEF BRICK_LEFT EQU $05\n"
"DEF BRICK_RIGHT EQU $06\n"
"DEF BLANK_TILE EQU $08\n"
"```"
msgstr "DEF BRICK_LEFT EQU $05\n"
"DEF BRICK_RIGHT EQU $06\n"
"DEF BLANK_TILE EQU $08\n"
"```"

#: src/part2/bricks.md:16
msgid "Constants are a kind of *symbol* (which is to say, \"a thing with a name\").\n"
"Writing a constant's name in an expression is equivalent to writing the number the constant is equal to, so `ld a, BRICK_LEFT` is the same as `ld a, $05`.\n"
"But I think we can all agree that the former is much clearer, right?"
msgstr ""

#: src/part2/bricks.md:20
msgid "## Destroying bricks"
msgstr ""

#: src/part2/bricks.md:22
msgid "Now we'll write a function that checks for and destroys bricks.\n"
"Our bricks are two tiles wide, so when we hit one we'll have to remove the adjacent tile as well.\n"
"If we hit the left side of a brick (represented by `BRICK_LEFT`), we need to remove it and the tile to its right (which should be the right side).\n"
"If we instead hit the right side, we need to remove the left!"
msgstr ""

#: src/part2/bricks.md:27
msgid "```rgbasm,linenos,start=282\n"
"; Checks if a brick was collided with and breaks it if possible.\n"
"; @param hl: address of tile.\n"
"CheckAndHandleBrick:\n"
"\tld a, [hl]\n"
"\tcp a, BRICK_LEFT\n"
"\tjr nz, CheckAndHandleBrickRight\n"
"\t; Break a brick from the left side.\n"
"\tld [hl], BLANK_TILE\n"
"\tinc hl\n"
"\tld [hl], BLANK_TILE\n"
"CheckAndHandleBrickRight:\n"
"\tcp a, BRICK_RIGHT\n"
"\tret nz\n"
"\t; Break a brick from the right side.\n"
"\tld [hl], BLANK_TILE\n"
"\tdec hl\n"
"\tld [hl], BLANK_TILE\n"
"\tret\n"
"```"
msgstr ""

#: src/part2/bricks.md:48
msgid "Just insert this function into each of your bounce checks now.\n"
"Make sure you don't miss any!\n"
"It should go right **before** the momentum is modified."
msgstr ""

#: src/part2/bricks.md:52
msgid "```diff,linenos,start=116\n"
"BounceOnTop:\n"
"\t; Remember to offset the OAM position!\n"
"\t; (8, 16) in OAM coordinates is (0, 0) on the screen.\n"
"\tld a, [_OAMRAM + 4]\n"
"\tsub a, 16 + 1\n"
"\tld c, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tsub a, 8\n"
"\tld b, a\n"
"\tcall GetTileByPixel ; Returns tile address in hl\n"
"\tld a, [hl]\n"
"\tcall IsWallTile\n"
"\tjp nz, BounceOnRight\n"
"+\tcall CheckAndHandleBrick\n"
"\tld a, 1\n"
"\tld [wBallMomentumY], a"
msgstr ""

#: src/part2/bricks.md:70
msgid "BounceOnRight:\n"
"\tld a, [_OAMRAM + 4]\n"
"\tsub a, 16\n"
"\tld c, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tsub a, 8 - 1\n"
"\tld b, a\n"
"\tcall GetTileByPixel\n"
"\tld a, [hl]\n"
"\tcall IsWallTile\n"
"\tjp nz, BounceOnLeft\n"
"+\tcall CheckAndHandleBrick\n"
"\tld a, -1\n"
"\tld [wBallMomentumX], a"
msgstr ""

#: src/part2/bricks.md:85
msgid "BounceOnLeft:\n"
"\tld a, [_OAMRAM + 4]\n"
"\tsub a, 16\n"
"\tld c, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tsub a, 8 + 1\n"
"\tld b, a\n"
"\tcall GetTileByPixel\n"
"\tld a, [hl]\n"
"\tcall IsWallTile\n"
"\tjp nz, BounceOnBottom\n"
"+\tcall CheckAndHandleBrick\n"
"\tld a, 1\n"
"\tld [wBallMomentumX], a"
msgstr ""

#: src/part2/bricks.md:100
msgid "BounceOnBottom:\n"
"\tld a, [_OAMRAM + 4]\n"
"\tsub a, 16 - 1\n"
"\tld c, a\n"
"\tld a, [_OAMRAM + 5]\n"
"\tsub a, 8\n"
"\tld b, a\n"
"\tcall GetTileByPixel\n"
"\tld a, [hl]\n"
"\tcall IsWallTile\n"
"\tjp nz, BounceDone\n"
"+\tcall CheckAndHandleBrick\n"
"\tld a, -1\n"
"\tld [wBallMomentumY], a\n"
"BounceDone:\n"
"```"
msgstr ""

#: src/part2/bricks.md:117
msgid "That's it!\n"
"Pretty simple, right?"
msgstr "Tutto qui!\n"
"Piuttosto semplice, no?"

#: src/part2/wip.md:1
msgid "# Work in progress"
msgstr "# Lavori in corso"

#: src/part2/wip.md:3
msgid "::: warning üöß üöß üöß üöß üöß üöß üöß"
msgstr ""

#: src/part2/wip.md:5
msgid "As explained in the initial tutorial presentation, Part ‚Ö° consists of us building an *Arkanoid* game.\n"
"However, this is not finished yet; lessons are uploaded as they are made, so the tutorial just abruptly stops at some point.\n"
"Sorry!"
msgstr "Come spiegato nella presentazione iniziale del tutorial, la Parte ‚Ö° consiste nella costruzione di un gioco *Arkanoid*.\n"
"Tuttavia, questo non √® ancora finito; le lezioni vengono caricate man mano che vengono realizzate, quindi il tutorial si interrompe bruscamente a un certo punto.\n"
"Mi dispiace!"

#: src/part2/wip.md:9
msgid "Please hold tight while we are working on this, [follow us on Twitter](https://twitter.com/gbdev0) for updates, and go to the next page to find out what you can do in the meantime!"
msgstr "Tenete duro mentre ci lavoriamo, [seguiteci su Twitter](https://twitter.com/gbdev0) per gli aggiornamenti e andate alla pagina successiva per scoprire cosa potete fare nel frattempo!"

#: src/part2/wip.md:11
msgid "Thank you for your patience üòä and see you around on GBDev!"
msgstr "Grazie per la vostra pazienza üòä e ci vediamo su GBDev!"

#: src/part3/getting-started.md:3
msgid "# Introducing Galactic Armada"
msgstr ""

#: src/part3/getting-started.md:5
msgid "<img class=\"pixelated\" src=\"../assets/part3/img/rgbds-shmup-gameplay2.gif\">"
msgstr ""

#: src/part3/getting-started.md:7
msgid "This guide will help you create a classic shoot-em-up in RGBDS. This guide builds on knowledge from the previous tutorials, so some basic (or previously explained) concepts will not be explained."
msgstr ""

#: src/part3/getting-started.md:9
msgid "## Feature set"
msgstr ""

#: src/part3/getting-started.md:11
msgid "Here's a list of features that will be included in the final product."
msgstr ""

#: src/part3/getting-started.md:13
msgid "- Vertical Scrolling Background\n"
"- Basic HUD (via Window) & Score\n"
"- 4-Directional Player Movement\n"
"- Enemies\n"
"- Bullets\n"
"- Enemy/Bullet Collision\n"
"- Enemy/Player Collision\n"
"- Smooth Movement via Scaled Integers - Instead of using counters, smoother motion can be achieved using 16-bit (scaled) integers.\n"
"- Multiple Game States: Title Screen, Gameplay, Story State\n"
"- STAT Interrupts - used to properly draw the HUD at the top of gameplay.\n"
"- RGBGFX & INCBIN\n"
"- Writing Text"
msgstr ""

#: src/part3/project-structure.md:1
msgid "# Project Structure"
msgstr "# Struttura progetti"

#: src/part3/project-structure.md:3
msgid "This page is going to give you an idea of how the Galactic Armada project is structured. This includes the folders, resources, tools, entry point, and compilation process."
msgstr ""

#: src/part3/project-structure.md:5
msgid "## Folder Layout"
msgstr "## Struttura della cartella"

#: src/part3/project-structure.md:7
msgid "For organizational purposes, many parts of the logic are separated into reusable functions. This is to reduce duplicate code, and make logic more clear."
msgstr ""

#: src/part3/project-structure.md:9
msgid "Here‚Äôs a basic look at how the project is structured:"
msgstr ""

#: src/part3/project-structure.md:13
msgid "Generated files should never be included in VCS repositories. It unneccessarily bloats the repo. The folders below marked with \\* contains assets generated from running the Makefile and are not included in the repository."
msgstr ""

#: src/part3/project-structure.md:17
msgid "- `libs` - Two assembly files for input and sprites are located here.\n"
"- `src`\n"
"  - `generated` - the results of RGBGFX are stored here. \\*\n"
"  - `resources` - Here exist some PNGs and Aseprite files for usage with RGBGFX\n"
"  - `main` - All assembly files are located here, or in subfolders\n"
"    - `states`\n"
"      - `gameplay` - for gameplay related files\n"
"        - `objects` - for gameplay objects like the player, bullets, and enemies\n"
"          - collision - for collision among objects\n"
"      - `story` - for our story state's related files\n"
"      - `title-screen` - for our title screen's related files\n"
"    - `utils` - Extra functions includes to assist with development\n"
"      - `macros`\n"
"- `dist` - The final ROM file will be created here. \\*\n"
"- `obj` - Intermediate files from the compile process. \\*\n"
"- `Makefile` - used to create the final ROM file and intermediate files"
msgstr ""

#: src/part3/project-structure.md:34
msgid "## Background & Sprite Resources"
msgstr ""

#: src/part3/project-structure.md:36
msgid "The following backgrounds and sprites are used in Galactic Armada:"
msgstr ""

#: src/part3/project-structure.md:38
msgid "- Backgrounds\n"
"  - Star Field\n"
"  - Title Screen\n"
"  - Text Font (Tiles only)\n"
"- Sprites\n"
"  - Enemy Ship\n"
"  - Player Ship\n"
"  - Bullet"
msgstr ""

#: src/part3/project-structure.md:47
msgid "<img class=\"pixelated\" src=\"../assets/part3/img/star-field.png\">"
msgstr "<img class=\"pixelated\" src=\"../assets/part3/img/star-field.png\">"

#: src/part3/project-structure.md:49
msgid "<img class=\"pixelated\" src=\"../assets/part3/img/title-screen.png\">"
msgstr "<img class=\"pixelated\" src=\"../assets/part3/img/title-screen.png\">"

#: src/part3/project-structure.md:51
#: src/part3/project-structure.md:55
msgid "<br>"
msgstr "<br>"

#: src/part3/project-structure.md:53
msgid "<img class=\"pixelated\" src=\"../assets/part3/img/text-font.png\" height=\"48px\">"
msgstr "<img class=\"pixelated\" src=\"../assets/part3/img/text-font.png\" height=\"48px\">"

#: src/part3/project-structure.md:57
msgid "<img class=\"pixelated sprites\" src=\"../assets/part3/img/player-ship.png\" height=\"48px\">"
msgstr "<img class=\"pixelated sprites\" src=\"../assets/part3/img/player-ship.png\" height=\"48px\">"

#: src/part3/project-structure.md:59
msgid "<img class=\"pixelated sprites\" src=\"../assets/part3/img/enemy-ship.png\" height=\"48px\">"
msgstr "<img class=\"pixelated sprites\" src=\"../assets/part3/img/enemy-ship.png\" height=\"48px\">"

#: src/part3/project-structure.md:61
msgid "<img class=\"pixelated sprites\" src=\"../assets/part3/img/bullet.png\" height=\"48x\">"
msgstr ""

#: src/part3/project-structure.md:64
msgid "These images were originally created in Aseprite. The original templates are also included in the repository. They were exported as a PNG **with a specific color palette**. Ater being exported as a PNG, when you run `make`, they are converted into `.2bpp` and `.tilemap` files via the RGBDS tool: RGBGFX."
msgstr ""

#: src/part3/project-structure.md:66
msgid "> The¬†**`rgbgfx`**¬†program converts PNG images into data suitable for display on the Game Boy and Game Boy Color, or vice-versa.\n"
">\n"
"> The main function of¬†**`rgbgfx`**¬†is to divide the input PNG into 8√ó8 pixel¬†*[squares](https://rgbds.gbdev.io/docs/v0.6.1/rgbgfx.1#squares)*, convert each of those squares into 1bpp or 2bpp tile data, and save all of the tile data in a file. It also has options to generate a tile map, attribute map, and/or palette set as well; more on that and how the conversion process can be tweaked below."
msgstr ""

#: src/part3/project-structure.md:70
msgid "RGBGFX can be found here: [https://rgbds.gbdev.io/docs/v0.6.1/rgbgfx.1](https://rgbds.gbdev.io/docs/v0.6.1/rgbgfx.1)"
msgstr ""

#: src/part3/project-structure.md:72
msgid "We'll use it to convert all of our graphics to .2bpp, and .tilemap formats (binary files)"
msgstr ""

#: src/part3/project-structure.md:74
msgid "```bash,linenos,start=48\n"
"NEEDED_GRAPHICS = \\\n"
"\t$(GENSPRITES)/player-ship.2bpp \\\n"
"\t$(GENSPRITES)/enemy-ship.2bpp \\\n"
"\t$(GENSPRITES)/bullet.2bpp \\\n"
"\t$(GENBACKGROUNDS)/text-font.2bpp \\\n"
"\t$(GENBACKGROUNDS)/star-field.tilemap \\\n"
"\t$(GENBACKGROUNDS)/title-screen.tilemap"
msgstr "```bash,linenos,start=48\n"
"NEEDED_GRAPHICS = \\\n"
"\t$(GENSPRITES)/player-ship.2bpp \\\n"
"\t$(GENSPRITES)/enemy-ship.2bpp \\\n"
"\t$(GENSPRITES)/bullet.2bpp \\\n"
"\t$(GENBACKGROUNDS)/text-font.2bpp \\\n"
"\t$(GENBACKGROUNDS)/star-field.tilemap \\\n"
"\t$(GENBACKGROUNDS)/title-screen.tilemap"

#: src/part3/project-structure.md:83
msgid "# Generate sprites, ensuring the containing directories have been created.\n"
"$(GENSPRITES)/%.2bpp: $(RESSPRITES)/%.png | $(GENSPRITES)\n"
"\t$(GFX) -c \"#FFFFFF,#cfcfcf,#686868,#000000;\" --columns -o $@ $<"
msgstr ""

#: src/part3/project-structure.md:87
msgid "# Generate background tile set, ensuring the containing directories have been created.\n"
"$(GENBACKGROUNDS)/%.2bpp: $(RESBACKGROUNDS)/%.png | $(GENBACKGROUNDS)\n"
"\t$(GFX) -c \"#FFFFFF,#cbcbcb,#414141,#000000;\" -o $@ $<"
msgstr ""

#: src/part3/project-structure.md:91
msgid "# Generate background tile map *and* tile set, ensuring the containing directories\n"
"# have been created.\n"
"$(GENBACKGROUNDS)/%.tilemap: $(RESBACKGROUNDS)/%.png | $(GENBACKGROUNDS)\n"
"\t$(GFX) -c \"#FFFFFF,#cbcbcb,#414141,#000000;\" \\\n"
"\t\t--tilemap $@ \\\n"
"\t\t--unique-tiles \\\n"
"\t\t-o $(GENBACKGROUNDS)/$*.2bpp \\\n"
"\t\t$<\n"
"```"
msgstr ""

#: src/part3/project-structure.md:101
msgid "From there, INCBIN commands are used to store reference the binary tile data."
msgstr ""

#: src/part3/project-structure.md:103
msgid "```rgbasm,linenos,start=2"
msgstr "``rgbasm, linenos, start=2"

#: src/part3/project-structure.md:105
#: src/part3/the-player.md:32
msgid "playerShipTileData: INCBIN \"src/generated/sprites/player-ship.2bpp\"\n"
"playerShipTileDataEnd:"
msgstr "playerShipTileData: INCBIN \"src/generated/sprites/player-ship.2bpp\"\n"
"playerShipTileDataEnd:"

#: src/part3/project-structure.md:108
#: src/part3/enemies.md:43
msgid "enemyShipTileData:: INCBIN \"src/generated/sprites/enemy-ship.2bpp\"\n"
"enemyShipTileDataEnd::"
msgstr "enemyShipTileData:: INCBIN \"src/generated/sprites/enemy-ship.2bpp\"\n"
"enemyShipTileDataEnd::"

#: src/part3/project-structure.md:111
#: src/part3/bullets.md:30
msgid "bulletTileData:: INCBIN \"src/generated/sprites/bullet.2bpp\"\n"
"bulletTileDataEnd::"
msgstr "bulletTileData:: INCBIN \"src/generated/sprites/bullet.2bpp\"\n"
"bulletTileDataEnd::"

#: src/part3/project-structure.md:114
#: src/part3/entry-point.md:114
#: src/part3/entry-point.md:161
#: src/part3/changing-game-states.md:71
#: src/part3/story-screen.md:129
#: src/part3/sprites-metasprites.md:28
#: src/part3/object-pools.md:19
#: src/part3/object-pools.md:37
#: src/part3/object-pools.md:53
#: src/part3/bullets.md:34
#: src/part3/enemies.md:36
#: src/part3/enemies.md:175
#: src/part3/enemies.md:256
#: src/part3/enemies.md:359
#: src/part3/collision.md:49
#: src/part3/collision.md:113
#: src/part3/enemy-player-collision.md:75
#: src/part3/enemy-player-collision.md:103
#: src/part3/enemy-player-collision.md:121
msgid "```"
msgstr "```"

#: src/part3/project-structure.md:116
msgid "::: tip Including binary files"
msgstr ""

#: src/part3/project-structure.md:118
msgid "You probably have some graphics, level data, etc. you'd like to include. Use¬†**`INCBIN`**¬†to include a raw binary file as it is. If the file isn't found in the current directory, the include-path list passed to¬†[rgbasm(1)](https://rgbds.gbdev.io/docs/v0.6.1/rgbasm.1)¬†(see the¬†**`-i`**¬†option) on the command line will be searched."
msgstr ""

#: src/part3/project-structure.md:120
msgid "```\n"
"INCBIN \"titlepic.bin\"\n"
"INCBIN \"sprites/hero.bin\"\n"
"```"
msgstr "```\n"
"INCBIN \"titlepic.bin\"\n"
"INCBIN \"sprites/hero.bin\"\n"
"````"

#: src/part3/project-structure.md:125
msgid "You can also include only part of a file with¬†**`INCBIN`**. The example below includes 256 bytes from data.bin, starting from byte 78."
msgstr ""

#: src/part3/project-structure.md:127
msgid "```\n"
"INCBIN \"data.bin\",78,256\n"
"```"
msgstr "```\n"
"INCBIN \"data.bin\",78,256\n"
"```"

#: src/part3/project-structure.md:131
msgid "The length argument is optional. If only the start position is specified, the bytes from the start position until the end of the file will be included."
msgstr ""

#: src/part3/project-structure.md:133
msgid "See also: [Including binary files - RGBASM documentation](https://rgbds.gbdev.io/docs/v0.6.1/rgbasm.5#Including_binary_files)"
msgstr ""

#: src/part3/project-structure.md:137
msgid "## Compilation"
msgstr "## Compilazione"

#: src/part3/project-structure.md:139
msgid "Compilation is done via a Makefile. This Makefile can be run using the `make` command. Make should be preinstalled on Linux and Mac systems. For Windows users, check out [cygwin](https://www.cygwin.com/)."
msgstr ""

#: src/part3/project-structure.md:141
msgid "Without going over everything in detail, here‚Äôs what the Makefile does:"
msgstr ""

#: src/part3/project-structure.md:143
msgid "- Clean generated folders\n"
"- Recreate generated folders\n"
"- Convert PNGs in src/resources to `.2bpp`, and `.tilemap` formats\n"
"- Convert `.asm` files to `.o`\n"
"- Use the `.o` files to build the ROM file\n"
"- Apply the RGBDS ‚Äúfix‚Äù utility."
msgstr ""

#: src/part3/entry-point.md:1
msgid "## Entry Point"
msgstr "## Punto di ingresso"

#: src/part3/entry-point.md:3
msgid "We'll start this tutorial out like the previous, with our \"header\" section (at address: $100). We're also going to declare some global variables that will be used throughout the game."
msgstr ""

#: src/part3/entry-point.md:5
msgid "- `wLastKeys` and `wCurKeys` are used for joypad input\n"
"- `wGameState` will keep track what our current game state is"
msgstr ""

#: src/part3/entry-point.md:8
#: src/part3/entry-point.md:124
msgid "```rgbasm,linenos,start=1\n"
"INCLUDE \"src/main/utils/hardware.inc\""
msgstr "``rgbasm,linenos,start=1\n"
"INCLUDE \"src/main/utils/hardware.inc\""

#: src/part3/entry-point.md:11
msgid "SECTION \"GameVariables\", WRAM0"
msgstr "SECTION \"GameVariables\", WRAM0"

#: src/part3/entry-point.md:13
msgid "wLastKeys:: db\n"
"wCurKeys:: db\n"
"wNewKeys:: db\n"
"wGameState::db"
msgstr ""

#: src/part3/entry-point.md:24
msgid "EntryPoint:\n"
"```"
msgstr "Punto di ingresso:\n"
"```"

#: src/part3/entry-point.md:27
msgid "after our `EntryPoint` label, well do the following:"
msgstr "dopo l'etichetta `EntryPoint`, faremo quanto segue:"

#: src/part3/entry-point.md:29
msgid "- set our default game state\n"
"- initiate [gb-sprobj-lib](https://github.com/eievui5/gb-sprobj-lib), the sprite library we're going to use\n"
"- setup our display registers\n"
"- load tile data for our font into VRAM."
msgstr ""

#: src/part3/entry-point.md:34
msgid "The tile data we are going to load is used by all game states, which is why we'll do it here & now, for them all to use."
msgstr ""

#: src/part3/entry-point.md:36
msgid "<img class=\"pixelated\" src=\"../assets/part3/img/text-font-large.png\">"
msgstr "<img class=\"pixelated\" src=\"../assets/part3/img/text-font-large.png\">"

#: src/part3/entry-point.md:38
msgid "This character-set is called ‚ÄúArea51‚Äù. It, and more 8x8 pixel fonts can ne found here: [https://damieng.com/typography/zx-origins/](https://damieng.com/typography/zx-origins/) . These 52 tiles will be placed at the beginning of our background/window VRAM region."
msgstr ""

#: src/part3/entry-point.md:40
msgid "![TextFontDiagram.png](../assets/part3/img/TextFontDiagram.png)"
msgstr "![TextFontDiagram.png](../assets/part3/img/TextFontDiagram.png)"

#: src/part3/entry-point.md:42
msgid "One important thing to note. Character maps for each letter must be defined. This let‚Äôs RGBDS know what byte value to give a specific letter."
msgstr ""

#: src/part3/entry-point.md:44
msgid "For the Galactic Armada space mapping, we‚Äôre going off the ‚Äútext-font.png‚Äù image. Our space character is the first character in VRAM. Our alphabet starts at 26. Special additions could be added if desired. For now, this is all that we‚Äôll need. We'll define that map in \"src/main/utils/macros/text-macros.inc\"."
msgstr ""

#: src/part3/entry-point.md:46
msgid "```rgbasm,linenos,start=1\n"
"; The character map for the text-font \n"
"CHARMAP \" \", 0\n"
"CHARMAP \".\", 24\n"
"CHARMAP \"-\", 25\n"
"CHARMAP \"a\", 26\n"
"CHARMAP \"b\", 27\n"
"CHARMAP \"c\", 28\n"
"CHARMAP \"d\", 29\n"
"CHARMAP \"e\", 30\n"
"CHARMAP \"f\", 31\n"
"CHARMAP \"g\", 32\n"
"CHARMAP \"h\", 33\n"
"CHARMAP \"i\", 34\n"
"CHARMAP \"j\", 35\n"
"CHARMAP \"k\", 36\n"
"CHARMAP \"l\", 37\n"
"CHARMAP \"m\", 38\n"
"CHARMAP \"n\", 39\n"
"CHARMAP \"o\", 40\n"
"CHARMAP \"p\", 41\n"
"CHARMAP \"q\", 42\n"
"CHARMAP \"r\", 43\n"
"CHARMAP \"s\", 44\n"
"CHARMAP \"t\", 45\n"
"CHARMAP \"u\", 46\n"
"CHARMAP \"v\", 47\n"
"CHARMAP \"w\", 48\n"
"CHARMAP \"x\", 49\n"
"CHARMAP \"y\", 50\n"
"CHARMAP \"z\", 51\n"
"```"
msgstr ""

#: src/part3/entry-point.md:79
msgid "Getting back to our entry point. Were going to wait until a vertical blank begins to do all of this. We'll also turn the LCD off before loading our tile data into VRAM.."
msgstr ""

#: src/part3/entry-point.md:81
msgid "```rgbasm,linenos,start=18\n"
"\t; Shut down audio circuitry\n"
"\tld a, 0\n"
"\tld [rNR52], a"
msgstr ""

#: src/part3/entry-point.md:86
msgid "\tld a, 0\n"
"\tld [wGameState], a"
msgstr "\tld a, 0\n"
"\tld [wGameState], a"

#: src/part3/entry-point.md:89
msgid "\t; Wait for the vertical blank phase before initiating the library\n"
"    call WaitForOneVBlank"
msgstr ""

#: src/part3/entry-point.md:92
msgid "\t; from: https://github.com/eievui5/gb-sprobj-lib\n"
"\t; The library is relatively simple to get set up. First, put the following in your initialization code:\n"
"\t; Initilize Sprite Object Library.\n"
"\tcall InitSprObjLibWrapper"
msgstr ""

#: src/part3/entry-point.md:97
#: src/part3/changing-game-states.md:37
#: src/part3/story-screen.md:140
msgid "\t; Turn the LCD off\n"
"\tld a, 0\n"
"\tld [rLCDC], a"
msgstr ""

#: src/part3/entry-point.md:101
msgid "\t; Load our common text font into VRAM\n"
"\tcall LoadTextFontIntoVRAM"
msgstr ""

#: src/part3/entry-point.md:104
msgid "\t; Turn the LCD on\n"
"\tld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16 | LCDCF_WINON | LCDCF_WIN9C00\n"
"\tld [rLCDC], a"
msgstr ""

#: src/part3/entry-point.md:108
msgid "\t; During the first (blank) frame, initialize display registers\n"
"\tld a, %11100100\n"
"\tld [rBGP], a\n"
"    ld a, %11100100\n"
"\tld [rOBP0], a"
msgstr ""

#: src/part3/entry-point.md:118
msgid "Even though we haven't specifically defined a color palette. The [emulicious](https://emulicious.net/) emulator may automatically apply a default color palette if in \"Automatic\" or \"Gameboy Color\" Mode"
msgstr ""

#: src/part3/entry-point.md:122
msgid "In the above snippet you saw use of a function called `WaitFOrOneVBLank`. We've setup some vblank utility functions in the \"src/main/utils/vblank-utils.asm\" file:"
msgstr ""

#: src/part3/entry-point.md:127
msgid "SECTION \"VBlankVariables\", WRAM0"
msgstr "SECTION \"VBlankVariables\", WRAM0"

#: src/part3/entry-point.md:129
msgid "wVBlankCount:: db "
msgstr "wVBlankCount:: db "

#: src/part3/entry-point.md:131
msgid "SECTION \"VBlankFunctions\", ROM0"
msgstr "SECTION \"VBlankFunctions\", ROM0"

#: src/part3/entry-point.md:133
msgid "WaitForOneVBlank::"
msgstr "WaitForOneVBlank::"

#: src/part3/entry-point.md:135
msgid "    ; Wait a small amount of time\n"
"    ; Save our count in this variable\n"
"    ld a, 1\n"
"    ld [wVBlankCount], a"
msgstr ""

#: src/part3/entry-point.md:140
msgid "WaitForVBlankFunction::"
msgstr "WaitForVBlankFunction::"

#: src/part3/entry-point.md:142
msgid "WaitForVBlankFunction_Loop::"
msgstr "WaitForVBlankFunction_Loop::"

#: src/part3/entry-point.md:144
msgid "\tld a, [rLY] ; Copy the vertical line to a\n"
"\tcp 144 ; Check if the vertical line (in a) is 0\n"
"\tjp c, WaitForVBlankFunction_Loop ; A conditional jump. The condition is that 'c' is set, the last operation overflowed"
msgstr ""

#: src/part3/entry-point.md:148
msgid "    ld a, [wVBlankCount]\n"
"    sub a, 1\n"
"    ld [wVBlankCount], a\n"
"    ret z"
msgstr "    ld a, [wVBlankCount]\n"
"    sub a, 1\n"
"    ld [wVBlankCount], a\n"
"    ret z"

#: src/part3/entry-point.md:153
msgid "WaitForVBlankFunction_Loop2::"
msgstr "WaitForVBlankFunction_Loop2::"

#: src/part3/entry-point.md:155
msgid "\tld a, [rLY] ; Copy the vertical line to a\n"
"\tcp 144 ; Check if the vertical line (in a) is 0\n"
"\tjp nc, WaitForVBlankFunction_Loop2 ; A conditional jump. The condition is that 'c' is set, the last operation overflowed"
msgstr ""

#: src/part3/entry-point.md:159
msgid "    jp WaitForVBlankFunction_Loop"
msgstr "    jp WaitForVBlankFunction_Loop"

#: src/part3/entry-point.md:163
msgid "In the next section, we'll go on next to setup our `NextGameState` label. Which is used for changing game states."
msgstr ""

#: src/part3/changing-game-states.md:1
msgid "# Changing Game States"
msgstr ""

#: src/part3/changing-game-states.md:3
msgid "In our GalacticArmada.asm file, we'll define label called \"NextGameState\". Our game will have 3 game states:"
msgstr ""

#: src/part3/changing-game-states.md:5
msgid "- Title Screen\n"
"- Story Screen\n"
"- Gameplay"
msgstr ""

#: src/part3/changing-game-states.md:9
msgid "Here is how they will flow:"
msgstr "Ecco come scorreranno:"

#: src/part3/changing-game-states.md:11
msgid "![Game States Visualized.png](../assets/part3/img/Game_States_Visualized.png)"
msgstr ""

#: src/part3/changing-game-states.md:13
msgid "When one game state wants to go to another, it will need to change our previously declared 'wGameState' variable and then jump to the \"NextGameState\" label. There are some common things we want to accomplish when changing game states:"
msgstr ""

#: src/part3/changing-game-states.md:15
msgid "(during a Vertical Blank)"
msgstr ""

#: src/part3/changing-game-states.md:17
msgid "- Turn off the LCD\n"
"- Reset our Background & Window positions\n"
"- Clear the Background\n"
"- Disable Interrupts\n"
"- Clear All Sprites\n"
"- Initiate our NEXT game state\n"
"- Jump to our NEXT game state's (looping) update logic"
msgstr ""

#: src/part3/changing-game-states.md:25
msgid "> It will be the responsibility of the \"init\" function for each game state to turn the LCD back on."
msgstr ""

#: src/part3/changing-game-states.md:27
msgid "```rgbasm,linenos,start=50"
msgstr "```rgbasm,linenos,start=50"

#: src/part3/changing-game-states.md:29
msgid "NextGameState::"
msgstr "NextGameState::"

#: src/part3/changing-game-states.md:31
msgid "\t; Do not turn the LCD off outside of VBlank\n"
"    call WaitForOneVBlank"
msgstr ""

#: src/part3/changing-game-states.md:34
msgid "\tcall ClearBackground;"
msgstr "\tcall ClearBackground;"

#: src/part3/changing-game-states.md:41
msgid "\tld a, 0\n"
"\tld [rSCX],a\n"
"\tld [rSCY],a\n"
"\tld [rWX],a\n"
"\tld [rWY],a\n"
"\t; disable interrupts\n"
"\tcall DisableInterrupts\n"
"\t\n"
"\t; Clear all sprites\n"
"\tcall ClearAllSprites"
msgstr "\tld a, 0\n"
"\tld [rSCX],a\n"
"\tld [rSCY],a\n"
"\tld [rWX],a\n"
"\tld [rWY],a\n"
"\t; disabilita gli interrupt\n"
"\tcall DisableInterrupts\n"
"\t\n"
"\t; cancella tutti gli sprite\n"
"\tcall ClearAllSprites"

#: src/part3/changing-game-states.md:52
msgid "\t; Initiate the next state\n"
"\tld a, [wGameState]\n"
"\tcp a, 2 ; 2 = Gameplay\n"
"\tcall z, InitGameplayState\n"
"\tld a, [wGameState]\n"
"\tcp a, 1 ; 1 = Story\n"
"\tcall z, InitStoryState\n"
"\tld a, [wGameState]\n"
"\tcp a, 0 ; 0 = Menu\n"
"\tcall z, InitTitleScreenState"
msgstr ""

#: src/part3/changing-game-states.md:63
msgid "\t; Update the next state\n"
"\tld a, [wGameState]\n"
"\tcp a, 2 ; 2 = Gameplay\n"
"\tjp z, UpdateGameplayState\n"
"\tcp a, 1 ; 1 = Story\n"
"\tjp z, UpdateStoryState\n"
"\tjp UpdateTitleScreenState"
msgstr ""

#: src/part3/changing-game-states.md:73
msgid "The goal here is to ( as much as possible) give each new game state a _blank slate_ to start with."
msgstr ""

#: src/part3/changing-game-states.md:75
msgid "That's it for the GalacticArmada.asm file."
msgstr ""

#: src/part3/title-screen.md:1
msgid "# Title Screen"
msgstr "# Schermata del titolo"

#: src/part3/title-screen.md:3
msgid "The title screen shows a basic title image using the background and draws text asking the player to press A. Once the user presses A, it will go to the story screen."
msgstr ""

#: src/part3/title-screen.md:5
msgid "<img src=\"../assets/part3/img/title-screen-large.png\" class=\"pixelated\">"
msgstr "<img src=\"../assets/part3/img/title-screen-large.png\" class=\"pixelated\">"

#: src/part3/title-screen.md:7
msgid "Our title screen has 3 pieces of data:"
msgstr ""

#: src/part3/title-screen.md:9
msgid "* The \"Press A to play\" text\n"
"* The title screen tile data\n"
"* The title screen tilemap"
msgstr ""

#: src/part3/title-screen.md:13
#: src/part3/story-screen.md:19
#: src/part3/gameplay.md:11
#: src/part3/scrolling-background.md:14
msgid "```rgbasm,linenos,start=1\n"
"INCLUDE \"src/main/utils/hardware.inc\"\n"
"INCLUDE \"src/main/utils/macros/text-macros.inc\""
msgstr "``rgbasm,linenos,start=1\n"
"INCLUDE \"src/main/utils/hardware.inc\"\n"
"INCLUDE \"src/main/utils/macros/text-macros.inc\""

#: src/part3/title-screen.md:17
msgid "SECTION \"TitleScreenState\", ROM0"
msgstr "SECTION \"TitleScreenState\", ROM0"

#: src/part3/title-screen.md:19
msgid "wPressPlayText::  db \"press a to play\", 255\n"
" \n"
"titleScreenTileData: INCBIN \"src/generated/backgrounds/title-screen.2bpp\"\n"
"titleScreenTileDataEnd:\n"
" \n"
"titleScreenTileMap: INCBIN \"src/generated/backgrounds/title-screen.tilemap\"\n"
"titleScreenTileMapEnd:\n"
"```"
msgstr ""

#: src/part3/title-screen.md:28
msgid "## Initiating the Title Screen"
msgstr "## Avvio della schermata del titolo"

#: src/part3/title-screen.md:30
msgid "In our title screen's \"InitTitleScreen\" function, we'll do the following:\n"
"* draw the title screen graphic\n"
"* draw our \"Press A to play\"\n"
"* turn on the LCD. "
msgstr ""

#: src/part3/title-screen.md:36
msgid "Here is what our \"InitTitleScreenState\" function looks like"
msgstr ""

#: src/part3/title-screen.md:38
msgid "```rgbasm,linenos,start=13\n"
"InitTitleScreenState::"
msgstr "``rgbasm,linenos,start=13\n"
"InitTitleScreenState::"

#: src/part3/title-screen.md:41
msgid "\tcall DrawTitleScreen\n"
"\t\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ; Draw the press play text\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr "\tcall DrawTitleScreen\n"
"\t\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ; Disegna il testo \"press play\"\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"

#: src/part3/title-screen.md:47
msgid "\t; Call Our function that draws text onto background/window tiles\n"
"    ld de, $99C3\n"
"    ld hl, wPressPlayText\n"
"    call DrawTextTilesLoop"
msgstr ""

#: src/part3/title-screen.md:52
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"

#: src/part3/title-screen.md:56
#: src/part3/story-screen.md:27
#: src/part3/story-screen.md:160
msgid "\t; Turn the LCD on\n"
"\tld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16\n"
"\tld [rLCDC], a"
msgstr ""

#: src/part3/title-screen.md:60
#: src/part3/story-screen.md:31
#: src/part3/gameplay.md:90
#: src/part3/the-player.md:85
msgid "    ret;\n"
"```"
msgstr "    ret;\n"
"````"

#: src/part3/title-screen.md:63
msgid "In order to draw text in our game, we've created a function called \"DrawTextTilesLoop\". We'll pass this function which tile to start on in `de`, and the address of our text in `hl`."
msgstr ""

#: src/part3/title-screen.md:65
msgid "```rgbasm,linenos,start=15\n"
"DrawTextTilesLoop::"
msgstr "``rgbasm,linenos,start=15\n"
"DrawTextilesLoop::"

#: src/part3/title-screen.md:68
msgid "    ; Check for the end of string character 255\n"
"    ld a, [hl]\n"
"    cp 255\n"
"    ret z"
msgstr ""

#: src/part3/title-screen.md:73
#: src/part3/story-screen.md:75
msgid "    ; Write the current character (in hl) to the address\n"
"    ; on the tilemap (in de)\n"
"    ld a, [hl]\n"
"    ld [de], a"
msgstr ""

#: src/part3/title-screen.md:78
msgid "    inc hl\n"
"    inc de"
msgstr "    inc hl\n"
"    inc de"

#: src/part3/title-screen.md:81
msgid "    ; move to the next character and next background tile\n"
"    jp DrawTextTilesLoop\n"
"```"
msgstr ""

#: src/part3/title-screen.md:85
msgid "The \"DrawTitleScreen\" function puts the tiles for our title screen graphic in VRAM, and draws its tilemap to the background:"
msgstr ""

#: src/part3/title-screen.md:87
msgid "> **NOTE:** Because of the text font, we'll add an offset of 52 to our tilemap tiles. We've created a function that adds the 52 offset, since we'll need to do so more than once."
msgstr ""

#: src/part3/title-screen.md:89
msgid "```rgbasm,linenos,start=36\n"
"DrawTitleScreen::\n"
"\t\n"
"\t; Copy the tile data\n"
"\tld de, titleScreenTileData ; de contains the address where data will be copied from;\n"
"\tld hl, $9340 ; hl contains the address where data will be copied to;\n"
"\tld bc, titleScreenTileDataEnd - titleScreenTileData ; bc contains how many bytes we have to copy.\n"
"\tcall CopyDEintoMemoryAtHL;\n"
"\t\n"
"\t; Copy the tilemap\n"
"\tld de, titleScreenTileMap\n"
"\tld hl, $9800\n"
"\tld bc, titleScreenTileMapEnd - titleScreenTileMap\n"
"\tcall CopyDEintoMemoryAtHL_With52Offset"
msgstr ""

#: src/part3/title-screen.md:104
#: src/part3/story-screen.md:165
#: src/part3/scrolling-background.md:49
msgid "\tret\n"
"```"
msgstr "\tret\n"
"```"

#: src/part3/title-screen.md:107
msgid "The \"CopyDEintoMemoryAtHL\" and \"CopyDEintoMemoryAtHL_With52Offset\" functions are defined in \"src/main/utils/memory-utils.asm\":"
msgstr ""

#: src/part3/title-screen.md:109
msgid "```rgbasm,linenos,start=1\n"
"SECTION \"MemoryUtilsSection\", ROM0"
msgstr "``rgbasm,linenos,start=1\n"
"SECTION \"MemoryUtilsSection\", ROM0"

#: src/part3/title-screen.md:112
msgid "CopyDEintoMemoryAtHL::\n"
"\tld a, [de]\n"
"\tld [hli], a\n"
"\tinc de\n"
"\tdec bc\n"
"\tld a, b\n"
"\tor a, c\n"
"\tjp nz, CopyDEintoMemoryAtHL ; Jump to COpyTiles, if the z flag is not set. (the last operation had a non zero result)\n"
"\tret;"
msgstr ""

#: src/part3/title-screen.md:122
msgid "CopyDEintoMemoryAtHL_With52Offset::\n"
"\tld a, [de]\n"
"    add a, 52 \n"
"\tld [hli], a\n"
"\tinc de\n"
"\tdec bc\n"
"\tld a, b\n"
"\tor a, c\n"
"\tjp nz, CopyDEintoMemoryAtHL_With52Offset ; Jump to COpyTiles, if the z flag is not set. (the last operation had a non zero result)\n"
"\tret;\n"
"```"
msgstr ""

#: src/part3/title-screen.md:134
msgid "## Updating the Title Screen"
msgstr ""

#: src/part3/title-screen.md:136
msgid "The title screen's update logic is the simplest of the 3. All we are going to do is wait until the A button is pressed. Afterwards, we'll go to the story screen game state."
msgstr ""

#: src/part3/title-screen.md:138
msgid "```rgbasm,linenos,start=52\n"
"UpdateTitleScreenState::"
msgstr "```rgbasm,linenos,start=52\n"
"UpdateTitleScreenState::"

#: src/part3/title-screen.md:141
#: src/part3/story-screen.md:117
#: src/part3/story-screen.md:189
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ; Wait for A\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/title-screen.md:145
#: src/part3/story-screen.md:121
#: src/part3/story-screen.md:193
msgid "    ; Save the passed value into the variable: mWaitKey\n"
"    ; The WaitForKeyFunction always checks against this vriable\n"
"    ld a,PADF_A\n"
"    ld [mWaitKey], a"
msgstr ""

#: src/part3/title-screen.md:150
msgid "    call WaitForKeyFunction"
msgstr "    call WaitForKeyFunction"

#: src/part3/title-screen.md:152
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/title-screen.md:155
msgid "    ld a, 1\n"
"    ld [wGameState],a\n"
"    jp NextGameState\n"
"```"
msgstr "    ld a, 1\n"
"    ld [wGameState],a\n"
"    jp NextGameState\n"
"```"

#: src/part3/title-screen.md:160
msgid "Our \"WaitForKeyFunction\" is defined in \"src/main/utils/input-utils.asm\". We'll poll for input and infinitely loop until the specified button is pressed down."
msgstr ""

#: src/part3/title-screen.md:162
msgid "```rgbasm,linenos,start=1\n"
"SECTION \"InputUtilsVariables\", WRAM0"
msgstr ""

#: src/part3/title-screen.md:165
msgid "mWaitKey:: db"
msgstr "mWaitKey:: db"

#: src/part3/title-screen.md:167
msgid "SECTION \"InputUtils\", ROM0"
msgstr "SECTION \"InputUtils\", ROM0"

#: src/part3/title-screen.md:169
msgid "WaitForKeyFunction::"
msgstr "WaitForKeyFunction::"

#: src/part3/title-screen.md:171
msgid "    ; Save our original value\n"
"    push bc"
msgstr ""

#: src/part3/title-screen.md:174
msgid "\t\n"
"WaitForKeyFunction_Loop:"
msgstr "\t\n"
"WaitForKeyFunction_Loop:"

#: src/part3/title-screen.md:177
msgid "\t; save the keys last frame\n"
"\tld a, [wCurKeys]\n"
"\tld [wLastKeys], a\n"
"    \n"
"\t; This is in input.asm\n"
"\t; It's straight from: https://gbdev.io/gb-asm-tutorial/part2/input.html\n"
"\t; In their words (paraphrased): reading player input for gameboy is NOT a trivial task\n"
"\t; So it's best to use some tested code\n"
"    call Input"
msgstr ""

#: src/part3/title-screen.md:187
msgid "    \n"
"\tld a, [mWaitKey]\n"
"    ld b,a\n"
"\tld a, [wCurKeys]\n"
"    and a, b\n"
"    jp z,WaitForKeyFunction_NotPressed\n"
"    \n"
"\tld a, [wLastKeys]\n"
"    and a, b\n"
"    jp nz,WaitForKeyFunction_NotPressed"
msgstr ""

#: src/part3/title-screen.md:198
msgid "\t; restore our original value\n"
"\tpop bc"
msgstr ""

#: src/part3/title-screen.md:201
#: src/part3/the-player.md:136
#: src/part3/the-player.md:149
#: src/part3/enemy-player-collision.md:119
msgid "    ret"
msgstr "    ret"

#: src/part3/title-screen.md:204
msgid "WaitForKeyFunction_NotPressed:"
msgstr "WaitForKeyFunction_NotPressed:"

#: src/part3/title-screen.md:206
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ; Wait a small amount of time\n"
"    ; Save our count in this variable\n"
"    ld a, 1\n"
"    ld [wVBlankCount], a"
msgstr ""

#: src/part3/title-screen.md:212
#: src/part3/story-screen.md:65
msgid "    ; Call our function that performs the code\n"
"    call WaitForVBlankFunction\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/title-screen.md:216
msgid "    jp WaitForKeyFunction_Loop\n"
"```"
msgstr "    jp WaitForKeyFunction_Loop\n"
"```"

#: src/part3/title-screen.md:219
msgid "That's it for our title screen. Next up is our story screen."
msgstr ""

#: src/part3/story-screen.md:1
msgid "# Story Screen"
msgstr "# Schermata della storia"

#: src/part3/story-screen.md:3
msgid "The story screen shows a basic story on 2 pages. Afterwards, it sends the player to the gameplay game state."
msgstr ""

#: src/part3/story-screen.md:5
msgid "<img src=\"../assets/part3/img/GalacticArmada-1.png\" class=\"pixelated\" height=\"288px\">"
msgstr "<img src=\"../assets/part3/img/GalacticArmada-1.png\" class=\"pixelated\" height=\"288px\">"

#: src/part3/story-screen.md:7
msgid "<img src=\"../assets/part3/img/GalacticArmada-2.png\" class=\"pixelated\" height=\"288px\">"
msgstr "<img src=\"../assets/part3/img/GalacticArmada-2.png\" class=\"pixelated\" height=\"288px\">"

#: src/part3/story-screen.md:9
msgid "## Initiating up the Story Screen"
msgstr ""

#: src/part3/story-screen.md:11
msgid "In the `InitStoryState` we'll just going to turn on the LCD. Most of the game state's logic will occur in its update function."
msgstr ""

#: src/part3/story-screen.md:15
msgid "The text macros file is included so our story text has the proper character maps."
msgstr ""

#: src/part3/story-screen.md:23
msgid "SECTION \"StoryStateASM\", ROM0"
msgstr "SECTION \"StoryStateASM\", ROM0"

#: src/part3/story-screen.md:25
msgid "InitStoryState::"
msgstr "InitStoryState::"

#: src/part3/story-screen.md:34
msgid "## Updating the Story Screen"
msgstr ""

#: src/part3/story-screen.md:36
msgid "Here's the data for our story screen. We have this defined just above our `UpdateStoryState` function:"
msgstr ""

#: src/part3/story-screen.md:38
msgid "```rgbasm,linenos,start=14\n"
"Story: \n"
"    .Line1 db \"the galatic empire\", 255\n"
"    .Line2 db \"rules the galaxy\", 255\n"
"    .Line3 db \"with an iron\", 255\n"
"    .Line4 db \"fist.\", 255\n"
"    .Line5 db \"the rebel force\", 255\n"
"    .Line6 db \"remain hopeful of\", 255\n"
"    .Line7 db \"freedoms light\", 255\n"
"\t\n"
"```"
msgstr ""

#: src/part3/story-screen.md:50
msgid "The story text is shown using a typewriter effect. This effect is done similarly to the ‚Äúpress a to play‚Äù text that was done before, but here we wait for 3 vertical blank phases between writing each letter, giving some additional delay."
msgstr ""

#: src/part3/story-screen.md:52
msgid "> You could bind this to a variable and make it configurable via an options screen too!"
msgstr ""

#: src/part3/story-screen.md:54
msgid "For this effect, we've defined a function in our \"src/main/utils/text-utils.asm\" file:"
msgstr ""

#: src/part3/story-screen.md:56
msgid "```rgbasm,linenos,start=33\n"
"DrawText_WithTypewriterEffect::"
msgstr ""

#: src/part3/story-screen.md:59
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ; Wait a small amount of time\n"
"    ; Save our count in this variable\n"
"    ld a, 3\n"
"    ld [wVBlankCount], a"
msgstr ""

#: src/part3/story-screen.md:69
msgid "    \n"
"    ; Check for the end of string character 255\n"
"    ld a, [hl]\n"
"    cp 255\n"
"    ret z"
msgstr ""

#: src/part3/story-screen.md:80
msgid "    ; move to the next character and next background tile\n"
"    inc hl\n"
"    inc de"
msgstr ""

#: src/part3/story-screen.md:84
msgid "    jp DrawText_WithTypewriterEffect\n"
"```"
msgstr ""

#: src/part3/story-screen.md:87
msgid "We'll call the `DrawText_WithTypewriterEffect` function exactly how we called the `DrawTextTilesLoop` function. We'll pass this function which tile to start on in de, and the address of our text in hl."
msgstr ""

#: src/part3/story-screen.md:89
msgid "We'll do that four times for the first page, and then wait for the A button to be pressed:"
msgstr ""

#: src/part3/story-screen.md:91
msgid "```rgbasm,linenos,start=23\n"
"UpdateStoryState::"
msgstr ""

#: src/part3/story-screen.md:94
msgid "    ; Call Our function that typewrites text onto background/window tiles\n"
"    ld de, $9821\n"
"    ld hl, Story.Line1\n"
"    call DrawText_WithTypewriterEffect"
msgstr ""

#: src/part3/story-screen.md:100
msgid "    ; Call Our function that typewrites text onto background/window tiles\n"
"    ld de, $9861\n"
"    ld hl, Story.Line2\n"
"    call DrawText_WithTypewriterEffect"
msgstr ""

#: src/part3/story-screen.md:106
msgid "    ; Call Our function that typewrites text onto background/window tiles\n"
"    ld de, $98A1\n"
"    ld hl, Story.Line3\n"
"    call DrawText_WithTypewriterEffect"
msgstr ""

#: src/part3/story-screen.md:112
msgid "    ; Call Our function that typewrites text onto background/window tiles\n"
"    ld de, $98E1\n"
"    ld hl, Story.Line4\n"
"    call DrawText_WithTypewriterEffect"
msgstr ""

#: src/part3/story-screen.md:126
msgid "    call WaitForKeyFunction\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/story-screen.md:131
msgid "Once the user presses the A button, we want to show the second page. To avoid any lingering \"leftover\" letters, we'll clear the background. All this function does is turn off the LCD, fill our background tilemap with the first tile, then turn back on the lcd. We've defined this function in the \"src/main/utils/background.utils.asm\" file:"
msgstr ""

#: src/part3/story-screen.md:133
msgid "```rgbasm,linenos,start=1\n"
"include \"src/main/utils/hardware.inc\""
msgstr ""

#: src/part3/story-screen.md:136
msgid "SECTION \"Background\", ROM0"
msgstr "SECTION \"Background\", ROM0"

#: src/part3/story-screen.md:138
msgid "ClearBackground::"
msgstr "ClearBackground::"

#: src/part3/story-screen.md:144
msgid "\tld bc,1024\n"
"\tld hl, $9800"
msgstr "\tld bc,1024\n"
"\tld hl, $9800"

#: src/part3/story-screen.md:147
msgid "ClearBackgroundLoop:"
msgstr "ClearBackgroundLoop:"

#: src/part3/story-screen.md:149
msgid "\tld a,0\n"
"\tld [hli], a"
msgstr "\tld a,0\n"
"\tld [hli], a"

#: src/part3/story-screen.md:152
msgid "\t\n"
"\tdec bc\n"
"\tld a, b\n"
"\tor a, c"
msgstr "\t\n"
"\tdec bc\n"
"\tld a, b\n"
"\tor a, c"

#: src/part3/story-screen.md:157
msgid "\tjp nz, ClearBackgroundLoop"
msgstr "\tjp nz, ClearBackgroundLoop"

#: src/part3/story-screen.md:168
msgid "Getting back to our Story Screen: After we've shown the first page and cleared the background, we'll do the same thing for page 2:"
msgstr ""

#: src/part3/story-screen.md:170
msgid "```rgbasm,linenos,start=65\n"
"    ; Call Our function that typewrites text onto background/window tiles\n"
"    ld de, $9821\n"
"    ld hl, Story.Line5\n"
"    call DrawText_WithTypewriterEffect"
msgstr ""

#: src/part3/story-screen.md:177
msgid "    ; Call Our function that typewrites text onto background/window tiles\n"
"    ld de, $9861\n"
"    ld hl, Story.Line6\n"
"    call DrawText_WithTypewriterEffect"
msgstr ""

#: src/part3/story-screen.md:183
msgid "    ; Call Our function that typewrites text onto background/window tiles\n"
"    ld de, $98A1\n"
"    ld hl, Story.Line7\n"
"    call DrawText_WithTypewriterEffect"
msgstr ""

#: src/part3/story-screen.md:198
msgid "    call WaitForKeyFunction\n"
"    \n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr "    call WaitForKeyFunction\n"
"    \n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"

#: src/part3/story-screen.md:202
#: src/part3/enemy-player-collision.md:51
msgid "    \n"
"```"
msgstr "    \n"
"```"

#: src/part3/story-screen.md:205
msgid "With our story full shown, we're ready to move onto the next game state: Gameplay. We'll end our `UpdateStoryState` function by updating our game state variable and jump back to the `NextGameState` label like previously discussed."
msgstr ""

#: src/part3/story-screen.md:207
msgid "```rgbasm,linenos,start=98\n"
"    ld a, 2\n"
"    ld [wGameState],a\n"
"    jp NextGameState\n"
"```"
msgstr ""

#: src/part3/gameplay.md:1
msgid "# Gameplay State"
msgstr ""

#: src/part3/gameplay.md:3
msgid "In this game state, the player will control a spaceship. Flying over a vertically scrolling space background. They‚Äôll be able to freely move in 4 directions , and shoot oncoming alien ships. As alien ships are destroyed by bullets, the player‚Äôs score will increase."
msgstr ""

#: src/part3/gameplay.md:5
msgid "![rgbds-shmup-gameplay.gif](../assets/part3/img/rgbds-shmup-gameplay.gif)"
msgstr "![rgbds-shmup-gameplay.gif](../assets/part3/img/rgbds-shmup-gameplay.gif)"

#: src/part3/gameplay.md:7
msgid "Gameplay is the core chunk of the source code. It also took the most time to create. Because of such, this game state has to be split into multiple sub-pages. Each page will explain a different gameplay concept."
msgstr ""

#: src/part3/gameplay.md:9
msgid "Our gameplay state defines the following data and variables:"
msgstr ""

#: src/part3/gameplay.md:15
msgid "SECTION \"GameplayVariables\", WRAM0"
msgstr "SECTION \"GameplayVariables\", WRAM0"

#: src/part3/gameplay.md:17
msgid "wScore:: ds 6\n"
"wLives:: db"
msgstr "wScore:: ds 6\n"
"wLives:: db"

#: src/part3/gameplay.md:20
msgid "SECTION \"GameplayState\", ROM0"
msgstr "SECTION \"GameplayState\", ROM0"

#: src/part3/gameplay.md:22
msgid "wScoreText::  db \"score\", 255\n"
"wLivesText::  db \"lives\", 255\n"
"```"
msgstr "wScoreText::  db \"score\", 255\n"
"wLivesText::  db \"lives\", 255\n"
"```"

#: src/part3/gameplay.md:26
msgid "For simplicity reasons, our score uses 6 bytes. Each byte repesents one digit in the score."
msgstr ""

#: src/part3/gameplay.md:28
msgid "## Initiating the Gameplay Game State:"
msgstr ""

#: src/part3/gameplay.md:30
msgid "When gameplay starts we want to do all of the following:\n"
"- reset the player's score to 0\n"
"- reset the player's lives to 3. \n"
"- Initialize all of our gameplay elements ( background, player, bullets, and enemies)\n"
"- Enable STAT interrupts for the HUD\n"
"- Draw our \"score\" & \"lives\"  on the HUD.\n"
"- Reset the window's position back to 7,0\n"
"- Turn the LCD on with the window enabled at $9C00"
msgstr ""

#: src/part3/gameplay.md:39
msgid "```rgbasm,linenos,start=14\n"
"InitGameplayState::"
msgstr "```rgbasm,linenos,start=14\n"
"InitGameplayState::"

#: src/part3/gameplay.md:42
msgid "\tld a, 3\n"
"\tld [wLives+0], a"
msgstr "\tld a, 3\n"
"\tld [wLives+0], a"

#: src/part3/gameplay.md:45
msgid "\tld a, 0\n"
"\tld [wScore+0], a\n"
"\tld [wScore+1], a\n"
"\tld [wScore+2], a\n"
"\tld [wScore+3], a\n"
"\tld [wScore+4], a\n"
"\tld [wScore+5], a"
msgstr "\tld a, 0\n"
"\tld [wScore+0], a\n"
"\tld [wScore+1], a\n"
"\tld [wScore+2], a\n"
"\tld [wScore+3], a\n"
"\tld [wScore+4], a\n"
"\tld [wScore+5], a"

#: src/part3/gameplay.md:53
msgid "\tcall InitializeBackground\n"
"\tcall InitializePlayer\n"
"\tcall InitializeBullets\n"
"\tcall InitializeEnemies"
msgstr "\tcall InitializeBackground\n"
"\tcall InitializePlayer\n"
"\tcall InitializeBullets\n"
"\tcall InitializeEnemies"

#: src/part3/gameplay.md:58
msgid "\t; Initiate STAT interrupts\n"
"\tcall InitStatInterrupts"
msgstr ""

#: src/part3/gameplay.md:61
msgid "\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/gameplay.md:64
msgid "\t; Call Our function that draws text onto background/window tiles\n"
"    ld de, $9c00\n"
"    ld hl, wScoreText\n"
"    call DrawTextTilesLoop"
msgstr ""

#: src/part3/gameplay.md:69
msgid "\t; Call Our function that draws text onto background/window tiles\n"
"    ld de, $9c0D\n"
"    ld hl, wLivesText\n"
"    call DrawTextTilesLoop\n"
"\t\n"
"\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/gameplay.md:77
msgid "\tcall DrawScore\n"
"\tcall DrawLives"
msgstr ""

#: src/part3/gameplay.md:80
msgid "\tld a, 0\n"
"\tld [rWY], a"
msgstr "\tld a, 0\n"
"\tld [rWY], a"

#: src/part3/gameplay.md:83
msgid "\tld a, 7\n"
"\tld [rWX], a"
msgstr "\tld a, 7\n"
"\tld [rWX], a"

#: src/part3/gameplay.md:86
msgid "\t; Turn the LCD on\n"
"\tld a, LCDCF_ON  | LCDCF_BGON|LCDCF_OBJON | LCDCF_OBJ16 | LCDCF_WINON | LCDCF_WIN9C00|LCDCF_BG9800\n"
"\tld [rLCDC], a"
msgstr ""

#: src/part3/gameplay.md:93
msgid "The initialization logic for our the background, the player, the enemies, the bullets will be explained in later pages. Every game state is responsible for turning the LCD back on. The gameplay game state needs to use the window layer, so we'll make sure that's enabled before we return."
msgstr ""

#: src/part3/gameplay.md:95
msgid "## Updating the Gameplay Game State"
msgstr ""

#: src/part3/gameplay.md:97
msgid "Our \"UpdateGameplayState\" function doesn't have very complicated logic. Most of the logic has been split into separate files for the background, player, enemies, and bullets."
msgstr ""

#: src/part3/gameplay.md:99
msgid "During gameplay, we do all of the following:\n"
"* Poll for input\n"
"* Reset our Shadow OAM\n"
"* Reset our current shadow OAM sprite\n"
"* Update our gameplay elements (player, background, enemies, bullets, background)\n"
"* Remove any unused sprites from the screen\n"
"* End gameplay if we've lost all of our lives\n"
"* inside of the vertical blank phase\n"
"    * Apply shadow OAM sprites \n"
"    * Update our background tilemap's position"
msgstr ""

#: src/part3/gameplay.md:110
msgid "We'll poll for input like in the previous tutorial. We'll always save the previous state of the gameboy's buttons in the \"wLastKeys\" variable."
msgstr ""

#: src/part3/gameplay.md:112
msgid "```rgbasm,linenos,start=66\n"
"UpdateGameplayState::"
msgstr "```rgbasm,linenos,start=66\n"
"UpdateGameplayState::"

#: src/part3/gameplay.md:115
msgid "\t; save the keys last frame\n"
"\tld a, [wCurKeys]\n"
"\tld [wLastKeys], a"
msgstr ""

#: src/part3/gameplay.md:119
msgid "\t; This is in input.asm\n"
"\t; It's straight from: https://gbdev.io/gb-asm-tutorial/part2/input.html\n"
"\t; In their words (paraphrased): reading player input for gameboy is NOT a trivial task\n"
"\t; So it's best to use some tested code\n"
"    call Input\n"
"```"
msgstr ""

#: src/part3/gameplay.md:126
msgid "Next, we'll reset our Shadow OAM and reset current Shadow OAM sprite address. "
msgstr ""

#: src/part3/gameplay.md:128
msgid "```rgbasm,linenos,start=78\n"
"\t; from: https://github.com/eievui5/gb-sprobj-lib\n"
"\t; hen put a call to ResetShadowOAM at the beginning of your main loop.\n"
"\tcall ResetShadowOAM\n"
"\tcall ResetOAMSpriteAddress\n"
"```"
msgstr ""

#: src/part3/gameplay.md:135
msgid "Because we are going to be dealing with a lot of sprites on the screen, we will not be directly manipulating the gameboy's OAM sprites. We'll define a set of \"shadow\" (copy\") OAM sprites, that all objects will use instaed. At the end of the gameplay looop, we'll copy the shadow OAM sprite objects into the hardware."
msgstr ""

#: src/part3/gameplay.md:137
msgid "Each object will use a random shadow OAM sprite. We need a way to keep track of what shadow OAM sprite is being used currently. For this, we've created a 16-bit pointer called \"wLastOAMAddress\". Defined in \"src/main/utils/sprites.asm\", this points to the data for the next inactive shadow OAM sprite. "
msgstr ""

#: src/part3/gameplay.md:139
msgid "When we reset our current Shadow OAM sprite address, we just set the \"mLastOAMAddress\" RAM variable to point to the first shadow OAM sprite. "
msgstr ""

#: src/part3/gameplay.md:141
msgid "> **NOTE:** We also keep a counter on how many shadow OAM sprites are used. In our \"ResetOAMSpriteAddress\" function, we'll reset that counter too."
msgstr ""

#: src/part3/gameplay.md:143
msgid "```rgbasm,linenos,start=64\n"
"ResetOAMSpriteAddress::\n"
"    \n"
"    ld a, 0\n"
"    ld [wSpritesUsed], a"
msgstr ""

#: src/part3/gameplay.md:149
msgid "\tld a, LOW(wShadowOAM)\n"
"\tld [wLastOAMAddress+0], a\n"
"\tld a, HIGH(wShadowOAM)\n"
"\tld [wLastOAMAddress+1], a"
msgstr ""

#: src/part3/gameplay.md:154
#: src/part3/heads-up-interface.md:59
#: src/part3/heads-up-interface.md:203
#: src/part3/sprites-metasprites.md:154
#: src/part3/the-player.md:174
#: src/part3/the-player.md:187
#: src/part3/the-player.md:320
#: src/part3/the-player.md:339
#: src/part3/bullets.md:346
#: src/part3/enemies.md:419
#: src/part3/enemy-bullet-collision.md:200
msgid "    ret\n"
"```"
msgstr ""

#: src/part3/gameplay.md:157
msgid "Next we'll update our gameplay elements:\n"
"```rgbasm,linenos,start=83\n"
"\tcall UpdatePlayer\n"
"\tcall UpdateEnemies\n"
"\tcall UpdateBullets\n"
"\tcall UpdateBackground\n"
"```"
msgstr ""

#: src/part3/gameplay.md:165
msgid "After all of that, at this point in time, the majority of gameplay is done for this iteration. We'll clear any remaining spirtes. This is very necessary becaus the number of active sprites changes from frame to frame. If there are any visible OAM sprites left onscreen, they will look weird and/or mislead the player. "
msgstr ""

#: src/part3/gameplay.md:167
msgid "```rgbasm,linenos,start=88\n"
"\t; Clear remaining sprites to avoid lingering rogue sprites\n"
"\tcall ClearRemainingSprites\n"
"```"
msgstr ""

#: src/part3/gameplay.md:172
msgid "The clear remaining sprites function, for all remaining shadow OAM sprites, moves the sprite offscreen so they are no longer visible. This function starts at wherever the \"wLastOAMAddress\" variable last left-off."
msgstr ""

#: src/part3/gameplay.md:174
msgid "#### End of The Gameplay loop"
msgstr ""

#: src/part3/gameplay.md:176
msgid "At this point in time, we need to check if gameplay needs to continue. When the vertical blank phase starts, we check if the player has lost all of their lives. If so, we end gameplay. We end gameplay similar to how we started it, we'll update our 'wGameState' variable and jump to \"NextGameState\"."
msgstr ""

#: src/part3/gameplay.md:178
msgid "If the player hasn't lost all of their lives, we'll copy our shadow OAM sprites over to the actual hardware OAM sprites and loop background."
msgstr ""

#: src/part3/gameplay.md:180
msgid "```rgbasm,linenos,start=91\n"
"\tld a, [wLives]\n"
"\tcp a, 250\n"
"\tjp nc, EndGameplay"
msgstr ""

#: src/part3/gameplay.md:185
msgid "\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ; Call our function that performs the code\n"
"    call WaitForOneVBlank\n"
"\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/gameplay.md:190
msgid "\t; from: https://github.com/eievui5/gb-sprobj-lib\n"
"\t; Finally, run the following code during VBlank:\n"
"\tld a, HIGH(wShadowOAM)\n"
"\tcall hOAMDMA"
msgstr ""

#: src/part3/gameplay.md:195
msgid "\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ; Call our function that performs the code\n"
"    call WaitForOneVBlank\n"
"\t;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"\t\n"
"\tjp UpdateGameplayState"
msgstr ""

#: src/part3/gameplay.md:202
msgid "EndGameplay:\n"
"\t\n"
"    ld a, 0\n"
"    ld [wGameState],a\n"
"    jp NextGameState\n"
"```"
msgstr ""

#: src/part3/scrolling-background.md:2
msgid "# Scrolling Background"
msgstr ""

#: src/part3/scrolling-background.md:4
msgid "Scrolling the background is an easy task. However, for a SMOOTH slow scrolling background: scaled integers[^1] will be used."
msgstr ""

#: src/part3/scrolling-background.md:6
msgid ">‚ö†Ô∏è Scaled Integers[^1] are a way to provide smooth ‚Äúsub-pixel‚Äù movement. They are slightly more difficult to understand & implement than implementing a counter, but they provide smoother motion."
msgstr ""

#: src/part3/scrolling-background.md:8
msgid "## Initializing the Background"
msgstr ""

#: src/part3/scrolling-background.md:10
msgid "At the start of the gameplay game state we called the initialize background function. This function shows the star field background, and resets our background scroll variables:"
msgstr ""

#: src/part3/scrolling-background.md:12
msgid "> Just like with our title screen graphic, because our text font tiles are at the beginning of VRAM: we offset the tilemap values by 52"
msgstr ""

#: src/part3/scrolling-background.md:18
msgid "SECTION \"BackgroundVariables\", WRAM0"
msgstr "SECTION \"BackgroundVariables\", WRAM0"

#: src/part3/scrolling-background.md:20
msgid "mBackgroundScroll:: dw"
msgstr "mBackgroundScroll:: dw"

#: src/part3/scrolling-background.md:22
msgid "SECTION \"GameplayBackgroundSection\", ROM0"
msgstr "SECTION \"GameplayBackgroundSection\", ROM0"

#: src/part3/scrolling-background.md:24
msgid "starFieldMap: INCBIN \"src/generated/backgrounds/star-field.tilemap\"\n"
"starFieldMapEnd:\n"
" \n"
"starFieldTileData: INCBIN \"src/generated/backgrounds/star-field.2bpp\"\n"
"starFieldTileDataEnd:"
msgstr "starFieldMap: INCBIN \"src/generated/backgrounds/star-field.tilemap\"\n"
"starFieldMapEnd:\n"
" \n"
"starFieldTileData: INCBIN \"src/generated/backgrounds/star-field.2bpp\"\n"
"starFieldTileDataEnd:"

#: src/part3/scrolling-background.md:30
msgid "InitializeBackground::"
msgstr ""

#: src/part3/scrolling-background.md:32
msgid "\t; Copy the tile data\n"
"\tld de, starFieldTileData ; de contains the address where data will be copied from;\n"
"\tld hl, $9340 ; hl contains the address where data will be copied to;\n"
"\tld bc, starFieldTileDataEnd - starFieldTileData ; bc contains how many bytes we have to copy.\n"
"    call CopyDEintoMemoryAtHL"
msgstr ""

#: src/part3/scrolling-background.md:38
msgid "\t; Copy the tilemap\n"
"\tld de, starFieldMap\n"
"\tld hl, $9800\n"
"\tld bc, starFieldMapEnd - starFieldMap\n"
"    call CopyDEintoMemoryAtHL_With52Offset"
msgstr ""

#: src/part3/scrolling-background.md:44
msgid "\tld a, 0\n"
"\tld [mBackgroundScroll+0],a\n"
"\tld a, 0\n"
"\tld [mBackgroundScroll+1],a"
msgstr ""

#: src/part3/scrolling-background.md:52
msgid "To scroll the background in a gameboy game, we simply need to gradually change the `SCX` or `SCX` registers. Our code is a tiny bit more complicated because of scaled integer usage. Our background's scroll position is stored in a 16-bit integer called `mBackgroundScroll`. We'l increase that 16-bit integer by a set amount."
msgstr ""

#: src/part3/scrolling-background.md:54
msgid "```rgbasm,linenos,start=37\n"
"; This is called during gameplay state on every frame\n"
"UpdateBackground::"
msgstr ""

#: src/part3/scrolling-background.md:58
msgid "\t; Increase our scaled integer by 5\n"
"\t; Get our true (non-scaled) value, and save it for later usage in bc\n"
"\tld a , [mBackgroundScroll+0]\n"
"\tadd a , 5\n"
"    ld b,a\n"
"\tld [mBackgroundScroll+0], a\n"
"\tld a , [mBackgroundScroll+1]\n"
"\tadc a , 0\n"
"    ld c,a\n"
"\tld [mBackgroundScroll+1], a\n"
"``` "
msgstr ""

#: src/part3/scrolling-background.md:70
msgid "We won't directly draw the background using this value. De-scaling a scaled integer simulates having a (more precise and useful for smooth movement) floating-point number. The value we draw our background at will be the de-scaled version of that 16-bit integer. To get that non-scaled version, we'll simply shift all of it's bit rightward 4 places. The final result will saved for when we update our background's y position."
msgstr ""

#: src/part3/scrolling-background.md:72
msgid "```rgbasm,linenos,start=51\n"
"    ; Descale our scaled integer \n"
"    ; shift bits to the right 4 spaces\n"
"    srl c\n"
"    rr b\n"
"    srl c\n"
"    rr b\n"
"    srl c\n"
"    rr b\n"
"    srl c\n"
"    rr b"
msgstr ""

#: src/part3/scrolling-background.md:84
msgid "    ; Use the de-scaled low byte as the backgrounds position\n"
"    ld a,b\n"
"\tld [rSCY], a"
msgstr ""

#: src/part3/scrolling-background.md:88
msgid "\tret\n"
"``` "
msgstr "\tret\n"
"``` "

#: src/part3/scrolling-background.md:91
msgid "[^1]: [Scaled Factor on Wikipedia](https://en.wikipedia.org/wiki/Scale_factor_(computer_science))"
msgstr ""

#: src/part3/heads-up-interface.md:1
msgid "# Heads Up Interface"
msgstr ""

#: src/part3/heads-up-interface.md:3
msgid "The gameboy normally draws sprites over both the window and background, and the window over the background. In Galactic Armada, The background is vertically scrolling. This means the HUD (the score text and number) needs to be draw on the window, which is separate from the background. "
msgstr ""

#: src/part3/heads-up-interface.md:5
msgid "On our HUD, we'll draw both our score and our lives. We'll also use STAT interrupts to make sure nothing covers the HUD."
msgstr ""

#: src/part3/heads-up-interface.md:7
msgid "## STAT Interrupts & the window"
msgstr ""

#: src/part3/heads-up-interface.md:10
msgid "The window is not enabled by default. We can enable the window using the `LCDC` register. RGBDS comes with constants that will help us. "
msgstr ""

#: src/part3/heads-up-interface.md:12
msgid "> ‚ö†Ô∏è NOTE: The window can essentially be a copy of the background. The `LCDCF_WIN9C00|LCDCF_BG9800` portion makes the background and window use different tilemaps when drawn.\n"
"There‚Äôs only one problem. Since the window is drawn between sprites and the background. Without any extra effort, our scrolling background tilemap will be covered by our window. In addition, our sprites will be drawn over our hud. For this, we‚Äôll need STAT interrupts. Fore more information on STAT interrupts, check out the pandocs: [https://gbdev.io/pandocs/Interrupt_Sources.html](https://gbdev.io/pandocs/Interrupt_Sources.html)"
msgstr ""

#: src/part3/heads-up-interface.md:16
msgid "![InterruptsDiagram.png](../assets/part3/img/StatInterruptsVisualized.png)"
msgstr ""

#: src/part3/heads-up-interface.md:18
msgid "> ### **[Using the STAT interrupt](https://gbdev.io/pandocs/Interrupt_Sources.html#using-the-stat-interrupt)**\n"
"> \n"
"> One very popular use is to indicate to the user when the video hardware is about to redraw a given LCD line. This can be useful for dynamically controlling the SCX/SCY registers ($FF43/$FF42) to¬†[perform special video effects](https://github.com/gb-archive/DeadCScroll).\n"
"> \n"
"> Example application: set LYC to WY, enable LY=LYC interrupt, and have the handler disable sprites. This can be used if you use the window for a text box (at the bottom of the screen), and you want sprites to be hidden by the text box."
msgstr ""

#: src/part3/heads-up-interface.md:25
msgid "With STAT interrupts, we can implement raster effects. in our case, we‚Äôll enable the window and stop drawing sprites on the first 8 scanlines. Afterwards, we‚Äôll show sprites and disable the window layer for the remaining scanlines. This makes sure nothing overlaps our HUD, and that our background is fully shown also."
msgstr ""

#: src/part3/heads-up-interface.md:27
msgid "### Initiating & Disabling STAT interrupts"
msgstr ""

#: src/part3/heads-up-interface.md:29
msgid "In our gameplay game state, at different points in time, we initialized and disabled interrupts. Here's the logic for those functions in our \"src/main/states/gameplay/hud.asm\" file:"
msgstr ""

#: src/part3/heads-up-interface.md:31
msgid "```rgbasm,linenos,start=2\n"
"INCLUDE \"src/main/utils/hardware.inc\""
msgstr ""

#: src/part3/heads-up-interface.md:34
msgid " SECTION \"Interrupts\", ROM0"
msgstr " SECTION \"Interrupts\", ROM0"

#: src/part3/heads-up-interface.md:36
msgid " DisableInterrupts::\n"
"\tld a, 0\n"
"\tldh [rSTAT], a\n"
"\tdi\n"
"\tret"
msgstr " DisableInterrupts::\n"
"\tld a, 0\n"
"\tldh [rSTAT], a\n"
"\tdi\n"
"\tret"

#: src/part3/heads-up-interface.md:42
msgid "InitStatInterrupts::"
msgstr ""

#: src/part3/heads-up-interface.md:44
msgid "    ld a, IEF_STAT\n"
"\tldh [rIE], a\n"
"\txor a, a ; This is equivalent to `ld a, 0`!\n"
"\tldh [rIF], a\n"
"\tei"
msgstr ""

#: src/part3/heads-up-interface.md:50
msgid "\t; This makes our stat interrupts occur when the current scanline is equal to the rLYC register\n"
"\tld a, STATF_LYC\n"
"\tldh [rSTAT], a"
msgstr ""

#: src/part3/heads-up-interface.md:54
msgid "\t; We'll start with the first scanline\n"
"\t; The first stat interrupt will call the next time rLY = 0\n"
"\tld a, 0\n"
"\tldh [rLYC], a"
msgstr ""

#: src/part3/heads-up-interface.md:62
msgid "### Defining STAT interrupts"
msgstr ""

#: src/part3/heads-up-interface.md:64
msgid "Our actual STAT interrupts must be located at $0048. We'll define different paths depending on what our LYC variable's value is when executed."
msgstr ""

#: src/part3/heads-up-interface.md:66
msgid "```rgbasm,linenos,start=31\n"
"; Define a new section and hard-code it to be at $0048.\n"
"SECTION \"Stat Interrupt\", ROM0[$0048]\n"
"StatInterrupt:"
msgstr ""

#: src/part3/heads-up-interface.md:71
msgid "\tpush af"
msgstr "\tpush af"

#: src/part3/heads-up-interface.md:73
msgid "\t; Check if we are on the first scanline\n"
"\tldh a, [rLYC]\n"
"\tcp 0\n"
"\tjp z, LYCEqualsZero"
msgstr ""

#: src/part3/heads-up-interface.md:78
msgid "LYCEquals8:"
msgstr "LYCEquals8:"

#: src/part3/heads-up-interface.md:80
msgid "\t; Don't call the next stat interrupt until scanline 8\n"
"\tld a, 0\n"
"\tldh [rLYC], a"
msgstr ""

#: src/part3/heads-up-interface.md:84
msgid "\t; Turn the LCD on including sprites. But no window\n"
"\tld a, LCDCF_ON | LCDCF_BGON | LCDCF_OBJON | LCDCF_OBJ16 | LCDCF_WINOFF | LCDCF_WIN9C00\n"
"\tldh [rLCDC], a"
msgstr ""

#: src/part3/heads-up-interface.md:88
msgid "\tjp EndStatInterrupts"
msgstr "\tjp EndStatInterrupts"

#: src/part3/heads-up-interface.md:90
msgid "LYCEqualsZero:"
msgstr "LYCEqualsZero:"

#: src/part3/heads-up-interface.md:92
msgid "\t; Don't call the next stat interrupt until scanline 8\n"
"\tld a, 8\n"
"\tldh [rLYC], a"
msgstr ""

#: src/part3/heads-up-interface.md:96
msgid "\t; Turn the LCD on including the window. But no sprites\n"
"\tld a, LCDCF_ON | LCDCF_BGON | LCDCF_OBJOFF | LCDCF_OBJ16| LCDCF_WINON | LCDCF_WIN9C00\n"
"\tldh [rLCDC], a"
msgstr ""

#: src/part3/heads-up-interface.md:101
msgid "EndStatInterrupts:"
msgstr ""

#: src/part3/heads-up-interface.md:103
msgid "\tpop af"
msgstr ""

#: src/part3/heads-up-interface.md:105
msgid "\treti;\n"
"```"
msgstr ""

#: src/part3/heads-up-interface.md:108
msgid "That should be all it takes to get a properly drawn HUD. For more details, check out the code in the repo or [ask questions](https://gbdev.io/gb-asm-tutorial/help-feedback.html) on the gbdev discord server."
msgstr ""

#: src/part3/heads-up-interface.md:110
msgid "## Keeping Score and Drawing Score on the HUD"
msgstr ""

#: src/part3/heads-up-interface.md:112
msgid "To keep things simple, back in our gameplay game state, we used 6 different bytes to hold our score.Each byte will hold a value between 0 and 9, and represents a specific digit in the score. So it‚Äôs easy to loop through and edit the score number on the HUD: The First byte represents the left-most digit, and the last byte represents the right-most digit. "
msgstr ""

#: src/part3/heads-up-interface.md:114
msgid "![DrawingScoreVisualized.png](../assets/part3/img/DrawingScoreVisualized.png)"
msgstr ""

#: src/part3/heads-up-interface.md:116
msgid "When the score increases, we‚Äôll increase digits on the right. As they go higher than 9, we‚Äôll reset back to 0 and increase the previous byte ."
msgstr ""

#: src/part3/heads-up-interface.md:119
msgid "```rgbasm,linenos,start=6\n"
"IncreaseScore::"
msgstr ""

#: src/part3/heads-up-interface.md:122
msgid "    ; We have 6 digits, start with the right-most digit (the last byte)\n"
"    ld c, 0\n"
"    ld hl, wScore+5"
msgstr ""

#: src/part3/heads-up-interface.md:126
msgid "IncreaseScore_Loop:"
msgstr "IncreaseScore_Loop:"

#: src/part3/heads-up-interface.md:128
msgid "    ; Increase the digit \n"
"    ld a, [hl]\n"
"    inc a\n"
"    ld [hl], a"
msgstr ""

#: src/part3/heads-up-interface.md:133
msgid "    ; Stop if it hasn't gone past 0\n"
"    cp a, 9\n"
"    ret c"
msgstr ""

#: src/part3/heads-up-interface.md:137
msgid "; If it HAS gone past 9\n"
"IncreaseScore_Next:"
msgstr ""

#: src/part3/heads-up-interface.md:140
msgid "    ; Increase a counter so we can not go out of our scores bounds\n"
"    ld a, c\n"
"    inc a \n"
"    ld c, a"
msgstr ""

#: src/part3/heads-up-interface.md:145
msgid "    ; Check if we've gone our o our scores bounds\n"
"    cp a, 6\n"
"    ret z"
msgstr ""

#: src/part3/heads-up-interface.md:149
msgid "    ; Reset the current digit to zero\n"
"    ; Then go to the previous byte (visually: to the left)\n"
"    ld a, 0\n"
"    ld [hl], a\n"
"    ld [hld], a"
msgstr ""

#: src/part3/heads-up-interface.md:155
msgid "    jp IncreaseScore_Loop\n"
"```"
msgstr "    jp IncreaseScore_Loop\n"
"```"

#: src/part3/heads-up-interface.md:159
msgid "We can call that score whenever a bullet hits an enemy. This function however does not draw our score on the background. We do that the same way we drew text previously:"
msgstr ""

#: src/part3/heads-up-interface.md:162
msgid "```rgbasm,linenos,start=55\n"
"DrawScore::"
msgstr "```rgbasm,linenos,start=55\n"
"DrawScore::"

#: src/part3/heads-up-interface.md:165
msgid "    ; Our score has max 6 digits\n"
"    ; We'll start with the left-most digit (visually) which is also the first byte\n"
"    ld c, 6\n"
"    ld hl, wScore\n"
"    ld de, $9C06 ; The window tilemap starts at $9C00"
msgstr ""

#: src/part3/heads-up-interface.md:171
msgid "DrawScore_Loop:"
msgstr "DrawScore_Loop:"

#: src/part3/heads-up-interface.md:173
msgid "    ld a, [hli]\n"
"    add a, 10 ; our numeric tiles start at tile 10, so add to 10 to each bytes value\n"
"    ld [de], a"
msgstr ""

#: src/part3/heads-up-interface.md:177
msgid "    ; Decrease how many numbers we have drawn\n"
"    ld a, c\n"
"    dec a\n"
"    ld c, a\n"
"\t\t\n"
"    ; Stop when we've drawn all the numbers\n"
"    ret z"
msgstr ""

#: src/part3/heads-up-interface.md:185
msgid "    ; Increase which tile we are drawing to\n"
"    inc de"
msgstr ""

#: src/part3/heads-up-interface.md:188
msgid "    jp DrawScore_Loop\n"
"```"
msgstr "    jp DrawScore_Loop\n"
"```"

#: src/part3/heads-up-interface.md:191
msgid "Because we'll only ever have 3 lives, drawing our lives is much easier. The numeric characters in our text font start at 10, so  we just need to put on the window, our lives plus 10."
msgstr ""

#: src/part3/heads-up-interface.md:193
msgid "```rgbasm,linenos,start=44\n"
"DrawLives::"
msgstr "```rgbasm,linenos,start=44\n"
"DrawLives::"

#: src/part3/heads-up-interface.md:196
msgid "    ld hl, wLives\n"
"    ld de, $9C13 ; The window tilemap starts at $9C00"
msgstr ""

#: src/part3/heads-up-interface.md:199
msgid "    ld a, [hl]\n"
"    add a, 10 ; our numeric tiles start at tile 10, so add to 10 to each bytes value\n"
"    ld [de], a"
msgstr ""

#: src/part3/sprites-metasprites.md:1
msgid "# Sprites & Metasprites"
msgstr ""

#: src/part3/sprites-metasprites.md:3
msgid "Before we dive into the player, bullets, and enemies; how they are drawn using metasprites should be explained."
msgstr ""

#: src/part3/sprites-metasprites.md:5
msgid "For sprites, the following library is used:  https://github.com/eievui5/gb-sprobj-lib"
msgstr ""

#: src/part3/sprites-metasprites.md:7
msgid "> This is a small, lightweight library meant to facilitate the rendering of sprite objects, including Shadow OAM and OAM DMA, single-entry \"simple\" sprite objects, and Q12.4 fixed-point position metasprite rendering."
msgstr ""

#: src/part3/sprites-metasprites.md:9
msgid "All objects are drawn using \"metasprites\", or groups of sprites that define one single object. A custom ‚Äúmetasprite‚Äù implementation is used in addition. Metasprite definitions should a multiple of 4 plus one additional byte for the end."
msgstr ""

#: src/part3/sprites-metasprites.md:11
msgid "- Relative Y offset ( relative to the previous sprite, or the actual metasprite‚Äôs draw position)\n"
"- Relative X offset ( relative to the previous sprite, or the actual metasprite‚Äôs draw position)\n"
"- Tile to draw\n"
"- Tile Props (not used in this project)"
msgstr ""

#: src/part3/sprites-metasprites.md:16
msgid "The logic stops drawing when it reads 128. "
msgstr ""

#: src/part3/sprites-metasprites.md:18
msgid "An example of metasprite is the enemy ship:"
msgstr ""

#: src/part3/sprites-metasprites.md:21
msgid "```rgbasm,linenos,start=501"
msgstr "```rgbasm,linenos,start=501"

#: src/part3/sprites-metasprites.md:23
msgid "enemyShipMetasprite::\n"
"    .metasprite1    db 0,0,4,0\n"
"    .metasprite2    db 0,8,6,0\n"
"    .metaspriteEnd  db 128"
msgstr "enemyShipMetasprite::\n"
"    .metasprite1    db 0,0,4,0\n"
"    .metasprite2    db 0,8,6,0\n"
"    .metaspriteEnd  db 128"

#: src/part3/sprites-metasprites.md:30
msgid "![MetaspriteDIagram.png](../assets/part3/img/MetaspriteDIagram.png)"
msgstr "![MetaspriteDIagram.png](../assets/part3/img/MetaspriteDIagram.png)"

#: src/part3/sprites-metasprites.md:32
msgid "The Previous snippet draws two sprites. One that the object‚Äôs actual position, which uses tile 4 and 5. The second sprite is 8 pixels to the right, and uses tile 6 and 7"
msgstr ""

#: src/part3/sprites-metasprites.md:34
msgid ">‚ö†Ô∏è **NOTE**: Sprites are in 8x16 mode for this project."
msgstr ""

#: src/part3/sprites-metasprites.md:36
msgid "I can later draw such metasprite by calling the \"DrawMetasprite\" function that"
msgstr ""

#: src/part3/sprites-metasprites.md:38
msgid "```rgbasm,linenos,start=509\n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"; call the 'DrawMetasprites function. \n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"; Save the x position\n"
"ld a, b\n"
"ld [wMetaspriteX],a"
msgstr ""

#: src/part3/sprites-metasprites.md:46
msgid "; Save the y position\n"
"ld a, c\n"
"ld [wMetaspriteY],a"
msgstr ""

#: src/part3/sprites-metasprites.md:50
msgid "; Actually call the 'DrawMetasprites function\n"
"call DrawMetasprites;\n"
"```"
msgstr ""

#: src/part3/sprites-metasprites.md:54
msgid "We previously mentioned a variable called \"wLastOAMAddress\". The \"DrawMetasprites\" function can be found in the \"src/main/utils/metasprites.asm\" file:"
msgstr ""

#: src/part3/sprites-metasprites.md:56
msgid "```rgbasm,linenos,start=1"
msgstr "```rgbasm,linenos,start=1"

#: src/part3/sprites-metasprites.md:58
msgid "include \"src/main/utils/constants.inc\"\n"
"SECTION \"MetaSpriteVariables\", WRAM0"
msgstr "include \"src/main/utils/constants.inc\"\n"
"SECTION \"MetaSpriteVariables\", WRAM0"

#: src/part3/sprites-metasprites.md:61
msgid "wMetaspriteAddress:: dw\n"
"wMetaspriteX:: db\n"
"wMetaspriteY::db"
msgstr "wMetaspriteAddress:: dw\n"
"wMetaspriteX:: db\n"
"wMetaspriteY::db"

#: src/part3/sprites-metasprites.md:65
msgid "SECTION \"MetaSprites\", ROM0"
msgstr "SECTION \"MetaSprites\", ROM0"

#: src/part3/sprites-metasprites.md:67
msgid "DrawMetasprites::"
msgstr "DrawMetasprites::"

#: src/part3/sprites-metasprites.md:70
msgid "    ; get the metasprite address\n"
"    ld a, [wMetaspriteAddress+0]\n"
"    ld l, a\n"
"    ld a, [wMetaspriteAddress+1]\n"
"    ld h, a"
msgstr ""

#: src/part3/sprites-metasprites.md:76
msgid "    ; Get the y position\n"
"    ld a, [hli]\n"
"    ld b, a"
msgstr ""

#: src/part3/sprites-metasprites.md:80
msgid "    ; stop if the y position is 128 \n"
"    ld a, b\n"
"    cp 128\n"
"    ret z"
msgstr ""

#: src/part3/sprites-metasprites.md:85
msgid "    ld a, [wMetaspriteY]\n"
"    add a, b\n"
"    ld [wMetaspriteY],a"
msgstr "    ld a, [wMetaspriteY]\n"
"    add a, b\n"
"    ld [wMetaspriteY],a"

#: src/part3/sprites-metasprites.md:89
msgid "    ; Get the x position\n"
"    ld a, [hli]\n"
"    ld c, a"
msgstr ""

#: src/part3/sprites-metasprites.md:93
msgid "    ld a, [wMetaspriteX]\n"
"    add a,c\n"
"    ld [wMetaspriteX],a"
msgstr "    ld a, [wMetaspriteX]\n"
"    add a,c\n"
"    ld [wMetaspriteX],a"

#: src/part3/sprites-metasprites.md:97
msgid "    ; Get the tile position\n"
"    ld a, [hli]\n"
"    ld d, a"
msgstr ""

#: src/part3/sprites-metasprites.md:101
msgid "    ; Get the flag position\n"
"    ld a, [hli]\n"
"    ld e, a\n"
"    "
msgstr ""

#: src/part3/sprites-metasprites.md:106
msgid "    ;Get our offset address in hl\n"
"\tld a,[wLastOAMAddress+0]\n"
"    ld l, a\n"
"\tld a, HIGH(wShadowOAM)\n"
"    ld h, a"
msgstr ""

#: src/part3/sprites-metasprites.md:112
msgid "    ld a, [wMetaspriteY]\n"
"    ld [hli], a"
msgstr ""

#: src/part3/sprites-metasprites.md:115
msgid "    ld a, [wMetaspriteX]\n"
"    ld [hli], a"
msgstr ""

#: src/part3/sprites-metasprites.md:118
msgid "    ld a, d\n"
"    ld [hli], a"
msgstr ""

#: src/part3/sprites-metasprites.md:121
msgid "    ld a, e\n"
"    ld [hli], a"
msgstr ""

#: src/part3/sprites-metasprites.md:124
msgid "    call NextOAMSprite"
msgstr ""

#: src/part3/sprites-metasprites.md:126
msgid "     ; increase the wMetaspriteAddress\n"
"    ld a, [wMetaspriteAddress+0]\n"
"    add a, METASPRITE_BYTES_COUNT\n"
"    ld  [wMetaspriteAddress+0], a\n"
"    ld a, [wMetaspriteAddress+1]\n"
"    adc a, 0\n"
"    ld  [wMetaspriteAddress+1], a"
msgstr ""

#: src/part3/sprites-metasprites.md:135
msgid "    jp DrawMetasprites\n"
"```"
msgstr ""

#: src/part3/sprites-metasprites.md:138
msgid "When we call the \"DrawMetasprites\" function, the \"wLastOAMAddress\" variable will be advanced  to point at the next available shadow OAM sprite. This is done using the \"NextOAMSprite\" function in \"src/main/utils/sprites-utils.asm\""
msgstr ""

#: src/part3/sprites-metasprites.md:140
msgid "```rgbasm,linenos,start=76\n"
"NextOAMSprite::"
msgstr ""

#: src/part3/sprites-metasprites.md:143
msgid "    ld a, [wSpritesUsed]\n"
"    inc a\n"
"    ld [wSpritesUsed], a"
msgstr ""

#: src/part3/sprites-metasprites.md:147
msgid "\tld a,[wLastOAMAddress+0]\n"
"    add a, sizeof_OAM_ATTRS\n"
"\tld [wLastOAMAddress+0], a\n"
"\tld a, HIGH(wShadowOAM)\n"
"\tld [wLastOAMAddress+1], a"
msgstr ""

#: src/part3/object-pools.md:1
msgid "# Object Pools"
msgstr ""

#: src/part3/object-pools.md:3
msgid "Galactic Armada will use \"object pools\" for bullets and enemies. A fixed amount of bytes representing a specific maximum amount of objects. Each pool is just a collection of bytes. The number of bytes per ‚Äúpool‚Äù is the maximum number of objects in the pool, times the number of bytes needed for data for each object."
msgstr ""

#: src/part3/object-pools.md:5
msgid "Constants are also created for the size of each object, and what each byte is. These constants are in the ‚Äúsrc/main/utils/constants.inc‚Äù file and utilize RGBDS offset constants (a really cool feature)"
msgstr ""

#: src/part3/object-pools.md:7
msgid "```rgbasm,linenos,start=528"
msgstr "```rgbasm,linenos,start=528"

#: src/part3/object-pools.md:9
msgid "; from https://rgbds.gbdev.io/docs/v0.6.1/rgbasm.5#EXPRESSIONS\n"
"; The RS group of commands is a handy way of defining structure offsets:\n"
"RSRESET\n"
"DEF bullet_activeByte            RB   1\n"
"DEF bullet_xByte                 RB   1\n"
"DEF bullet_yLowByte              RB   1\n"
"DEF bullet_yHighByte             RB   1\n"
"DEF PER_BULLET_BYTES_COUNT       RB   0"
msgstr ""

#: src/part3/object-pools.md:21
msgid "The two object types that we need to loop through are Enemies and Bullets."
msgstr ""

#: src/part3/object-pools.md:23
msgid "**Bytes for an Enemy:**"
msgstr ""

#: src/part3/object-pools.md:25
msgid "1. Active - Are they active\n"
"2. X - Position: horizontal coordinate\n"
"3. Y (low) - The lower byte of their 16-bit (scaled) y position\n"
"4. Y (high) - The higher byte of their 16-bit (scaled) y position\n"
"5. Speed - How fast they move\n"
"6. Health - How many bullets they can take"
msgstr ""

#: src/part3/object-pools.md:32
msgid "```rgbasm,linenos,start=540"
msgstr "```rgbasm,linenos,start=540"

#: src/part3/object-pools.md:34
#: src/part3/enemies.md:33
msgid "; Bytes: active, x , y (low), y (high), speed, health\n"
"wEnemies:: ds MAX_ENEMY_COUNT*PER_ENEMY_BYTES_COUNT"
msgstr ""

#: src/part3/object-pools.md:39
msgid "![EnemyBytesVisualized.png](../assets/part3/img/EnemyBytesVisualized.png)"
msgstr "![EnemyBytesVisualized.png](../assets/part3/img/EnemyBytesVisualized.png)"

#: src/part3/object-pools.md:41
msgid "**Bytes for a Bullet:**"
msgstr ""

#: src/part3/object-pools.md:43
msgid "1. Active - Are they active\n"
"2. X - Position: horizontal coordinate\n"
"3. Y (low) - The lower byte of their 16-bit (scaled) y position\n"
"4. Y (high) - The higher byte of their 16-bit (scaled) y position"
msgstr ""

#: src/part3/object-pools.md:48
msgid "```rgbasm,linenos,start=523"
msgstr "```rgbasm,linenos,start=523"

#: src/part3/object-pools.md:50
#: src/part3/bullets.md:21
msgid "; Bytes: active, x , y (low), y (high)\n"
"wBullets:: ds MAX_BULLET_COUNT*PER_BULLET_BYTES_COUNT"
msgstr ""

#: src/part3/object-pools.md:55
#: src/part3/bullets.md:42
msgid "![BulletBytesVisualized.png](../assets/part3/img/BulletBytesVisualized.png)"
msgstr ""

#: src/part3/object-pools.md:57
msgid "> ‚ö†Ô∏è **NOTE:** Scaled integers are used for only the y positions of bullets and enemies. Scaled Integers are a way to provide smooth ‚Äúsub-pixel‚Äù movement. They only move vertically, so the x position can be 8-bit."
msgstr ""

#: src/part3/object-pools.md:59
msgid "When looping through an object pool, we‚Äôll check if an object is active. If it‚Äôs active, we‚Äôll run the logic for that object. Otherwise, we‚Äôll skip to the start of the next object‚Äôs bytes. "
msgstr ""

#: src/part3/object-pools.md:61
msgid "Both bullets and enemies do similar things. They move vertically until they are off the screen. In addition, enemies will check against bullets when updating. If they are found to be colliding, the bullet is destroyed and so is the enemy."
msgstr ""

#: src/part3/object-pools.md:63
msgid "# ‚ÄúActivating‚Äù a pooled object"
msgstr ""

#: src/part3/object-pools.md:65
msgid "To Activate a pooled object, we simply loop through each object. If the first byte, which tells us if it‚Äôs active or not, is 0: then we‚Äôll add the new item at that location and set that byte to be 1. If we loop through all possible objects and nothing is inactive, nothing happens."
msgstr ""

#: src/part3/object-pools.md:67
msgid "![Spawning Enemies.png](../assets/part3/img/Spawning_Enemies.png)"
msgstr ""

#: src/part3/the-player.md:1
msgid "# The Player"
msgstr ""

#: src/part3/the-player.md:3
msgid "The player‚Äôs logic is pretty simple. The player can move in 4 directions and fire bullets. We update the player by checking our input directions and the A button. We‚Äôll move in the proper direction if its associated d-pad button is pressed. If the A button is pressed, we‚Äôll spawn a new bullet at the player‚Äôs position."
msgstr ""

#: src/part3/the-player.md:5
msgid "Our player will have 3 variables:\n"
"- wePlayerPositionX - a 16-bit scaled integer\n"
"- wePlayerPositionY - a 16-bit scaled integer\n"
"- wPlayerFlash - a 16-bit integer used when the player gets damaged"
msgstr ""

#: src/part3/the-player.md:10
msgid "> ‚ö†Ô∏è **NOTE**: The player can move vertically AND horizontally. So, unlike bullets and enemies, it‚Äôs x position is a 16-bit scaled integer."
msgstr ""

#: src/part3/the-player.md:12
msgid "These are declared at the top of the \"src/main/states/gameplay/objects/player.asm\" file"
msgstr ""

#: src/part3/the-player.md:14
msgid "```rgbasm,linenos,start=1\n"
"include \"src/main/utils/hardware.inc\"\n"
"include \"src/main/utils/hardware.inc\"\n"
"include \"src/main/utils/constants.inc\""
msgstr ""

#: src/part3/the-player.md:19
msgid "SECTION \"PlayerVariables\", WRAM0"
msgstr "SECTION \"PlayerVariables\", WRAM0"

#: src/part3/the-player.md:21
msgid "; first byte is low, second is high (little endian)\n"
"wPlayerPositionX:: dw\n"
"wPlayerPositionY:: dw"
msgstr ""

#: src/part3/the-player.md:25
msgid "mPlayerFlash: dw\n"
"```"
msgstr "mPlayerFlash: dw\n"
"```"

#: src/part3/the-player.md:28
msgid "Well draw our player, a simple ship, using the previously discussed metasprites implementation. Here is what we have for the players metasprites and tile data:\n"
"```rgbasm,linenos,start=12\n"
"SECTION \"Player\", ROM0"
msgstr ""

#: src/part3/the-player.md:35
msgid "playerTestMetaSprite::\n"
"    .metasprite1    db 0,0,0,0\n"
"    .metasprite2    db 0,8,2,0\n"
"    .metaspriteEnd  db 128\n"
"```"
msgstr "playerTestMetaSprite::\n"
"    .metasprite1    db 0,0,0,0\n"
"    .metasprite2    db 0,8,2,0\n"
"    .metaspriteEnd  db 128\n"
"```"

#: src/part3/the-player.md:41
msgid "## Initializing the Player"
msgstr ""

#: src/part3/the-player.md:43
msgid "Initializing the player is pretty simple. Here's a list of things we need to do:\n"
"* Reset oir wPlayerFlash variable\n"
"* Reset our wPlayerPositionX variable\n"
"* Reset our wPlayerPositionU variable\n"
"* Copy the player's ship into VRAM"
msgstr ""

#: src/part3/the-player.md:49
msgid "We'll use a constant we declared in \"src/main/utils/constants.inc\" to copy the player ship's tile data into VRAM. Our enemy ship and player ship both have 4 tiles (16 bytes for each tile). In the snippet below, we can define where we'll place the tile data in VRAM relative to the _VRAM constant:"
msgstr ""

#: src/part3/the-player.md:51
msgid "```rgbasm,linenos,start=37\n"
"RSRESET\n"
"DEF spriteTilesStart            RB _VRAM\n"
"DEF PLAYER_TILES_START          RB 4*16\n"
"DEF ENEMY_TILES_START           RB 4*16\n"
"DEF BULLET_TILES_START          RB 0\n"
"```"
msgstr ""

#: src/part3/the-player.md:59
msgid "Here's what our \"InitializePlayer\" function looks like. Recall, this was called when initiating the gameplay game state:"
msgstr ""

#: src/part3/the-player.md:61
msgid "```rgbasm,linenos,start=22\n"
"InitializePlayer::"
msgstr "```rgbasm,linenos,start=22\n"
"InitializePlayer::"

#: src/part3/the-player.md:64
msgid "    ld a, 0\n"
"    ld [mPlayerFlash+0],a\n"
"    ld [mPlayerFlash+1],a"
msgstr "    ld a, 0\n"
"    ld [mPlayerFlash+0],a\n"
"    ld [mPlayerFlash+1],a"

#: src/part3/the-player.md:68
msgid "    ; Place in the middle of the screen\n"
"    ld a, 0\n"
"    ld [wPlayerPositionX+0], a\n"
"    ld [wPlayerPositionY+0], a"
msgstr ""

#: src/part3/the-player.md:73
msgid "    ld a, 5\n"
"    ld [wPlayerPositionX+1], a\n"
"    ld [wPlayerPositionY+1], a"
msgstr "    ld a, 5\n"
"    ld [wPlayerPositionX+1], a\n"
"    ld [wPlayerPositionY+1], a"

#: src/part3/the-player.md:77
msgid "    \n"
"CopyPlayerTileDataIntoVRAM:\n"
"    ; Copy the player's tile data into VRAM\n"
"\tld de, playerShipTileData\n"
"\tld hl, PLAYER_TILES_START\n"
"\tld bc, playerShipTileDataEnd - playerShipTileData\n"
"    call CopyDEintoMemoryAtHL"
msgstr ""

#: src/part3/the-player.md:88
msgid "## Updating the Player"
msgstr ""

#: src/part3/the-player.md:90
msgid "We can break our player's update logic into 2 parts:\n"
"* Check for joypad input,  move with the d-pad, shoot with A\n"
"* Depending on our \"wPlayerFlash\" variable: Draw our metasprites at our location"
msgstr ""

#: src/part3/the-player.md:94
msgid "Checking the joypad is done like the previous tutorials, we'll perform bitwise \"and\" operations with constants for each d-pad direction."
msgstr ""

#: src/part3/the-player.md:96
msgid "```rgbasm,linenos,start=47\n"
"UpdatePlayer::"
msgstr ""

#: src/part3/the-player.md:99
msgid "UpdatePlayer_HandleInput:"
msgstr "UpdatePlayer_HandleInput:"

#: src/part3/the-player.md:101
msgid "\tld a, [wCurKeys]\n"
"\tand a, PADF_UP\n"
"\tcall nz, MoveUp"
msgstr "\tld a, [wCurKeys]\n"
"\tand a, PADF_UP\n"
"\tcall nz, MoveUp"

#: src/part3/the-player.md:105
msgid "\tld a, [wCurKeys]\n"
"\tand a, PADF_DOWN\n"
"\tcall nz, MoveDown"
msgstr "\tld a, [wCurKeys]\n"
"\tand a, PADF_DOWN\n"
"\tcall nz, MoveDown"

#: src/part3/the-player.md:109
msgid "\tld a, [wCurKeys]\n"
"\tand a, PADF_LEFT\n"
"\tcall nz, MoveLeft"
msgstr "\tld a, [wCurKeys]\n"
"\tand a, PADF_LEFT\n"
"\tcall nz, MoveLeft"

#: src/part3/the-player.md:113
msgid "\tld a, [wCurKeys]\n"
"\tand a, PADF_RIGHT\n"
"\tcall nz, MoveRight"
msgstr "\tld a, [wCurKeys]\n"
"\tand a, PADF_RIGHT\n"
"\tcall nz, MoveRight"

#: src/part3/the-player.md:117
msgid "\tld a, [wCurKeys]\n"
"\tand a, PADF_A\n"
"\tcall nz, TryShoot\n"
"```"
msgstr ""

#: src/part3/the-player.md:122
msgid "For player movement, our X & Y are 16-bit integers. These both require two bytes. There is a little endian ordering, the first byte will be the low byte. The second byte will be the high byte. To increase/decrease these values, we add/subtract our change amount to/from the low byte. Then afterwards, we add/subtract the remainder of that operation to/from the high byte."
msgstr ""

#: src/part3/the-player.md:124
msgid "```rgbasm,linenos,start=213\n"
"MoveUp:"
msgstr ""

#: src/part3/the-player.md:127
msgid "    ; decrease the player's y position\n"
"    ld a, [wPlayerPositionY+0]\n"
"    sub a, PLAYER_MOVE_SPEED\n"
"    ld [wPlayerPositionY+0], a"
msgstr ""

#: src/part3/the-player.md:132
msgid "    ld a, [wPlayerPositionY+1]\n"
"    sbc a, 0\n"
"    ld [wPlayerPositionY+1], a"
msgstr ""

#: src/part3/the-player.md:138
msgid "MoveDown:"
msgstr ""

#: src/part3/the-player.md:140
msgid "    ; increase the player's y position\n"
"    ld a, [wPlayerPositionY+0]\n"
"    add a, PLAYER_MOVE_SPEED\n"
"    ld [wPlayerPositionY+0], a"
msgstr ""

#: src/part3/the-player.md:145
msgid "    ld a, [wPlayerPositionY+1]\n"
"    adc a, 0\n"
"    ld [wPlayerPositionY+1], a"
msgstr ""

#: src/part3/the-player.md:151
msgid "MoveLeft:"
msgstr ""

#: src/part3/the-player.md:153
msgid "    ; decrease the player's x position\n"
"    ld a, [wPlayerPositionX+0]\n"
"    sub a, PLAYER_MOVE_SPEED\n"
"    ld [wPlayerPositionX+0], a"
msgstr ""

#: src/part3/the-player.md:158
msgid "    ld a, [wPlayerPositionX+1]\n"
"    sbc a, 0\n"
"    ld [wPlayerPositionX+1], a\n"
"    ret"
msgstr ""

#: src/part3/the-player.md:163
msgid "MoveRight:"
msgstr ""

#: src/part3/the-player.md:165
msgid "    ; increase the player's x position\n"
"    ld a, [wPlayerPositionX+0]\n"
"    add a, PLAYER_MOVE_SPEED\n"
"    ld [wPlayerPositionX+0], a"
msgstr ""

#: src/part3/the-player.md:170
msgid "    ld a, [wPlayerPositionX+1]\n"
"    adc a, 0\n"
"    ld [wPlayerPositionX+1], a"
msgstr ""

#: src/part3/the-player.md:177
msgid "When the player wants to shoot, we first check if the A button previously was down. If it was, we won't shoot a new bullet. This avoids bullet spamming a little. For spawning bullets, we have a function called \"FireNextBullet\". This function will need the new bullet's 8-bit X coordinate and 16-bit Y coordinate, both set in a variable it uses called \"wNextBullet\""
msgstr ""

#: src/part3/the-player.md:179
msgid "```rgbasm,linenos,start=189\n"
"TryShoot:\n"
"\tld a, [wLastKeys]\n"
"\tand a, PADF_A\n"
"    ret nz"
msgstr ""

#: src/part3/the-player.md:185
msgid "    call FireNextBullet;"
msgstr ""

#: src/part3/the-player.md:190
msgid "After we've potentially moved the player and/or shot a new bullet. We need to draw our player. However, to create the \"flashing\" effect when damaged, we'll conditionally NOT draw our player sprite. We do this based on the \"wPlayerFlash\" variable."
msgstr ""

#: src/part3/the-player.md:192
msgid "- If the \"wPlayerFlash\" variable is 0, the player is not damaged, we'll skip to drawing our player sprite.\n"
"- Otherwise, decrease the \"wPlayerFlash\" variable by 5.\n"
"    - We'll shift all the bits of the \"wPlayerFlash\" variable to the right 4 times\n"
"    - If the result is less than 5, we'll stop flashing and draw our player metasprite.\n"
"    - Otherwise, if the first bit of the decscaled \"wPlayerFLash\" variable is 1, we'll skip drawing the player."
msgstr ""

#: src/part3/the-player.md:198
msgid "> ***NOTE:** The following resumes from where the \"UpdatePlayer_HandleInput\" label ended above."
msgstr ""

#: src/part3/the-player.md:200
msgid "```rgbasm,linenos,start=72\n"
"    ld a, [mPlayerFlash+0]\n"
"    ld b, a"
msgstr ""

#: src/part3/the-player.md:204
msgid "    ld a, [mPlayerFlash+1]\n"
"    ld c, a"
msgstr ""

#: src/part3/the-player.md:207
msgid "UpdatePlayer_UpdateSprite_CheckFlashing:"
msgstr ""

#: src/part3/the-player.md:209
msgid "    ld a, b\n"
"    or a, c\n"
"    jp z, UpdatePlayer_UpdateSprite"
msgstr ""

#: src/part3/the-player.md:213
msgid "    ; decrease bc by 5\n"
"    ld a, b\n"
"    sub a, 5\n"
"    ld b, a\n"
"    ld a, c\n"
"    sbc a, 0\n"
"    ld c, a\n"
"    "
msgstr ""

#: src/part3/the-player.md:222
msgid "UpdatePlayer_UpdateSprite_DecreaseFlashing:"
msgstr ""

#: src/part3/the-player.md:224
msgid "    ld a, b\n"
"    ld [mPlayerFlash+0], a\n"
"    ld a, c\n"
"    ld [mPlayerFlash+1], a"
msgstr ""

#: src/part3/the-player.md:229
msgid "    ; descale bc\n"
"    srl c\n"
"    rr b\n"
"    srl c\n"
"    rr b\n"
"    srl c\n"
"    rr b\n"
"    srl c\n"
"    rr b"
msgstr ""

#: src/part3/the-player.md:239
msgid "    ld a, b\n"
"    cp a, 5\n"
"    jp c, UpdatePlayer_UpdateSprite_StopFlashing"
msgstr ""

#: src/part3/the-player.md:244
msgid "    bit 0, b\n"
"    jp z, UpdatePlayer_UpdateSprite"
msgstr ""

#: src/part3/the-player.md:247
msgid "UpdatePlayer_UpdateSprite_Flashing:"
msgstr ""

#: src/part3/the-player.md:249
msgid "    ret;\n"
"UpdatePlayer_UpdateSprite_StopFlashing:"
msgstr ""

#: src/part3/the-player.md:252
msgid "    ld a, 0\n"
"    ld [mPlayerFlash+0],a\n"
"    ld [mPlayerFlash+1],a\n"
"```"
msgstr ""

#: src/part3/the-player.md:257
msgid "If we get past all of the \"wPlayerFlash\" logic, we'll draw our player using the \"DrawMetasprite\" function we previously discussed."
msgstr ""

#: src/part3/the-player.md:259
msgid "```rgbasm,linenos,start=127\n"
"UpdatePlayer_UpdateSprite:"
msgstr ""

#: src/part3/the-player.md:262
msgid "    ; Get the unscaled player x position in b\n"
"    ld a, [wPlayerPositionX+0]\n"
"    ld b, a\n"
"    ld a, [wPlayerPositionX+1]\n"
"    ld d, a\n"
"    \n"
"    srl d\n"
"    rr b\n"
"    srl d\n"
"    rr b\n"
"    srl d\n"
"    rr b\n"
"    srl d\n"
"    rr b"
msgstr ""

#: src/part3/the-player.md:277
msgid "    ; Get the unscaled player y position in c\n"
"    ld a, [wPlayerPositionY+0]\n"
"    ld c, a\n"
"    ld a, [wPlayerPositionY+1]\n"
"    ld e, a"
msgstr ""

#: src/part3/the-player.md:283
msgid "    srl e\n"
"    rr c\n"
"    srl e\n"
"    rr c\n"
"    srl e\n"
"    rr c\n"
"    srl e\n"
"    rr c\n"
"    \n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ; Drawing the palyer metasprite\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/the-player.md:297
msgid "    ; Save the address of the metasprite into the 'wMetaspriteAddress' variable\n"
"    ; Our DrawMetasprites functoin uses that variable\n"
"    ld a, LOW(playerTestMetaSprite)\n"
"    ld [wMetaspriteAddress+0], a\n"
"    ld a, HIGH(playerTestMetaSprite)\n"
"    ld [wMetaspriteAddress+1], a"
msgstr ""

#: src/part3/the-player.md:305
#: src/part3/bullets.md:258
msgid "    ; Save the x position\n"
"    ld a, b\n"
"    ld [wMetaspriteX],a"
msgstr ""

#: src/part3/the-player.md:309
#: src/part3/bullets.md:262
msgid "    ; Save the y position\n"
"    ld a, c\n"
"    ld [wMetaspriteY],a"
msgstr ""

#: src/part3/the-player.md:313
#: src/part3/enemies.md:327
msgid "    ; Actually call the 'DrawMetasprites function\n"
"    call DrawMetasprites;"
msgstr ""

#: src/part3/the-player.md:316
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/the-player.md:323
msgid "That's the end our our \"UpdatePlayer\" function. The final bit of code for our player handles when they are damaged. When an enemy damages the player, we want to decrease our lives by one. We'll also start flashing  by giving our 'mPlayerFlash' variable a non-zero value. In the gameplay game state, if we've lost all lives, gameplay will end."
msgstr ""

#: src/part3/the-player.md:325
msgid "```rgbasm,linenos,start=198\n"
"DamagePlayer::"
msgstr ""

#: src/part3/the-player.md:328
msgid "    "
msgstr ""

#: src/part3/the-player.md:330
msgid "    ld a, 0\n"
"    ld [mPlayerFlash+0], a\n"
"    ld a, 1\n"
"    ld [mPlayerFlash+1], a"
msgstr ""

#: src/part3/the-player.md:335
msgid "    ld a, [wLives]\n"
"    dec a\n"
"    ld [wLives], a"
msgstr ""

#: src/part3/the-player.md:342
msgid "That's everything for our player. Next, we'll go over bullets and then onto the enemies."
msgstr ""

#: src/part3/bullets.md:1
msgid "# Bullets"
msgstr ""

#: src/part3/bullets.md:3
msgid "Bullets are relatively simple, logic-wise. They all travel straight-forward, and de-activate themselves when they leave the screen."
msgstr ""

#: src/part3/bullets.md:5
msgid "At the top of our \"src/main/states/gameplay/objects/bullets.asm\" file we'll setup some variables for bullets and include our tile data."
msgstr ""

#: src/part3/bullets.md:7
msgid "```rgbasm,linenos,start=2\n"
"include \"src/main/utils/hardware.inc\"\n"
"include \"src/main/utils/constants.inc\""
msgstr ""

#: src/part3/bullets.md:11
msgid "SECTION \"BulletVariables\", WRAM0"
msgstr ""

#: src/part3/bullets.md:13
msgid "wSpawnBullet:db"
msgstr ""

#: src/part3/bullets.md:15
msgid "; how many bullets are currently active\n"
"wActiveBulletCounter:: db"
msgstr ""

#: src/part3/bullets.md:18
msgid "; how many bullet's we've updated\n"
"wUpdateBulletsCounter:db "
msgstr ""

#: src/part3/bullets.md:24
msgid "SECTION \"Bullets\", ROM0"
msgstr ""

#: src/part3/bullets.md:26
msgid "bulletMetasprite::\n"
"    .metasprite1    db 0,0,8,0\n"
"    .metaspriteEnd  db 128"
msgstr ""

#: src/part3/bullets.md:36
msgid "We'll need to loop through the bullet object pool in the following sections. "
msgstr ""

#: src/part3/bullets.md:38
msgid "## Initiating Bullets"
msgstr ""

#: src/part3/bullets.md:40
msgid "In our \"InitializeBullets\" function, we'll copy the tile data for the bullet sprites into VRAM, and set every bullet as inactive. Each bullet is 4 bytes, the first byte signaling if the bullet is active or not. "
msgstr ""

#: src/part3/bullets.md:44
msgid "We'll iterate through bullet object pool, named \"wBullets\", and activate the first of the the four bytes. Then skipping the next 3 bytes, to go onto the next bullet. We'll do this until we've looped for each bullet in our pool."
msgstr ""

#: src/part3/bullets.md:46
msgid "```rgbasm,linenos,start=29\n"
"InitializeBullets::"
msgstr ""

#: src/part3/bullets.md:49
msgid "    ld a, 0\n"
"    ld [wSpawnBullet], a"
msgstr ""

#: src/part3/bullets.md:52
msgid "    ; Copy the bullet tile data intto vram\n"
"\tld de, bulletTileData\n"
"\tld hl, BULLET_TILES_START\n"
"\tld bc, bulletTileDataEnd - bulletTileData\n"
"    call CopyDEintoMemoryAtHL"
msgstr ""

#: src/part3/bullets.md:58
msgid "    ; Reset how many bullets are active to 0\n"
"    ld a,0\n"
"    ld [wActiveBulletCounter],a"
msgstr ""

#: src/part3/bullets.md:62
msgid "    ld b, 0\n"
"    ld hl, wBullets"
msgstr "    ld b, 0\n"
"    ld hl, wBullets"

#: src/part3/bullets.md:65
msgid "InitializeBullets_Loop:"
msgstr ""

#: src/part3/bullets.md:67
msgid "    ld a, 0\n"
"    ld [hl], a"
msgstr "    ld a, 0\n"
"    ld [hl], a"

#: src/part3/bullets.md:70
msgid "    ; Increase the address\n"
"    ld a, l\n"
"    add a, PER_BULLET_BYTES_COUNT\n"
"    ld l, a\n"
"    ld a, h\n"
"    adc a, 0\n"
"    ld h, a"
msgstr ""

#: src/part3/bullets.md:78
msgid "    ; Increase how many bullets we have initailized\n"
"    ld a, b\n"
"    inc a\n"
"    ld b ,a"
msgstr ""

#: src/part3/bullets.md:83
msgid "    cp a, MAX_BULLET_COUNT\n"
"    ret z"
msgstr "    cp a, MAX_BULLET_COUNT\n"
"    ret z"

#: src/part3/bullets.md:86
msgid "    jp InitializeBullets_Loop\n"
"```"
msgstr "    jp InitializeBullets_Loop\n"
"```"

#: src/part3/bullets.md:89
msgid "## Updating Bullets"
msgstr ""

#: src/part3/bullets.md:91
msgid "When we want to update each of bullets, first we should check if any bullets are active. If no bullets are active we can stop early."
msgstr ""

#: src/part3/bullets.md:93
msgid "```rgbasm,linenos,start=70\n"
"UpdateBullets::"
msgstr "```rgbasm,linenos,start=70\n"
"UpdateBullets::"

#: src/part3/bullets.md:96
msgid "    ; Make sure we have SOME active enemies\n"
"    ld a, [wSpawnBullet]\n"
"    ld b, a\n"
"    ld a, [wActiveBulletCounter]\n"
"    or a,b\n"
"    cp a, 0\n"
"    ret z\n"
"    \n"
"    ; Reset our counter for how many bullets we have checked\n"
"    ld a, 0\n"
"    ld [wUpdateBulletsCounter], a"
msgstr ""

#: src/part3/bullets.md:108
msgid "    ; Get the address of the first bullet in hl\n"
"    ld a, LOW(wBullets)\n"
"    ld l,  a\n"
"    ld a, HIGH(wBullets)\n"
"    ld h, a"
msgstr ""

#: src/part3/bullets.md:114
msgid "    jp UpdateBullets_PerBullet\n"
"```"
msgstr "    jp UpdateBullets_PerBullet\n"
"```"

#: src/part3/bullets.md:117
msgid "If we have active bullets, we'll reset how many bullets we've checked and set our \"hl\" registers to point to the first bullets address. "
msgstr ""

#: src/part3/bullets.md:119
msgid "When were updating each bullet, we'll check each byte, changing hl (the byte we want to read) as we go. At the start, \"hl\" should point to the first byte. \"hl\" should point to the first byte at the end too:"
msgstr ""

#: src/part3/bullets.md:121
msgid "> HL should point to the first byte at the end so we can easily do one of two things:\n"
"> * deactivate the bullet\n"
"> * jump to the next bullet (by simply adding 4 to hl)"
msgstr ""

#: src/part3/bullets.md:125
msgid "For we each bullet, we'll do the following:"
msgstr ""

#: src/part3/bullets.md:127
msgid "* Check if active\n"
"* Get our x position, save into b\n"
"* Get our y scaled positon, save into c (low byte), and d (high byte)\n"
"* Decrease our y position to move the bullet upwards\n"
"* Reset HL to the first byte of our bullet\n"
"* Descale the y position we have in c & d, and jump to our deactivation code if c (the low byte) is high enough\n"
"* Draw our bullet metasprit, if it wasn't previously deactivated"
msgstr ""

#: src/part3/bullets.md:135
msgid "```rgbasm,linenos,start=113\n"
"UpdateBullets_PerBullet:"
msgstr ""

#: src/part3/bullets.md:138
msgid "    ; The first byte is if the bullet is active\n"
"    ; If it's NOT  zero, it's active, go to the normal update section\n"
"    ld a, [hl]\n"
"    cp a, 0\n"
"    jp nz, UpdateBullets_PerBullet_Normal"
msgstr ""

#: src/part3/bullets.md:144
msgid "    ; Do we need to spawn a bullet?\n"
"    ; If we dont, loop to the next enemy\n"
"    ld a, [wSpawnBullet]\n"
"    cp a, 0\n"
"    jp z, UpdateBullets_Loop\n"
"    \n"
"UpdateBullets_PerBullet_SpawnDeactivatedBullet:"
msgstr ""

#: src/part3/bullets.md:152
msgid "    ; reset this variable so we don't spawn anymore\n"
"    ld a, 0\n"
"    ld [wSpawnBullet], a\n"
"    \n"
"    ; Increase how many bullets are active\n"
"    ld a,[wActiveBulletCounter]\n"
"    inc a\n"
"    ld [wActiveBulletCounter], a"
msgstr ""

#: src/part3/bullets.md:161
#: src/part3/bullets.md:245
#: src/part3/enemies.md:149
#: src/part3/enemies.md:270
#: src/part3/enemies.md:286
#: src/part3/enemies.md:306
#: src/part3/enemy-bullet-collision.md:70
msgid "    push hl"
msgstr "    push hl"

#: src/part3/bullets.md:163
msgid "    ; Set the current bullet as  active\n"
"    ld a, 1\n"
"    ld [hli], a"
msgstr ""

#: src/part3/bullets.md:167
msgid "    ; Get the unscaled player x position in b\n"
"    ld a, [wPlayerPositionX+0]\n"
"    ld b, a\n"
"    ld a, [wPlayerPositionX+1]\n"
"    ld d, a\n"
"    \n"
"    ; Descale the player's x position\n"
"    ; the result will only be in the low byt\n"
"    srl d\n"
"    rr b\n"
"    srl d\n"
"    rr b\n"
"    srl d\n"
"    rr b\n"
"    srl d\n"
"    rr b\n"
"    \n"
"    ; Set the x position to equal the player's x position\n"
"    ld a, b\n"
"    ld [hli], a"
msgstr ""

#: src/part3/bullets.md:188
msgid "    ; Set the y position (low)\n"
"    ld a, [wPlayerPositionY+0]\n"
"    ld [hli], a"
msgstr ""

#: src/part3/bullets.md:192
msgid "    ;Set the y position (high)\n"
"    ld a, [wPlayerPositionY+1]\n"
"    ld [hli], a"
msgstr ""

#: src/part3/bullets.md:196
#: src/part3/enemies.md:241
#: src/part3/enemies.md:279
msgid "    pop hl"
msgstr "    pop hl"

#: src/part3/bullets.md:198
msgid "UpdateBullets_PerBullet_Normal:"
msgstr "UpdateBullets_PerBullet_Normal:"

#: src/part3/bullets.md:200
msgid "    ; Save our active byte\n"
"    push hl"
msgstr ""

#: src/part3/bullets.md:203
#: src/part3/enemies.md:223
#: src/part3/enemy-bullet-collision.md:63
msgid "    inc hl"
msgstr "    inc hl"

#: src/part3/bullets.md:205
msgid "    ; Get our x position\n"
"    ld a, [hli]\n"
"    ld b, a"
msgstr ""

#: src/part3/bullets.md:209
msgid "    ; get our 16-bit y position\n"
"    ld a, [hl]\n"
"    sub a, BULLET_MOVE_SPEED\n"
"    ld [hli], a\n"
"    ld c, a\n"
"    ld a, [hl] \n"
"    sbc a, 0\n"
"    ld [hl], a\n"
"    ld d, a"
msgstr ""

#: src/part3/bullets.md:219
msgid "    pop hl; go to the active byte"
msgstr ""

#: src/part3/bullets.md:221
msgid "    ; Descale our y position\n"
"    srl d\n"
"    rr c\n"
"    srl d\n"
"    rr c\n"
"    srl d\n"
"    rr c\n"
"    srl d\n"
"    rr c"
msgstr ""

#: src/part3/bullets.md:231
msgid "    ; See if our non scaled low byte is above 160\n"
"    ld a, c\n"
"    cp a, 178\n"
"    ; If it below 160, continue on  to deactivate\n"
"    jp nc, UpdateBullets_DeActivateIfOutOfBounds\n"
"    \n"
"```"
msgstr ""

#: src/part3/bullets.md:239
msgid "### Drawing the Bullets"
msgstr ""

#: src/part3/bullets.md:241
msgid "We'll draw our bullet metasprite like we drew the player, using our \"DrawMetasprites\" function. This function may alter the 'h' or 'l' registers, so we'll push the hl register onto the stack before hand. After drawing, we'll pop the hl register off of the stack to restore it's value."
msgstr ""

#: src/part3/bullets.md:243
msgid "```rgbasm,linenos,start=214"
msgstr "```rgbasm,linenos,start=214"

#: src/part3/bullets.md:247
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;; Drawing a metasprite\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/bullets.md:251
msgid "     ; Save the address of the metasprite into the 'wMetaspriteAddress' variable\n"
"    ; Our DrawMetasprites functoin uses that variable\n"
"    ld a, LOW(bulletMetasprite)\n"
"    ld [wMetaspriteAddress+0], a\n"
"    ld a, HIGH(bulletMetasprite)\n"
"    ld [wMetaspriteAddress+1], a"
msgstr ""

#: src/part3/bullets.md:266
msgid "    ; Actually call the 'DrawMetasprites function\n"
"    call DrawMetasprites;\n"
"    \n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    "
msgstr ""

#: src/part3/bullets.md:272
msgid "    pop hl\n"
"    \n"
"    jp UpdateBullets_Loop\n"
"```"
msgstr ""

#: src/part3/bullets.md:277
msgid "### Deactivating the Bullets"
msgstr ""

#: src/part3/bullets.md:279
msgid "If a bullet needs to be deactivated, we simply set it's first byte to 0. At this point in time, the \"hl\" registers should point at our bullets first byte. This makes deactivation a really simple task. In addition to changing the first byte, we'll decrease how many bullets we have that are active."
msgstr ""

#: src/part3/bullets.md:281
msgid "```rgbasm,linenos,start=246\n"
"UpdateBullets_DeActivateIfOutOfBounds:"
msgstr ""

#: src/part3/bullets.md:284
msgid "    ; if it's y value is grater than 160\n"
"    ; Set as inactive\n"
"    ld a, 0\n"
"    ld [hl], a"
msgstr ""

#: src/part3/bullets.md:289
msgid "    ; Decrease counter\n"
"    ld a,[wActiveBulletCounter]\n"
"    dec a\n"
"    ld [wActiveBulletCounter], a"
msgstr ""

#: src/part3/bullets.md:294
msgid "    jp UpdateBullets_Loop\n"
"```"
msgstr "    jp UpdateBullets_Loop\n"
"```"

#: src/part3/bullets.md:298
msgid "### Updating the next bullet"
msgstr ""

#: src/part3/bullets.md:300
msgid "After we've updated a single bullet, we'll increase how many bullet's we've updated. If we've updated all the bullets, we can stop our \"UpdateBullets\" function. Otherwise, we'll add 4 bytes to the addressed stored in \"hl\", and update the next bullet."
msgstr ""

#: src/part3/bullets.md:302
msgid "```rgbasm,linenos,start=92\n"
"UpdateBullets_Loop:"
msgstr ""

#: src/part3/bullets.md:305
msgid "    ; Check our counter, if it's zero\n"
"    ; Stop the function\n"
"    ld a, [wUpdateBulletsCounter]\n"
"    inc a\n"
"    ld [wUpdateBulletsCounter], a"
msgstr ""

#: src/part3/bullets.md:311
msgid "    ; Check if we've already\n"
"    ld a, [wUpdateBulletsCounter]\n"
"    cp a, MAX_BULLET_COUNT\n"
"    ret nc"
msgstr ""

#: src/part3/bullets.md:316
msgid "    ; Increase the bullet data our address is pointingtwo\n"
"    ld a, l\n"
"    add a, PER_BULLET_BYTES_COUNT\n"
"    ld l, a\n"
"    ld a, h\n"
"    adc a, 0\n"
"    ld h, a\n"
"```"
msgstr ""

#: src/part3/bullets.md:326
msgid "## Firing New Bullets"
msgstr ""

#: src/part3/bullets.md:328
msgid "During the \"UpdatePlayer\" function previously, when use pressed A we called the \"FireNextBullet\" function."
msgstr ""

#: src/part3/bullets.md:330
msgid "This function will loop through each bullet in the bullet object pool. When it finds an inactive bullet, it will activate it and set it's position equal to the players."
msgstr ""

#: src/part3/bullets.md:332
msgid "> Our bullets only use one 8-bit integer for their x position, so need to de-scale the player's 16-bit scaled x position"
msgstr ""

#: src/part3/bullets.md:334
msgid "```rgbasm,linenos,start=260\n"
"FireNextBullet::"
msgstr ""

#: src/part3/bullets.md:337
msgid "    ; Make sure we don't have the max amount of enmies\n"
"    ld a, [wActiveBulletCounter]\n"
"    cp a, MAX_BULLET_COUNT\n"
"    ret nc"
msgstr ""

#: src/part3/bullets.md:342
msgid "    ; Set our spawn bullet variable to true\n"
"    ld a, 1\n"
"    ld [wSpawnBullet], a"
msgstr ""

#: src/part3/bullets.md:349
msgid "That's it for bullets logic. Next we'll cover enemies, and after that we'll step back into the world of bullets with \"Bullet vs Enemy\" Collision."
msgstr ""

#: src/part3/enemies.md:1
msgid "# Enemies"
msgstr ""

#: src/part3/enemies.md:3
msgid "Enemies in SHMUPS often come in a variety of types, and travel also in a variety of patterns. To keep things simple for this tutorial, we'll have one enemy that flys straight downward. Because of this decision, the logic for enemies is going to be similar to bullets in a way. They both travel vertically and disappear when off screeen. Some differences to point out are:"
msgstr ""

#: src/part3/enemies.md:5
msgid "- Enemies are not spawned by the player, so we need logic that spawns them at random times and locations.\n"
"- Enemies must check for collision against the player\n"
"- We'll check for collision against bullets in the enemy update function."
msgstr ""

#: src/part3/enemies.md:9
msgid "Here are the RAM variables we'll use for our enemies:"
msgstr ""

#: src/part3/enemies.md:11
msgid "- wCurrentEnemyX & wCurrentEnemyY - When we check for collisions, we'll save the current enemy's position in these two variables.\n"
"- wNextEnemyXPosition - When this variable has a non-zero value, we'll spawn a new enemy at that position\n"
"- wSpawnCounter - We'll decrease this, when it reaches zero we'll spawn a new enemy (by setting 'wNextEnemyXPosition' to a non-zero value).\n"
"- wActiveEnemyCounter - This tracks how many enemies we have on screen\n"
"- wUpdateEnemiesCounter - This is used when updating enemies so we know how many we have updated.\n"
"- wUpdateEnemiesCurrentEnemyAddress - When we check for enemy v. bullet collision, we'll save the address of our current enemy here."
msgstr ""

#: src/part3/enemies.md:18
msgid "```rgbasm,linenos,start=1\n"
"include \"src/main/utils/hardware.inc\"\n"
"include \"src/main/utils/constants.inc\""
msgstr "```rgbasm,linenos,start=1\n"
"include \"src/main/utils/hardware.inc\"\n"
"include \"src/main/utils/constants.inc\""

#: src/part3/enemies.md:22
msgid "SECTION \"EnemyVariables\", WRAM0"
msgstr "SECTION \"EnemyVariables\", WRAM0"

#: src/part3/enemies.md:24
msgid "wCurrentEnemyX:: db  \n"
"wCurrentEnemyY:: db  "
msgstr "wCurrentEnemyX:: db  \n"
"wCurrentEnemyY:: db  "

#: src/part3/enemies.md:27
msgid "wSpawnCounter: db  \n"
"wNextEnemyXPosition: db\n"
"wActiveEnemyCounter::db\n"
"wUpdateEnemiesCounter:db\n"
"wUpdateEnemiesCurrentEnemyAddress::dw"
msgstr "wSpawnCounter: db  \n"
"wNextEnemyXPosition: db\n"
"wActiveEnemyCounter::db\n"
"wUpdateEnemiesCounter:db\n"
"wUpdateEnemiesCurrentEnemyAddress::dw"

#: src/part3/enemies.md:38
msgid "Just like with bullets, we'll setup ROM data for our enemies tile data and metasprites."
msgstr ""

#: src/part3/enemies.md:40
msgid "```rgbasm,linenos,start=18\n"
"SECTION \"Enemies\", ROM0"
msgstr "```rgbasm,linenos,start=18\n"
"SECTION \"Enemies\", ROM0"

#: src/part3/enemies.md:46
msgid "enemyShipMetasprite::\n"
"    .metasprite1    db 0,0,4,0\n"
"    .metasprite2    db 0,8,6,0\n"
"    .metaspriteEnd  db 128\n"
"```"
msgstr "enemyShipMetasprite::\n"
"    .metasprite1    db 0,0,4,0\n"
"    .metasprite2    db 0,8,6,0\n"
"    .metaspriteEnd  db 128\n"
"```"

#: src/part3/enemies.md:52
msgid "## Initializing Enemies"
msgstr ""

#: src/part3/enemies.md:54
msgid "When initializing the enemies (at the start of gameplay), we'll copy the enemy tile data into VRAM. Also, like with bullets, we'll loop through and make sure each enemy is set to inactive."
msgstr ""

#: src/part3/enemies.md:56
msgid "```rgbasm,linenos,start=28\n"
"InitializeEnemies::"
msgstr ""

#: src/part3/enemies.md:59
msgid "\tld de, enemyShipTileData\n"
"\tld hl, ENEMY_TILES_START\n"
"\tld bc, enemyShipTileDataEnd - enemyShipTileData\n"
"    call CopyDEintoMemoryAtHL"
msgstr "\tld de, enemyShipTileData\n"
"\tld hl, ENEMY_TILES_START\n"
"\tld bc, enemyShipTileDataEnd - enemyShipTileData\n"
"    call CopyDEintoMemoryAtHL"

#: src/part3/enemies.md:64
msgid "    ld a, 0\n"
"    ld [wSpawnCounter], a\n"
"    ld [wActiveEnemyCounter], a\n"
"    ld [wNextEnemyXPosition], a"
msgstr "    ld a, 0\n"
"    ld [wSpawnCounter], a\n"
"    ld [wActiveEnemyCounter], a\n"
"    ld [wNextEnemyXPosition], a"

#: src/part3/enemies.md:69
msgid "    ld b, 0"
msgstr "    ld b, 0"

#: src/part3/enemies.md:71
msgid "    ld hl, wEnemies"
msgstr "    ld hl, wEnemies"

#: src/part3/enemies.md:73
msgid "InitializeEnemies_Loop:"
msgstr "InitializeEnemies_Loop:"

#: src/part3/enemies.md:75
msgid "    ; Set as inactive\n"
"    ld a, 0\n"
"    ld [hl], a\n"
"    \n"
"    ; Increase the address\n"
"    ld a, l\n"
"    add a, PER_ENEMY_BYTES_COUNT\n"
"    ld l, a\n"
"    ld a, h\n"
"    adc a, 0\n"
"    ld h, a"
msgstr "    ; Imposta come inattivo\n"
"    ld a, 0\n"
"    ld [hl], a\n"
"    \n"
"    ; Aumenta il registro\n"
"    ld a, l\n"
"    add a, PER_ENEMY_BYTES_COUNT\n"
"    ld l, a\n"
"    ld a, h\n"
"    adc a, 0\n"
"    ld h, a"

#: src/part3/enemies.md:87
msgid "    ld a, b\n"
"    inc a\n"
"    ld b ,a"
msgstr "    ld a, b\n"
"    inc a\n"
"    ld b ,a"

#: src/part3/enemies.md:91
msgid "    cp a, MAX_ENEMY_COUNT\n"
"    ret z"
msgstr "    cp a, MAX_ENEMY_COUNT\n"
"    ret z"

#: src/part3/enemies.md:94
msgid "    jp InitializeEnemies_Loop\n"
"```"
msgstr "    jp InitializeEnemies_Loop\n"
"```"

#: src/part3/enemies.md:97
msgid "## Updating Enemies"
msgstr ""

#: src/part3/enemies.md:99
msgid "When \"UpdateEnemies\" is called from gameplay, the first thing we try to do is spawn new enemies. After that, if we have no active enemies (and are not trying to spawn a new enemy), we stop the \"UpdateEnemies\" function. From here, like with bullets, we'll save the address of our first enemy in hl and start looping through."
msgstr ""

#: src/part3/enemies.md:101
msgid "```rgbasm,linenos,start=67\n"
"UpdateEnemies::"
msgstr "```rgbasm,linenos,start=67\n"
"UpdateEnemies::"

#: src/part3/enemies.md:104
msgid "\tcall TryToSpawnEnemies"
msgstr "\tcall TryToSpawnEnemies"

#: src/part3/enemies.md:106
msgid "    ; Make sure we have active enemies\n"
"    ; or we want to spawn a new enemy\n"
"    ld a, [wNextEnemyXPosition]\n"
"    ld b, a\n"
"    ld a, [wActiveEnemyCounter]\n"
"    or a, b\n"
"    cp a, 0\n"
"    ret z\n"
"    \n"
"    ld a, 0\n"
"    ld [wUpdateEnemiesCounter], a"
msgstr ""

#: src/part3/enemies.md:118
msgid "    ld a, LOW(wEnemies)\n"
"    ld l, a\n"
"    ld a, HIGH(wEnemies)\n"
"    ld h, a"
msgstr "    ld a, LOW(wEnemies)\n"
"    ld l, a\n"
"    ld a, HIGH(wEnemies)\n"
"    ld h, a"

#: src/part3/enemies.md:123
msgid "    jp UpdateEnemies_PerEnemy\n"
"```"
msgstr "    jp UpdateEnemies_PerEnemy\n"
"```"

#: src/part3/enemies.md:126
msgid "When we are  looping through our enemy object pool, let's check if the current enemy is active. If it's active, we'll update it like normal. If it isn't active, the game checks if we want to spawn a new enemy. We specify we want to spawn a new enemy by setting 'wNextEnemyXPosition' to a non-zero value. If we don't want to spawn a new enemy, we'll move on to the next enemy."
msgstr ""

#: src/part3/enemies.md:128
msgid "If we want to spawn a new enemy, we'll set the current inactive enemy to active. Afterwards, we'll set it's y position to zero, and it's x position to whatever was in the 'wNextEnemyXPosition' variable. After that, we'll increase our active enemy counter, and go on to update the enemy like normal."
msgstr ""

#: src/part3/enemies.md:130
msgid "```rgbasm,linenos,start=111\n"
"UpdateEnemies_PerEnemy:"
msgstr "```rgbasm,linenos,start=111\n"
"UpdateEnemies_PerEnemy:"

#: src/part3/enemies.md:133
msgid "    ; The first byte is if the current object is active\n"
"    ; If it's not zero, it's active, go to the normal update section\n"
"    ld a, [hl]\n"
"    cp 0\n"
"    jp nz, UpdateEnemies_PerEnemy_Update"
msgstr ""

#: src/part3/enemies.md:139
msgid "UpdateEnemies_SpawnNewEnemy:"
msgstr "UpdateEnemies_SpawnNewEnemy:"

#: src/part3/enemies.md:141
msgid "    ; If this enemy is NOT active\n"
"    ; Check If we want to spawn a new enemy\n"
"    ld a, [wNextEnemyXPosition]\n"
"    cp 0"
msgstr ""

#: src/part3/enemies.md:146
msgid "    ; If we don't want to spawn a new enemy, we'll skip this (deactivated) enemy\n"
"    jp z, UpdateEnemies_Loop"
msgstr ""

#: src/part3/enemies.md:151
msgid "    ; If they are deactivated, and we want to spawn an enemy\n"
"    ; activate the enemy\n"
"    ld a, 1\n"
"    ld [hli], a"
msgstr ""

#: src/part3/enemies.md:156
msgid "    ; Put the value for our enemies x position\n"
"    ld a, [wNextEnemyXPosition]\n"
"    ld [hli], a"
msgstr ""

#: src/part3/enemies.md:160
msgid "    ; Put the value for our enemies y position to equal 0\n"
"    ld a, 0\n"
"    ld [hli], a\n"
"    ld [hld], a"
msgstr ""

#: src/part3/enemies.md:165
msgid "    ld a, 0\n"
"    ld [wNextEnemyXPosition], a"
msgstr "    ld a, 0\n"
"    ld [wNextEnemyXPosition], a"

#: src/part3/enemies.md:168
msgid "    pop hl\n"
"    \n"
"    ; Increase counter\n"
"    ld a,[wActiveEnemyCounter]\n"
"    inc a\n"
"    ld [wActiveEnemyCounter], a"
msgstr "    pop hl\n"
"    \n"
"    ; Aumenta contatore\n"
"    ld a,[wActiveEnemyCounter]\n"
"    inc a\n"
"    ld [wActiveEnemyCounter], a"

#: src/part3/enemies.md:177
msgid "When We are done updating a single enemy, we'll jump to the \"UpdateEnemies_Loop\" label. Here we'll increase how many enemies we've updated, and end if we've done them all. If we still have more enemies left, we'll increase the address stored in hl by 6 and update the next enemy."
msgstr ""

#: src/part3/enemies.md:179
msgid "> The \"hl\" registers should always point to the current enemies first byte when this label is reached."
msgstr ""

#: src/part3/enemies.md:181
msgid "```rgbasm,linenos,start=89\n"
"UpdateEnemies_Loop:"
msgstr "```rgbasm,linenos,start=89\n"
"UpdateEnemies_Loop:"

#: src/part3/enemies.md:184
msgid "    ; Check our coutner, if it's zero\n"
"    ; Stop the function\n"
"    ld a, [wUpdateEnemiesCounter]\n"
"    inc a\n"
"    ld [wUpdateEnemiesCounter], a"
msgstr ""

#: src/part3/enemies.md:190
msgid "    ; Compare against the active count\n"
"    ld a, [wUpdateEnemiesCounter]\n"
"    cp a, MAX_ENEMY_COUNT\n"
"    ret nc"
msgstr ""

#: src/part3/enemies.md:195
msgid "    ; Increase the enemy data our address is pointingtwo\n"
"    ld a, l\n"
"    add a, PER_ENEMY_BYTES_COUNT\n"
"    ld  l, a\n"
"    ld a, h\n"
"    adc a, 0\n"
"    ld  h, a\n"
"```"
msgstr ""

#: src/part3/enemies.md:204
msgid "For updating enemies, we'll first get the enemies speed. Afterwards we'll increase the enemies 16-bit y position. Once we've done that, we'll descale the y position so we can check for collisions and draw the ennemy."
msgstr ""

#: src/part3/enemies.md:206
msgid "```rgbasm,linenos,start=156\n"
"UpdateEnemies_PerEnemy_Update:"
msgstr ""

#: src/part3/enemies.md:209
msgid "    ; Save our first bytye\n"
"    push hl"
msgstr ""

#: src/part3/enemies.md:212
msgid "    ; Get our move speed in e\n"
"    ld bc, enemy_speedByte\n"
"    add hl, bc\n"
"    ld a, [hl]\n"
"    ld e, a"
msgstr ""

#: src/part3/enemies.md:218
msgid "    ; Go back to the first byte\n"
"    ; put the address toe the first byte back on the stack for later\n"
"    pop hl\n"
"    push hl"
msgstr ""

#: src/part3/enemies.md:225
msgid "    ; Get our x position\n"
"    ld a, [hli]\n"
"    ld b, a\n"
"    ld [wCurrentEnemyX],a"
msgstr ""

#: src/part3/enemies.md:230
msgid "    ; get our 16-bit y position\n"
"    ; increase it (by e), but also save it \n"
"    ld a, [hl]\n"
"    add a, 10\n"
"    ld [hli], a\n"
"    ld c, a\n"
"    ld a, [hl]\n"
"    adc a, 0\n"
"    ld [hl], a\n"
"    ld d, a"
msgstr ""

#: src/part3/enemies.md:243
msgid "    ; Descale the y psoition\n"
"    srl d\n"
"    rr c\n"
"    srl d\n"
"    rr c\n"
"    srl d\n"
"    rr c\n"
"    srl d\n"
"    rr c"
msgstr ""

#: src/part3/enemies.md:253
msgid "    ld a, c\n"
"    ld [wCurrentEnemyY],a"
msgstr ""

#: src/part3/enemies.md:258
msgid "## Player & Bullet Collision"
msgstr ""

#: src/part3/enemies.md:260
msgid "One of the differences between enemies and bullets is that enemies must check for collision against the player and also against bullets. For both of these cases, we'll use a simple Axis-Aligned Bounding Box test. We'll cover the specific logic in a later section."
msgstr ""

#: src/part3/enemies.md:262
msgid "If we have a collison against the player we need to damage the player, and redraw how many lives they have. In addition, it's optional, but we'll deactivate the enemy too when they collide with the player."
msgstr ""

#: src/part3/enemies.md:264
msgid "> Our \"hl\" registers should point to the active byte of the current enemy. We push and pop our \"hl\" registers to make sure we get back to that same address for later logic."
msgstr ""

#: src/part3/enemies.md:267
msgid "```rgbasm,linenos,start=207\n"
"UpdateEnemies_PerEnemy_CheckPlayerCollision:"
msgstr ""

#: src/part3/enemies.md:272
msgid "    call CheckCurrentEnemyAgainstBullets"
msgstr ""

#: src/part3/enemies.md:274
msgid "    pop hl\n"
"    push hl"
msgstr ""

#: src/part3/enemies.md:277
msgid "    call CheckEnemyPlayerCollision"
msgstr ""

#: src/part3/enemies.md:281
msgid "    ld a, [wResult]\n"
"    cp a, 0\n"
"    jp z, UpdateEnemies_NoCollisionWithPlayer \n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/enemies.md:288
msgid "    call DamagePlayer\n"
"    call DrawLives"
msgstr ""

#: src/part3/enemies.md:291
msgid "    pop hl\n"
"    \n"
"    jp UpdateEnemies_DeActivateEnemy\n"
"```"
msgstr ""

#: src/part3/enemies.md:296
msgid "If there is no collision with the player, we'll draw the enemies. This is done just as we did the player and bullets, with the \"DrawMetasprites\" function."
msgstr ""

#: src/part3/enemies.md:298
msgid "```rgbasm,linenos,start=249\n"
"UpdateEnemies_NoCollisionWithPlayer::"
msgstr ""

#: src/part3/enemies.md:301
msgid "    ; See if our non scaled low byte is above 160\n"
"    ld a, [wCurrentEnemyY]\n"
"    cp a, 160\n"
"    jp nc, UpdateEnemies_DeActivateEnemy"
msgstr ""

#: src/part3/enemies.md:308
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ; call the 'DrawMetasprites function. setup variables and call\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/enemies.md:312
msgid "    ; Save the address of the metasprite into the 'wMetaspriteAddress' variable\n"
"    ; Our DrawMetasprites functoin uses that variable\n"
"    ld a, LOW(enemyShipMetasprite)\n"
"    ld [wMetaspriteAddress+0], a\n"
"    ld a, HIGH(enemyShipMetasprite)\n"
"    ld [wMetaspriteAddress+1], a"
msgstr ""

#: src/part3/enemies.md:319
msgid "    ; Save the x position\n"
"    ld a, [wCurrentEnemyX]\n"
"    ld [wMetaspriteX],a"
msgstr ""

#: src/part3/enemies.md:323
msgid "    ; Save the y position\n"
"    ld a, [wCurrentEnemyY]\n"
"    ld [wMetaspriteY],a"
msgstr ""

#: src/part3/enemies.md:330
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/enemies.md:334
msgid "    pop hl\n"
"    \n"
"    jp UpdateEnemies_Loop\n"
"```"
msgstr "    pop hl\n"
"    \n"
"    jp UpdateEnemies_Loop\n"
"```"

#: src/part3/enemies.md:339
msgid "## Deactivating Enemies"
msgstr ""

#: src/part3/enemies.md:341
msgid "Deactivating an enemy is just like with bullets. We'll set it's first byte to 0, and decrease our counter variable."
msgstr ""

#: src/part3/enemies.md:343
msgid "> Here, we can just use the current address in HL. This is the second reason we wanted to keep the address of our first byte on the stack."
msgstr ""

#: src/part3/enemies.md:345
msgid "```rgbasm,linenos,start=235\n"
"UpdateEnemies_DeActivateEnemy:"
msgstr ""

#: src/part3/enemies.md:348
msgid "    ; Set as inactive\n"
"    ld a, 0\n"
"    ld [hl], a"
msgstr ""

#: src/part3/enemies.md:352
msgid "    ; Decrease counter\n"
"    ld a,[wActiveEnemyCounter]\n"
"    dec a\n"
"    ld [wActiveEnemyCounter], a"
msgstr ""

#: src/part3/enemies.md:357
msgid "    jp UpdateEnemies_Loop"
msgstr "    jp UpdateEnemies_Loop"

#: src/part3/enemies.md:361
msgid "## Spawning Enemies"
msgstr ""

#: src/part3/enemies.md:363
msgid "Randomly, we want to spawn enemies. We'll increase a counter called \"wEnemyCounter\". When it reaches a preset maximum value, we'll **maybe** try to spawn a new enemy. "
msgstr ""

#: src/part3/enemies.md:365
msgid "Firstly, We need to make sure we aren't at maximum enemy capacity, if so, we will not spawn enemy more enemies. If we are not at maximum capacity, we'll try to get a x position to spawn the enemy at. If our x position is below 24 or above 150, we'll also NOT spawn a new enemy. "
msgstr ""

#: src/part3/enemies.md:367
msgid "> All enemies are spawned with y position of 0, so we only need to get the x position."
msgstr ""

#: src/part3/enemies.md:369
msgid "If we have a valid x position, we'll reset our spawn counter, and save that x position in the \"wNextEnemyXPosition\" variable. With this variable set, We'll later activate and update a enemy that we find in the inactive state."
msgstr ""

#: src/part3/enemies.md:371
msgid "```rgbasm,linenos,start=290\n"
"TryToSpawnEnemies::"
msgstr "```rgbasm,linenos,start=290\n"
"TryToSpawnEnemies::"

#: src/part3/enemies.md:374
msgid "    ; Increase our spwncounter\n"
"    ld a, [wSpawnCounter]\n"
"    inc a\n"
"    ld [wSpawnCounter], a"
msgstr ""

#: src/part3/enemies.md:379
msgid "    ; Check our spawn acounter\n"
"    ; Stop if it's below a given value\n"
"    ld a, [wSpawnCounter]\n"
"    cp a, ENEMY_SPAWN_DELAY_MAX\n"
"    ret c"
msgstr ""

#: src/part3/enemies.md:385
msgid "    ; Check our next enemy x position variable\n"
"    ; Stop if it's non zero\n"
"    ld a, [wNextEnemyXPosition]\n"
"    cp a, 0\n"
"    ret nz"
msgstr ""

#: src/part3/enemies.md:391
msgid "    ; Make sure we don't have the max amount of enmies\n"
"    ld a, [wActiveEnemyCounter]\n"
"    cp a, MAX_ENEMY_COUNT\n"
"    ret nc"
msgstr ""

#: src/part3/enemies.md:396
msgid "GetSpawnPosition:"
msgstr "GetSpawnPosition:"

#: src/part3/enemies.md:398
msgid "    ; Generate a semi random value\n"
"    call rand\n"
"    \n"
"    ; make sure it's not above 150\n"
"    ld a,b\n"
"    cp a, 150\n"
"    ret nc"
msgstr ""

#: src/part3/enemies.md:406
msgid "    ; make sure it's not below 24\n"
"    ld a, b\n"
"    cp a, 24\n"
"    ret c"
msgstr ""

#: src/part3/enemies.md:411
msgid "    ; reset our spawn counter\n"
"    ld a, 0\n"
"    ld [wSpawnCounter], a\n"
"    \n"
"    ld a, b\n"
"    ld [wNextEnemyXPosition], a"
msgstr ""

#: src/part3/collision.md:1
msgid "# Collision Detection"
msgstr ""

#: src/part3/collision.md:3
msgid "Collision Detection is cruical to games. It can be a very complicated topic. In Galactic Armada, things will be kept super simple. We're going to perform a basic implementation of \"Axis-Aligned Bounding Box Collision Detection\":"
msgstr ""

#: src/part3/collision.md:5
msgid "> One of the simpler forms of collision detection is between two rectangles that are axis aligned ‚Äî meaning no rotation. The algorithm works by ensuring there is no gap between any of the 4 sides of the rectangles. Any gap means a collision does not exist.[^mdn_source]"
msgstr ""

#: src/part3/collision.md:7
msgid "The easiest way to check for overlap, is to check the difference bewteen their centers. If the absolute value of their x & y differences (I'll refer to as \"the absolute difference\") are BOTH smaller than the sum of their half widths, we have a collision. This collision detection is run for bullets against enemies, and enemies against the player. Here's a visualization with bullets and enemies."
msgstr ""

#: src/part3/collision.md:9
msgid "![CollisionDetectionVisualized.png](../assets/part3/img/CollisionDetectionVisualized.png)"
msgstr ""

#: src/part3/collision.md:11
msgid "For this, we've created a basic function called \"CheckObjectPositionDifference\". This function will help us check for overlap on the x or y axis. When the (absolute) difference between the first two values passed is greater than the third value passed, it jump's to the label passed in the fourth parameter."
msgstr ""

#: src/part3/collision.md:13
msgid "Here's an example of how to call this function:"
msgstr ""

#: src/part3/collision.md:15
msgid "> We have the player's x & y position in registers d & e respectively. We have the enemy's x & y position in registers b & c respectively. If there is no overlap on the x or y axis, the program jumps to the \"NoCollisionWithPlayer\" label."
msgstr ""

#: src/part3/collision.md:17
msgid "```rgbasm,linenos,start=696"
msgstr "```rgbasm,linenos,start=696"

#: src/part3/collision.md:19
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ; Check the absolute distances. Jump to 'NoAxisOverlap' on failure\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/collision.md:24
msgid "    ld a, b\n"
"    ld [wObject1Value], a"
msgstr "    ld a, b\n"
"    ld [wObject1Value], a"

#: src/part3/collision.md:27
#: src/part3/enemy-player-collision.md:37
#: src/part3/enemy-player-collision.md:89
msgid "    ld a, d\n"
"    ld [wObject2Value], a"
msgstr "    ld a, d\n"
"    ld [wObject2Value], a"

#: src/part3/collision.md:30
#: src/part3/enemy-player-collision.md:40
#: src/part3/enemy-player-collision.md:92
#: src/part3/enemy-bullet-collision.md:148
msgid "    ; Save if the minimum distance\n"
"    ld a, 16\n"
"    ld [wSize], a"
msgstr "    ; Salva la distanza minima\n"
"    ld a, 16\n"
"    ld [wSize], a"

#: src/part3/collision.md:34
#: src/part3/enemy-player-collision.md:44
#: src/part3/enemy-player-collision.md:96
#: src/part3/enemy-bullet-collision.md:89
#: src/part3/enemy-bullet-collision.md:152
msgid "    call CheckObjectPositionDifference"
msgstr "    call CheckObjectPositionDifference"

#: src/part3/collision.md:36
msgid "    ld a, [wResult]\n"
"    cp a, 0\n"
"    jp z, NoAxisOverlap"
msgstr "    ld a, [wResult]\n"
"    cp a, 0\n"
"    jp z, NoAxisOverlap"

#: src/part3/collision.md:40
msgid "OverlapExists:"
msgstr "OverlapExists:"

#: src/part3/collision.md:42
msgid "  ... There is an overlap"
msgstr "  ... Abbiamo una sovrapposizione"

#: src/part3/collision.md:44
msgid "NoAxisOverlap:"
msgstr "NoAxisOverlap:"

#: src/part3/collision.md:46
msgid "  ... no overlap\n"
"    "
msgstr "  ... nessuna sovrapposizione\n"
"    "

#: src/part3/collision.md:51
msgid "When checking for collision, we'll use that function twice. Once for the x-axis, and again for the y-axis."
msgstr ""

#: src/part3/collision.md:53
msgid "> NOTE: We don't need to test the y-axis if the x-axis fails. "
msgstr ""

#: src/part3/collision.md:55
msgid "The source code for that function looks like this:"
msgstr ""

#: src/part3/collision.md:57
msgid "```rgbasm,linenos,start=1\n"
"include \"src/main/utils/hardware.inc\"\n"
"include \"src/main/utils/constants.inc\"\n"
"include \"src/main/utils/hardware.inc\""
msgstr "```rgbasm,linenos,start=1\n"
"include \"src/main/utils/hardware.inc\"\n"
"include \"src/main/utils/constants.inc\"\n"
"include \"src/main/utils/hardware.inc\""

#: src/part3/collision.md:62
msgid "SECTION \"CollisionUtilsVariables\", WRAM0"
msgstr ""

#: src/part3/collision.md:64
msgid "wResult::db;\n"
"wSize::db;\n"
"wObject1Value:: db\n"
"wObject2Value:: db"
msgstr ""

#: src/part3/collision.md:69
msgid "SECTION \"CollisionUtils\", ROM0"
msgstr ""

#: src/part3/collision.md:71
msgid "CheckObjectPositionDifference::"
msgstr ""

#: src/part3/collision.md:73
msgid "    ; at this point in time; e = enemy.y, b =bullet.y"
msgstr ""

#: src/part3/collision.md:75
msgid "    ld a, [wObject1Value]\n"
"    ld e, a\n"
"    ld a, [wObject2Value]\n"
"    ld b, a"
msgstr ""

#: src/part3/collision.md:80
msgid "    ld a, [wSize]\n"
"    ld d, a"
msgstr ""

#: src/part3/collision.md:83
msgid "    ; subtract  bullet.y, (aka b) - (enemy.y+8, aka e)\n"
"    ; carry means e<b, means enemy.bottom is visually above bullet.y (no collision)"
msgstr ""

#: src/part3/collision.md:86
msgid "    ld a, e\n"
"    add a, d\n"
"    cp a, b"
msgstr ""

#: src/part3/collision.md:90
msgid "    ;  carry means  no collision\n"
"    jp c, CheckObjectPositionDifference_Failure"
msgstr ""

#: src/part3/collision.md:93
msgid "    ; subtract  enemy.y-8 (aka e) - bullet.y (aka b)\n"
"    ; no carry means e>b, means enemy.top is visually below bullet.y (no collision)\n"
"    ld a, e\n"
"    sub a, d\n"
"    cp a, b"
msgstr ""

#: src/part3/collision.md:99
msgid "    ; no carry means no collision\n"
"    jp nc, CheckObjectPositionDifference_Failure"
msgstr ""

#: src/part3/collision.md:102
msgid "    ld a,1\n"
"    ld [wResult], a\n"
"    ret;"
msgstr ""

#: src/part3/collision.md:106
msgid "    \n"
"CheckObjectPositionDifference_Failure:"
msgstr ""

#: src/part3/collision.md:109
msgid "    ld a,0\n"
"    ld [wResult], a\n"
"    ret;"
msgstr ""

#: src/part3/collision.md:115
msgid "[^mdn_source]:\n"
"From [mdn web docs - 2D collision detection](https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection)"
msgstr ""

#: src/part3/enemy-player-collision.md:1
msgid "# Enemy-Player Collision"
msgstr ""

#: src/part3/enemy-player-collision.md:3
msgid "Our enemy versus player collision detection starts with us getting our player's unscaled x position. We'll store that value in d."
msgstr ""

#: src/part3/enemy-player-collision.md:5
msgid "```rgbasm,linenos,start=6\n"
"CheckEnemyPlayerCollision::"
msgstr ""

#: src/part3/enemy-player-collision.md:8
msgid "    ; Get our player's unscaled x position in d\n"
"    ld a, [wPlayerPositionX+0]\n"
"    ld d,a"
msgstr ""

#: src/part3/enemy-player-collision.md:12
msgid "    ld a, [wPlayerPositionX+1]\n"
"    ld e,a"
msgstr "    ld a, [wPlayerPositionX+1]\n"
"    ld e,a"

#: src/part3/enemy-player-collision.md:15
msgid "    srl e\n"
"    rr d\n"
"    srl e\n"
"    rr d\n"
"    srl e\n"
"    rr d\n"
"    srl e\n"
"    rr d\n"
"    \n"
"```"
msgstr "    srl e\n"
"    rr d\n"
"    srl e\n"
"    rr d\n"
"    srl e\n"
"    rr d\n"
"    srl e\n"
"    rr d\n"
"    \n"
"```"

#: src/part3/enemy-player-collision.md:26
msgid "With our player's x position in d, we'll compare it against a previously saved enemy x position variable. If they are more than 16 pixels apart, we'll jump to the \"NoCollisionWithPlayer\" label."
msgstr ""

#: src/part3/enemy-player-collision.md:28
msgid "```rgbasm,linenos,start=25"
msgstr "```rgbasm,linenos,start=25"

#: src/part3/enemy-player-collision.md:30
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ; Check the x distances. Jump to 'NoCollisionWithPlayer' on failure\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/enemy-player-collision.md:34
msgid "    ld a, [wCurrentEnemyX]\n"
"    ld [wObject1Value], a"
msgstr "    ld a, [wCurrentEnemyX]\n"
"    ld [wObject1Value], a"

#: src/part3/enemy-player-collision.md:46
#: src/part3/enemy-player-collision.md:98
msgid "    ld a, [wResult]\n"
"    cp a, 0\n"
"    jp z, NoCollisionWithPlayer\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr "    ld a, [wResult]\n"
"    cp a, 0\n"
"    jp z, NoCollisionWithPlayer\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"

#: src/part3/enemy-player-collision.md:54
msgid "After checking the x axis, if the code gets this far there was an overlap. We'll do the same for the y axis next."
msgstr ""

#: src/part3/enemy-player-collision.md:56
msgid "We'll get the player's unscaled y position. We'll store that value in d for consistency."
msgstr ""

#: src/part3/enemy-player-collision.md:58
msgid "```rgbasm,linenos,start=49\n"
"    ; Get our player's unscaled y position in d\n"
"    ld a, [wPlayerPositionY+0]\n"
"    ld d,a"
msgstr ""

#: src/part3/enemy-player-collision.md:63
msgid "    ld a, [wPlayerPositionY+1]\n"
"    ld e,a"
msgstr "    ld a, [wPlayerPositionY+1]\n"
"    ld e,a"

#: src/part3/enemy-player-collision.md:66
msgid "    srl e\n"
"    rr d\n"
"    srl e\n"
"    rr d\n"
"    srl e\n"
"    rr d\n"
"    srl e\n"
"    rr d"
msgstr "    srl e\n"
"    rr d\n"
"    srl e\n"
"    rr d\n"
"    srl e\n"
"    rr d\n"
"    srl e\n"
"    rr d"

#: src/part3/enemy-player-collision.md:77
msgid "Just like before, we'll compare our player's unscaled y position (stored in d) against a previously saved enemy y position variable. If they are more than 16 pixels apart, we'll jump to the \"NoCollisionWithPlayer\" label. "
msgstr ""

#: src/part3/enemy-player-collision.md:79
msgid "```rgbasm,linenos,start=67"
msgstr "```rgbasm,linenos,start=67"

#: src/part3/enemy-player-collision.md:81
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ; Check the y distances. Jump to 'NoCollisionWithPlayer' on failure\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/enemy-player-collision.md:86
msgid "    ld a, [wCurrentEnemyY]\n"
"    ld [wObject1Value], a"
msgstr "    ld a, [wCurrentEnemyY]\n"
"    ld [wObject1Value], a"

#: src/part3/enemy-player-collision.md:105
msgid "The \"NoCollisionWithPlayer\", just set's the \"wResult\" to 0 for failure. If overlap occurs on both axis, we'll isntead set 1 for success."
msgstr ""

#: src/part3/enemy-player-collision.md:107
msgid "```rgbasm,linenos,start=91"
msgstr "```rgbasm,linenos,start=91"

#: src/part3/enemy-player-collision.md:109
msgid "    ld a, 1\n"
"    ld [wResult], a"
msgstr "    ld a, 1\n"
"    ld [wResult], a"

#: src/part3/enemy-player-collision.md:112
msgid "    ret\n"
"    \n"
"NoCollisionWithPlayer::"
msgstr "    ret\n"
"    \n"
"NoCollisionWithPlayer::"

#: src/part3/enemy-player-collision.md:116
msgid "    ld a, 0\n"
"    ld [wResult], a"
msgstr "    ld a, 0\n"
"    ld [wResult], a"

#: src/part3/enemy-player-collision.md:123
msgid "That's the enemy-player collision logic. Callers of the function can simply check the \"wResult\" variable to determine if there was collision."
msgstr ""

#: src/part3/enemy-bullet-collision.md:1
msgid "# Enemy-Bullet Collision"
msgstr ""

#: src/part3/enemy-bullet-collision.md:3
msgid "When we are udating enemies, we'll call a function called \"CheckCurrentEnemyAgainstBullets\". This will check the current enemy against all active bullets."
msgstr ""

#: src/part3/enemy-bullet-collision.md:5
msgid "This fuction needs to loop through the bullet object pool, and check if our current enemy overlaps any bullet on both the x and y axis. If so, we'll deactivate the enemy and bullet."
msgstr ""

#: src/part3/enemy-bullet-collision.md:7
msgid "Our \"CheckCurrentEnemyAgainstBullets\" function starts off in a manner similar to how we updated enemies & bullets."
msgstr ""

#: src/part3/enemy-bullet-collision.md:9
msgid "> This function expects \"hl\" points to the curent enemy. We'll save that in a variable for later usage."
msgstr ""

#: src/part3/enemy-bullet-collision.md:11
msgid "```rgbasm,linenos,start=2\n"
"include \"src/main/utils/hardware.inc\"\n"
"include \"src/main/utils/constants.inc\"\n"
"include \"src/main/utils/hardware.inc\""
msgstr "```rgbasm,linenos,start=2\n"
"include \"src/main/utils/hardware.inc\"\n"
"include \"src/main/utils/constants.inc\"\n"
"include \"src/main/utils/hardware.inc\""

#: src/part3/enemy-bullet-collision.md:16
msgid "SECTION \"EnemyBulletCollisionVariables\", WRAM0"
msgstr "SECTION \"EnemyBulletCollisionVariables\", WRAM0"

#: src/part3/enemy-bullet-collision.md:18
msgid "wEnemyBulletCollisionCounter: db\n"
"wBulletAddresses: dw"
msgstr "wEnemyBulletCollisionCounter: db\n"
"wBulletAddresses: dw"

#: src/part3/enemy-bullet-collision.md:21
msgid "SECTION \"EnemyBulletCollision\", ROM0"
msgstr "SECTION \"EnemyBulletCollision\", ROM0"

#: src/part3/enemy-bullet-collision.md:23
msgid "; called from enemies.asm\n"
"CheckCurrentEnemyAgainstBullets::"
msgstr ""

#: src/part3/enemy-bullet-collision.md:27
msgid "    ld a, l\n"
"    ld [wUpdateEnemiesCurrentEnemyAddress+0], a\n"
"    ld a, h\n"
"    ld [wUpdateEnemiesCurrentEnemyAddress+1], a"
msgstr "    ld a, l\n"
"    ld [wUpdateEnemiesCurrentEnemyAddress+0], a\n"
"    ld a, h\n"
"    ld [wUpdateEnemiesCurrentEnemyAddress+1], a"

#: src/part3/enemy-bullet-collision.md:32
msgid "    ld a, 0\n"
"    ld [wEnemyBulletCollisionCounter], a\n"
"    \n"
"    ; Copy our bullets address into wBulletAddress\n"
"    ld a, LOW(wBullets)\n"
"    ld l, a\n"
"    ld a, HIGH(wBullets)\n"
"    ld h, a"
msgstr ""

#: src/part3/enemy-bullet-collision.md:41
msgid "    jp CheckCurrentEnemyAgainstBullets_PerBullet\n"
"```"
msgstr "    jp CheckCurrentEnemyAgainstBullets_PerBullet\n"
"```"

#: src/part3/enemy-bullet-collision.md:44
msgid "As we loop through the bullets, we need to make sure we only check active bullets. Inactive bullets will be skipped."
msgstr ""

#: src/part3/enemy-bullet-collision.md:46
msgid "```rgbasm,linenos,start=53\n"
"CheckCurrentEnemyAgainstBullets_PerBullet:"
msgstr "```rgbasm,linenos,start=53\n"
"CheckCurrentEnemyAgainstBullets_PerBullet:"

#: src/part3/enemy-bullet-collision.md:49
msgid "    ld a, [hl]\n"
"    cp a, 1\n"
"    jp nz, CheckCurrentEnemyAgainstBullets_Loop\n"
"```\n"
"First, we need to check if the current enemy and current bullet are overlapping on the x axis. We'll get the enemy's x position in e, and the bullet's x position in b. From there, we'll again call our \"CheckObjectPositionDifference\" function. If it returns a failure (wResult=0), we'll start with the next bullet."
msgstr ""

#: src/part3/enemy-bullet-collision.md:55
msgid "> We add an offset to the x coordinates so they measure from their centers. That offset is half it's respective object's width."
msgstr ""

#: src/part3/enemy-bullet-collision.md:57
msgid "```rgbasm,linenos,start=59\n"
"CheckCurrentEnemyAgainstBullets_Check_X_Overlap:"
msgstr "```rgbasm,linenos,start=59\n"
"CheckCurrentEnemyAgainstBullets_Check_X_Overlap:"

#: src/part3/enemy-bullet-collision.md:60
msgid "    ; Save our first byte address\n"
"    push hl"
msgstr ""

#: src/part3/enemy-bullet-collision.md:65
msgid "    ; Get our x position\n"
"    ld a, [hli]\n"
"    add a, 4\n"
"    ld b, a"
msgstr "    ; Ottieni la posizione x\n"
"    ld a, [hli]\n"
"    add a, 4\n"
"    ld b, a"

#: src/part3/enemy-bullet-collision.md:72
#: src/part3/enemy-bullet-collision.md:136
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;; Start: Checking the absolute difference\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"
msgstr ""

#: src/part3/enemy-bullet-collision.md:76
#: src/part3/enemy-bullet-collision.md:140
msgid "    ; The first value\n"
"    ld a, b\n"
"    ld [wObject1Value], a"
msgstr ""

#: src/part3/enemy-bullet-collision.md:80
msgid "    ; The second value\n"
"    ld a, [wCurrentEnemyX]\n"
"    add a, 8\n"
"    ld [wObject2Value], a"
msgstr ""

#: src/part3/enemy-bullet-collision.md:85
msgid "    ; Save if the minimum distance\n"
"    ld a, 12\n"
"    ld [wSize], a"
msgstr ""

#: src/part3/enemy-bullet-collision.md:91
msgid "    \n"
"    ld a, [wResult]\n"
"    cp a, 0\n"
"    jp z, CheckCurrentEnemyAgainstBullets_Check_X_Overlap_Fail"
msgstr ""

#: src/part3/enemy-bullet-collision.md:96
msgid "    \n"
"    pop hl"
msgstr ""

#: src/part3/enemy-bullet-collision.md:99
msgid "    jp CheckCurrentEnemyAgainstBullets_PerBullet_Y_Overlap"
msgstr ""

#: src/part3/enemy-bullet-collision.md:101
msgid "CheckCurrentEnemyAgainstBullets_Check_X_Overlap_Fail:"
msgstr ""

#: src/part3/enemy-bullet-collision.md:103
msgid "    pop hl\n"
"    pop hl"
msgstr ""

#: src/part3/enemy-bullet-collision.md:106
msgid "    jp CheckCurrentEnemyAgainstBullets_Loop\n"
"```"
msgstr ""

#: src/part3/enemy-bullet-collision.md:109
msgid "Next we restore our hl variable so we can get the y position of our current bullet. Once we have that y position, we'll get the current enemy's y position and check for an overlap on the y axis. If no overlap is found, we'll loop to the next bullet. Otherwise, we have a collision."
msgstr ""

#: src/part3/enemy-bullet-collision.md:111
msgid "```rgbasm,linenos,start=113\n"
"    \n"
"CheckCurrentEnemyAgainstBullets_PerBullet_Y_Overlap:"
msgstr ""

#: src/part3/enemy-bullet-collision.md:115
msgid "    ; get our bullet 16-bit y position\n"
"    ld a, [hli]\n"
"    ld b, a"
msgstr ""

#: src/part3/enemy-bullet-collision.md:119
msgid "    ld a, [hli]\n"
"    ld c, a"
msgstr ""

#: src/part3/enemy-bullet-collision.md:122
msgid "    ; Descale our 16 bit y position\n"
"    srl c\n"
"    rr b\n"
"    srl c\n"
"    rr b\n"
"    srl c\n"
"    rr b\n"
"    srl c\n"
"    rr b"
msgstr ""

#: src/part3/enemy-bullet-collision.md:132
msgid "    ; preserve our first byte addresss\n"
"    pop hl\n"
"    push hl"
msgstr ""

#: src/part3/enemy-bullet-collision.md:144
msgid "    ; The second value\n"
"    ld a, [wCurrentEnemyY]\n"
"    ld [wObject2Value], a"
msgstr ""

#: src/part3/enemy-bullet-collision.md:154
msgid "    pop hl\n"
"    \n"
"    ld a, [wResult]\n"
"    cp a, 0\n"
"    jp z, CheckCurrentEnemyAgainstBullets_Loop\n"
"    jp CheckCurrentEnemyAgainstBullets_PerBullet_Collision"
msgstr ""

#: src/part3/enemy-bullet-collision.md:161
msgid "    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    ;; End: Checking the absolute difference\n"
"    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"    \n"
"```"
msgstr ""

#: src/part3/enemy-bullet-collision.md:167
msgid "If a collision was detected (overlap on x and y axis), we'll set the current active byte for that bullet to 0. Also , we'll set the active byte for the current enemy to zero. Before we end the function, we'll increase and redraw the score, and decrease how many bullets & enemies we have by one."
msgstr ""

#: src/part3/enemy-bullet-collision.md:169
msgid "```rgbasm,linenos,start=168\n"
"CheckCurrentEnemyAgainstBullets_PerBullet_Collision:"
msgstr ""

#: src/part3/enemy-bullet-collision.md:172
msgid "    ; set the active byte  and x value to 0 for bullets\n"
"    ld a, 0\n"
"    ld [hli], a\n"
"    ld [hl], a"
msgstr ""

#: src/part3/enemy-bullet-collision.md:177
msgid "    ld a, [wUpdateEnemiesCurrentEnemyAddress+0]\n"
"    ld l, a\n"
"    ld a, [wUpdateEnemiesCurrentEnemyAddress+1]\n"
"    ld h, a"
msgstr ""

#: src/part3/enemy-bullet-collision.md:182
msgid "    ; set the active byte  and x value to 0 for enemies\n"
"    ld a, 0\n"
"    ld [hli], a\n"
"    ld [hl], a\n"
"    \n"
"    call IncreaseScore;\n"
"    call DrawScore"
msgstr ""

#: src/part3/enemy-bullet-collision.md:190
msgid "    ; Decrease how many active enemies their are\n"
"    ld a, [wActiveEnemyCounter]\n"
"    dec a\n"
"    ld [wActiveEnemyCounter], a"
msgstr ""

#: src/part3/enemy-bullet-collision.md:195
msgid "    ; Decrease how many active bullets their are\n"
"    ld a, [wActiveBulletCounter]\n"
"    dec a\n"
"    ld [wActiveBulletCounter], a"
msgstr ""

#: src/part3/enemy-bullet-collision.md:203
msgid "If no collision happened, we'll continue our loop through the enemy bullets. When we've checked all the bullets, we'll end the function."
msgstr ""

#: src/part3/enemy-bullet-collision.md:205
msgid "```rgbasm,linenos,start=33\n"
"CheckCurrentEnemyAgainstBullets_Loop:"
msgstr ""

#: src/part3/enemy-bullet-collision.md:208
msgid "    ; increase our counter\n"
"    ld a, [wEnemyBulletCollisionCounter]\n"
"    inc a\n"
"    ld [wEnemyBulletCollisionCounter], a"
msgstr ""

#: src/part3/enemy-bullet-collision.md:213
msgid "    ; Stop if we've checked all bullets\n"
"    cp a, MAX_BULLET_COUNT\n"
"    ret nc"
msgstr ""

#: src/part3/enemy-bullet-collision.md:217
msgid "    ; Increase the  data our address is pointing to\n"
"    ld a, l\n"
"    add a, PER_BULLET_BYTES_COUNT\n"
"    ld  l, a\n"
"    ld a, h\n"
"    adc a, 0\n"
"    ld  h, a\n"
"```"
msgstr ""

#: src/part3/conclusion.md:1
msgid "# Conclusion"
msgstr "# Conclusione"

#: src/part3/conclusion.md:3
msgid "If you liked this tutorial, and you want to take things to the next level, here are some ideas:"
msgstr ""

#: src/part3/conclusion.md:5
msgid "- Add an options menu (for typewriter speed, difficulty, disable audio)\n"
"- Add Ship Select and different player ships\n"
"- Add the ability to upgrade your bullet type\n"
"- Add dialogue and \"waves\" of enemies\n"
"- Add different types of enemies\n"
"- Add a boss\n"
"- Add a level select"
msgstr ""

#: src/next.md:1
msgid "# Where to go next"
msgstr "# Prossimi passi"

#: src/next.md:3
msgid "Oh."
msgstr "Oh."

#: src/next.md:5
msgid "Well, you've reached the end of the tutorial...\n"
"And yes, as you can see, it's not finished _yet_."
msgstr ""

#: src/next.md:8
msgid "We're actively working on new content (and improvement of the existing one)."
msgstr ""

#: src/next.md:10
msgid "In the meantime, the best course of action is to peruse the [resources](resources.html) in the next section, and experiment by yourself.\n"
"Well, given that, it may be a good idea to [ask around](help-feedback.html) for advice.\n"
"A lot of the problems and questions you will be encountering have already been solved, so others can‚Äîand will!‚Äîhelp you getting started faster."
msgstr ""

#: src/next.md:14
msgid "If you enjoyed the tutorial, please consider [contributing](index.html#contributing), donating to our [OpenCollective](https://opencollective.com/gbdev) or simply share the link to this book."
msgstr ""

#: src/resources.md:1
msgid "# Resources"
msgstr "# Risorse"

#: src/resources.md:3
msgid "## Help channels"
msgstr "## Canali di aiuto"

#: src/resources.md:5
msgid "- [GBDev community home page](https://gbdev.io) and [chat channels](https://gbdev.io/chat)."
msgstr "- [home page della comunit√† GBDev](https://gbdev.io) e [canali di chat](https://gbdev.io/chat)."

#: src/resources.md:7
msgid "## Other tutorials"
msgstr "## Altri tutorial"

#: src/resources.md:9
msgid "- [evie's interrupts tutorial](https://evie.gbdev.io/resources/interrupts) should help you understand how to use interrupts, and what they are useful for.\n"
"- [tbsp's \"Simple GB ASM examples\"](https://github.com/tbsp/simple-gb-asm-examples) is a collection of ROMs, each built from a single, fairly short source file.\n"
"  If you found this tutorial too abstract and/or want to get your feet wet, this is a good place to go to!\n"
"- [GB assembly by example](https://github.com/daid/gameboy-assembly-by-example), Daid's collection of code snippets.\n"
"  Consider this a continuation of the tutorial, but without explanations; it's still useful to peruse them and ask about it, they are overall good quality."
msgstr ""

#: src/resources.md:15
msgid "## Complements"
msgstr "## Ringraziamenti"

#: src/resources.md:17
msgid "Did you enjoy the tutorial or one of the above?\n"
"The following should prove useful along the rest of your journey!"
msgstr "Vi √® piaciuto il tutorial o uno dei precedenti?\n"
"Quanto segue dovrebbe esservi utile per il resto del vostro viaggio!"

#: src/resources.md:20
msgid "- [RGBDS' online documentation](https://rgbds.gbdev.io/docs/) is always useful!\n"
"  Notably, you'll find [an instruction reference](https://rgbds.gbdev.io/docs/gbz80.7) and [the reference on RGBASM's syntax and features](https://rgbds.gbdev.io/docs/rgbasm.5).\n"
"- [Pan Docs](https://gbdev.io/pandocs) are _the_ reference for all Game Boy hardware.\n"
"  It's a good idea to consult it if you aare unsure how a register works, or if you're wondering how to do something.\n"
"- [gb-optables](https://gbdev.io/gb-opcodes/optables) is a more compact instruction table, it becomes more useful when you stop needing the instructions' descriptions."
msgstr ""

#: src/thanks.md:1
msgid "# Special Thanks"
msgstr "# Ringraziamenti speciali"

#: src/thanks.md:3
msgid "Big thank you to [Twoflower/Triad](https://www.pouet.net/user.php?who=21982) for making the Hello World graphic."
msgstr "Un grande ringraziamento a [Twoflower/Triad](https://www.pouet.net/user.php?who=21982) per aver realizzato la grafica di Hello World."

#: src/thanks.md:5
msgid "I can't thank enough Chlo√© and many others for their continued support."
msgstr "Non ringrazier√≤ mai abbastanza Chlo√© e molti altri per il loro continuo sostegno."

#: src/thanks.md:7
msgid "Thanks to the GBDev community for being so nice throughout the years."
msgstr "Grazie alla comunit√† GBDev per essere stata cos√¨ gentile nel corso degli anni."

#: src/thanks.md:9
msgid "**You are all great. Thank you so very much.**"
msgstr "**Siete tutti fantastici. Grazie mille.**"

#: src/thanks.md:13
msgid "Thank you to the [Rust language](https://www.rust-lang.org) team for making [mdBook](https://github.com/rust-lang/mdBook), which powers this book (this honestly slick design is the stock one!!)"
msgstr "Si ringrazia il team di [Rust language](https://www.rust-lang.org) per aver realizzato [mdBook](https://github.com/rust-lang/mdBook), che alimenta questo libro (questo design, onestamente elegante, √® quello di serie!!!)."

#: src/thanks.md:15
msgid "Greets to AYCE, Phantasy, TPPDevs/RainbowDevs, Plutiedev, lft/kryo :)"
msgstr "Un saluto a AYCE, Phantasy, TPPDevs/RainbowDevs, Plutiedev, lft/kryo :)"

#: src/thanks.md:17
msgid "Shoutouts to [Eievui](https://eievui.ml), [Rangi](https://github.com/Rangi42), [MarkSixtyFour](https://github.com/MarkSixtyFour), [ax6](https://github.com/aaaaaa123456789), [Ba≈ùto](https://github.com/basxto), [bbbbbr](https://github.com/bbbbbr), and [bitnenfer](https://github.com/bitnenfer)!"
msgstr "Un saluto a [Eievui](https://eievui.ml), [Rangi](https://github.com/Rangi42), [MarkSixtyFour](https://github.com/MarkSixtyFour), [ax6](https://github.com/aaaaaa123456789), [Ba≈ùto](https://github.com/basxto), [bbbbbr](https://github.com/bbbbbr) e [bitnenfer](https://github.com/bitnenfer)!"

#: src/thanks.md:19
msgid "The Italian translation is curated by [Antonio Guido Leoni](https://github.com/Street-Philosopher), [Antonio Vivace](https://github.com/avivace), [Mattia Fortunati](https://github.com/MattiaFortunati), Matilde Della Morte and [Daniele Scasciafratte](https://github.com/mte90)."
msgstr ""

